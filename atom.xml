<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mikyi喵喵呜~</title>
  
  <subtitle>So we beat on, boats against the current, borne back ceaselessly into the past.</subtitle>
  <link href="http://remedios14.github.io/atom.xml" rel="self"/>
  
  <link href="http://remedios14.github.io/"/>
  <updated>2025-08-27T15:56:31.136Z</updated>
  <id>http://remedios14.github.io/</id>
  
  <author>
    <name>Mikyi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>cry for me-口琴谱</title>
    <link href="http://remedios14.github.io/2025/08/27/music-life/harmonica/cry%20for%20me-%E5%8F%A3%E7%90%B4%E8%B0%B1/"/>
    <id>http://remedios14.github.io/2025/08/27/music-life/harmonica/cry%20for%20me-%E5%8F%A3%E7%90%B4%E8%B0%B1/</id>
    <published>2025-08-27T15:53:56.000Z</published>
    <updated>2025-08-27T15:56:31.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原链接"><a href="#原链接" class="headerlink" title="原链接"></a><a href="https://www.bilibili.com/video/BV15WAWexEPW/">原链接</a></h1><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">2 452 1(#65) 1(#6) 42</span><br><span class="line">(4)4 5 2 45#6 642 52 #66 4</span><br><span class="line"></span><br><span class="line">#66~#6</span><br><span class="line">#66~4</span><br><span class="line">#66~#6</span><br><span class="line">#66~4</span><br><span class="line">#6#6 #3#3 #76#6</span><br><span class="line">#6#6 #3#3 #76#6</span><br><span class="line">#3#6#6 64</span><br><span class="line">4 4#6#6 64</span><br><span class="line">4 #6#6#3#3#3 #76#6</span><br><span class="line">#6#6#6 #3#3 #3#76#6</span><br><span class="line">#66 #6 #3#3#3#66 #6</span><br><span class="line">#66 #6</span><br><span class="line">222 #2 #2 2</span><br><span class="line">(#6#6#6#6)2 (#7#6#6#6)</span><br><span class="line">222 2#22 #22</span><br><span class="line">(#6#6#6) 21 (#6#6)</span><br><span class="line">2#22 2#22 #22</span><br><span class="line">222 2#22 #22</span><br><span class="line">(#6#6#6)2 1(#6#6)</span><br><span class="line">(#6#6#6#6#6 #6)21 (#66#6)</span><br><span class="line">221(#6)1 221</span><br><span class="line">(#6#6)2222 2222 1(#6)1</span><br><span class="line">(#6#6) 2#2 2#221(#6)</span><br><span class="line">(#6#6) 222#22 22 (#6#6#6)</span><br><span class="line">(#6#6) 2#2 2#22 1(#6#6)</span><br><span class="line">(#6) 2#22 22 1(#6)1</span><br><span class="line">(#6) 2#2 2#22 1(#6#6)</span><br><span class="line">(#6#6) 2#22 #2#22 1(#66#6)</span><br><span class="line">#6#6 #3#3 #76#6</span><br><span class="line">#6#6 #3#3 #76#6</span><br><span class="line">#3#6#6 64</span><br><span class="line">4 4#6#6 64</span><br><span class="line">4 #6#6#3#3#3 #76#6</span><br><span class="line">#6#6#6 #3#3 #3#76#6</span><br><span class="line">#66 #6 #3#3#3#66 #6</span><br><span class="line">#66 #6</span><br><span class="line">#6#6 444 4#76#6</span><br><span class="line">#6#6 444 4#66 5</span><br><span class="line">#6#6#6 #3#3 #3#76#6</span><br><span class="line">#6#6#6 #3#3 #3#76#6</span><br><span class="line">#6#66 #6</span><br><span class="line">4444 44 #66 5</span><br><span class="line">444 6#6</span><br><span class="line">444444 #7#6 665</span><br><span class="line">444 6#6</span><br><span class="line">4444444 #66 65</span><br><span class="line">444#66 5</span><br><span class="line">444#66 5</span><br><span class="line">4444 44 44 #7#66 #6~</span><br><span class="line">#66~4</span><br><span class="line">#66~#6</span><br><span class="line">#66~4</span><br><span class="line"></span><br><span class="line">4444 44 #66 5</span><br><span class="line">444 6#6</span><br><span class="line">444444 #7#6 665</span><br><span class="line">444 6#6</span><br><span class="line">4444444 #66 65</span><br><span class="line">444#66 5</span><br><span class="line">444#66 5</span><br><span class="line">4444 44 44 #7#66 #6~</span><br><span class="line">#66~4</span><br><span class="line">#66~#6</span><br><span class="line">#66~4</span><br><span class="line">442254</span><br><span class="line">442254</span><br><span class="line">4#6#6 644</span><br><span class="line">4 4#6#6 644</span><br><span class="line">4 #6#6#3 #3#76#6</span><br><span class="line">#6#6#6 #3#3 #3#76#6</span><br><span class="line">#66 #6 #3#3#3#66 #6</span><br><span class="line">#66 #6</span><br><span class="line">#6#6#6 #3#7 #6</span><br><span class="line">6#6#3#7 #7 #6</span><br><span class="line">#3#6#6 644</span><br><span class="line">4 4#66 #6</span><br><span class="line">66#6 #7 #6</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原链接&quot;&gt;&lt;a href=&quot;#原链接&quot; class=&quot;headerlink&quot; title=&quot;原链接&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV15WAWexEPW/&quot;&gt;原链接&lt;/a&gt;&lt;/h1&gt;&lt;figure cl</summary>
      
    
    
    
    <category term="口琴" scheme="http://remedios14.github.io/categories/%E5%8F%A3%E7%90%B4/"/>
    
    
    <category term="音乐" scheme="http://remedios14.github.io/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>鸟之诗-口琴谱</title>
    <link href="http://remedios14.github.io/2025/08/27/music-life/harmonica/%E9%B8%9F%E4%B9%8B%E8%AF%97-%E5%8F%A3%E7%90%B4%E8%B0%B1/"/>
    <id>http://remedios14.github.io/2025/08/27/music-life/harmonica/%E9%B8%9F%E4%B9%8B%E8%AF%97-%E5%8F%A3%E7%90%B4%E8%B0%B1/</id>
    <published>2025-08-27T15:53:07.000Z</published>
    <updated>2025-08-27T15:54:25.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原链接"><a href="#原链接" class="headerlink" title="原链接"></a><a href="https://www.bilibili.com/video/BV1XJN3e4E9e/">原链接</a></h1><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">(7) #1 26#4 #43#4</span><br><span class="line">3#463 #12#1 #1(7#4)</span><br><span class="line">(7) #1 26#4 #43#4</span><br><span class="line">3#46#4 6【2#1】 7#4</span><br><span class="line">3#4 6 7 【#1】 #4 #43#4</span><br><span class="line">3#463 #12#1 #1(7#4)</span><br><span class="line">(7) #1 26#4 #43#4</span><br><span class="line">3#4 6#4 6【2#1】 7 7【#1】 7</span><br><span class="line"></span><br><span class="line">#5#5 #5#5#5 #4#4</span><br><span class="line">#5#6 7#6#5 #2#2 #1(7)</span><br><span class="line">#5#5 #5#5#5 #4#4</span><br><span class="line">#2#4 #5#67</span><br><span class="line">#5#5 #5#5#5 #4#4</span><br><span class="line">#5#6 7#6#5 #2#2 #1(7)</span><br><span class="line">#2#2#2 #2#1#2 #4#2 #4#5 7#6#5</span><br><span class="line">#4 #3#3#3#2#3</span><br><span class="line">#3#4#5 #2 (#7#7)</span><br><span class="line">(#7)#1#2 #3#3#3(#6)#3</span><br><span class="line">#2#1#2 #2#1#2#5 #5</span><br><span class="line">#3#3#3#2#3 #3#4#5 #2 (#7)(#7)</span><br><span class="line">(#7)#1#2 #5#5#5#4#5</span><br><span class="line">#43#4 #43#4#5 #5</span><br><span class="line">(7) #1 26#4 #43#4</span><br><span class="line">3#463 #12#1 #1(7#4)</span><br><span class="line">(7) #1 26#4 #43#4</span><br><span class="line">3#46#4 6【2#1】 7#4</span><br><span class="line">3#4 6 7 【#1】 #4 #43#4</span><br><span class="line">3#463 #12#1 #1(7#4)</span><br><span class="line">(7) #1 26#4 #43#4</span><br><span class="line">3#46#4 6【2#1】 77 7【#1】 7</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原链接&quot;&gt;&lt;a href=&quot;#原链接&quot; class=&quot;headerlink&quot; title=&quot;原链接&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1XJN3e4E9e/&quot;&gt;原链接&lt;/a&gt;&lt;/h1&gt;&lt;figure cl</summary>
      
    
    
    
    <category term="口琴" scheme="http://remedios14.github.io/categories/%E5%8F%A3%E7%90%B4/"/>
    
    
    <category term="音乐" scheme="http://remedios14.github.io/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>卡农-口琴谱</title>
    <link href="http://remedios14.github.io/2025/08/27/music-life/harmonica/%E5%8D%A1%E5%86%9C-%E5%8F%A3%E7%90%B4%E8%B0%B1/"/>
    <id>http://remedios14.github.io/2025/08/27/music-life/harmonica/%E5%8D%A1%E5%86%9C-%E5%8F%A3%E7%90%B4%E8%B0%B1/</id>
    <published>2025-08-27T15:43:17.000Z</published>
    <updated>2025-08-27T15:53:13.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原链接"><a href="#原链接" class="headerlink" title="原链接"></a><a href="https://www.bilibili.com/video/BV1Hy4y1x7nd/">原链接</a></h1><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">321（76567） 321（76567）</span><br><span class="line">1（7）</span><br><span class="line">135643（6）11</span><br><span class="line">（7）1（7）1（357） 1 3 5356</span><br><span class="line">4324 321（7） （654）11</span><br><span class="line">（7）1（7）1（357） 1 3 5356</span><br><span class="line">4324 321（7） （654）11</span><br><span class="line">（7）2 3 3212 3432321</span><br><span class="line">（7）1（7） （535） （6 7）1（5 6 4）121</span><br><span class="line">（7）2 3 3212 3432321</span><br><span class="line">（7）1（7）（535）（6）1 43 21</span><br><span class="line">（6 4） 121 （7）2</span><br><span class="line">［［［</span><br><span class="line">5 345 345（5 67）12 343</span><br><span class="line">123（34 5654 5）1（7）1（6）</span><br><span class="line">1（76）（5454 345）1（7）1（6）</span><br><span class="line">1（7）1（7）1（7 67）1 2345</span><br><span class="line">］］］</span><br><span class="line">3 123 212（7） 12 321（7）1</span><br><span class="line">（67）1（12 3432 3）1（7）1（6）</span><br><span class="line">1（76 5454 345）1（7）1（6）</span><br><span class="line">1（7）1（767）1 21（7）1（67）1</span><br><span class="line"></span><br><span class="line">3453（7）12（7）1231 321（7）</span><br><span class="line">（67）1（6） （56）1（5）</span><br><span class="line">（67）1（65） 1231</span><br><span class="line">3453 2342 123 1（7）</span><br><span class="line">5435 665 46 554 35</span><br><span class="line">6546 546 765（567）12</span><br><span class="line">3 3212 3432321</span><br><span class="line">（7）1（7）（535）（6 7）1（5 6 4）121</span><br><span class="line">（7）23 3212 3432321</span><br><span class="line">（7）1 （357）1 357［1］7654</span><br><span class="line">5432 321（7） 1（765 6545 64）1（7）12</span><br><span class="line">［［［［</span><br><span class="line">3 3456 543 1234 321</span><br><span class="line">（67）1（5）1（7）1</span><br><span class="line">（5）1（7）1（6）1（7）1（6）1（7）1（7）12</span><br><span class="line">］］］］</span><br><span class="line">321（76567） 321（76567）</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原链接&quot;&gt;&lt;a href=&quot;#原链接&quot; class=&quot;headerlink&quot; title=&quot;原链接&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1Hy4y1x7nd/&quot;&gt;原链接&lt;/a&gt;&lt;/h1&gt;&lt;figure cl</summary>
      
    
    
    
    <category term="口琴" scheme="http://remedios14.github.io/categories/%E5%8F%A3%E7%90%B4/"/>
    
    
    <category term="音乐" scheme="http://remedios14.github.io/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>secret-base-口琴谱</title>
    <link href="http://remedios14.github.io/2025/08/14/music-life/harmonica/secret-base-%E5%8F%A3%E7%90%B4%E8%B0%B1/"/>
    <id>http://remedios14.github.io/2025/08/14/music-life/harmonica/secret-base-%E5%8F%A3%E7%90%B4%E8%B0%B1/</id>
    <published>2025-08-13T16:48:19.000Z</published>
    <updated>2025-08-13T16:55:59.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原链接"><a href="#原链接" class="headerlink" title="原链接"></a><a href="https://www.bilibili.com/video/BV15a411x74m/">原链接</a></h1><p><strong>全程升半音</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">145 566 66 65 55 55 54 44 44 4111</span><br><span class="line">145 56 66 66 6【1】 666 66 545 66</span><br><span class="line">565 44 565 44</span><br><span class="line">44 44 44 44 4431</span><br><span class="line">144 44 44 44 4431</span><br><span class="line">144 44 44 44 511 1(6)11 22</span><br><span class="line">44 44 44 44 431</span><br><span class="line">144 44 44 44 4431</span><br><span class="line">4 4 4444 511 11(6) 11 22</span><br><span class="line">2 221 23 33 333 34 44 1(6) 12 22</span><br><span class="line">2 221 23 33 332 33 44</span><br><span class="line">565 42 565 42</span><br><span class="line">565 41 11(6) 12 22</span><br><span class="line">65 42 5654 222 54</span><br><span class="line">145 566 66 65 55 55 54 44 44 4111</span><br><span class="line">145 66 66 66 6【1】 666 66 545 66</span><br><span class="line">145 56 66 66 66 55 55 55 55 5 44 44 4111</span><br><span class="line">145 56 66 66 6【1】 666 66 54 55 66</span><br><span class="line">565 44 565 44</span><br><span class="line"></span><br><span class="line">2 221 23 3 332 34 4 11(6) 11 22</span><br><span class="line">2 221 23 33 332 33 44</span><br><span class="line">565 42 565 42 565 41 11(6) 1 22</span><br><span class="line">65 42 5654 222 54</span><br><span class="line">145 56 66 66 66 55 55 55 55 5 44 44 4111</span><br><span class="line">145 66 66 66 6【1】 666 66 54 55 66</span><br><span class="line">565 44 565 44</span><br><span class="line">5 43 2321 2 23 3 4 5 43 2 31</span><br><span class="line">1(6) 12 22 221 2333 332 3444 654 566</span><br><span class="line">66 562 5654 222 54</span><br><span class="line">145 566 66 65 55 55 54 44 44 44 4111</span><br><span class="line">145 56 66 66 6【1】 666 66 54 55 66</span><br><span class="line">145 56 66 66 66 55 55 5 5 54 44 44 4111</span><br><span class="line">145 56 66 66 6【1】 666 66 54 55 66</span><br><span class="line">145 566 66 65 55 55 54 44 44 4111</span><br><span class="line">145 66 66 66 6【1】 666 66 545 66</span><br><span class="line">145 56 66 66 66 55 55 55 55 5 44 44 4111</span><br><span class="line">145 56 66 66 6【1】 666 66 54 55 66</span><br><span class="line">565 44 565 44 565 44 565 44</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原链接&quot;&gt;&lt;a href=&quot;#原链接&quot; class=&quot;headerlink&quot; title=&quot;原链接&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV15a411x74m/&quot;&gt;原链接&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong</summary>
      
    
    
    
    <category term="口琴" scheme="http://remedios14.github.io/categories/%E5%8F%A3%E7%90%B4/"/>
    
    
    <category term="音乐" scheme="http://remedios14.github.io/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>樱花樱花想见你-口琴谱</title>
    <link href="http://remedios14.github.io/2025/08/14/music-life/harmonica/%E6%A8%B1%E8%8A%B1%E6%A8%B1%E8%8A%B1%E6%83%B3%E8%A7%81%E4%BD%A0-%E5%8F%A3%E7%90%B4%E8%B0%B1/"/>
    <id>http://remedios14.github.io/2025/08/14/music-life/harmonica/%E6%A8%B1%E8%8A%B1%E6%A8%B1%E8%8A%B1%E6%83%B3%E8%A7%81%E4%BD%A0-%E5%8F%A3%E7%90%B4%E8%B0%B1/</id>
    <published>2025-08-13T16:46:27.000Z</published>
    <updated>2025-08-13T16:47:44.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原链接"><a href="#原链接" class="headerlink" title="原链接"></a><a href="https://www.bilibili.com/video/BV1jx411A7gw/">原链接</a></h1><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">23 #4#4#4#4 #476 #4#4#4333 3222 25#4</span><br><span class="line">(7)#1 222 #4#4#4#4 3 #1#1#123 (6)(6)(6)65#4 #45#4</span><br><span class="line">23 #4#4#4#4 #476 #4#4#4333 3222 25#4</span><br><span class="line">(77)#12 2#4#4#4#4 3 #1#1#1#123 (6)(6)(6)6655 #4</span><br><span class="line">223#4 #4#4#4#4 33 2#12</span><br><span class="line">23#4#4 #4#433 2#12</span><br><span class="line"></span><br><span class="line">(6)#4#4#4 #4#4#4#4333#4 (7)222 22223#4 (6)(6)222 2222 (6)(6)333 3332</span><br><span class="line">#4#4#4 4#4#4#4333#4 (7)222 22223#4 (6)(6)222 2222 (6)(6)333 3 32</span><br><span class="line">(7)(7)(7)222 #1 #12#1(76) (7) (7)2#1(7)(6)(#4)</span><br><span class="line">(7)(7)(7)(7)2222 #1 #12#1(76) (7) (7)2#1(7)(6)(#4)</span><br><span class="line">2222 #4#4#4#4 3 3#432#12 #4#4#4 3 #12223#43 #123#43 2223#4336#4</span><br><span class="line"></span><br><span class="line">23 #4#4#4#4 #476 #4#4#4333 3222 25#4</span><br><span class="line">(7)#1 222 #4#4#4#4 3 #1#1#123 (6)(6)(6)65#4 #4#45#4</span><br><span class="line">23 #4#4#4#4 #476 #4#4#4333 3222 25#4</span><br><span class="line">(77)#12 2#4#4#4#4 3 #1#1#1#123 (666)6655 #4</span><br><span class="line">223#4 #4#4#4#4 33 2#12</span><br><span class="line">23#4#4 #4#433 2#12</span><br><span class="line"></span><br><span class="line">#4#4#4(6) #4 #4(6) 333(6) 3333 222(6) 222233#4 (6)(6)222 2222 (6)(6)(6)3333 32</span><br><span class="line">#4#4#4(6) #4#4#4#4 333(6) 3333 222(6) 222233#4 (6)(6)222 2222 (6)(6)(6)333 3332</span><br><span class="line">(7)(7)(7)222 #1 #12#1(76) (7) (7)2#1(7)(6)(#4)</span><br><span class="line">(7)(7)(7)(7)2222 #1 #12#1(76) (7) (7)2#1(7)(6)(#4)</span><br><span class="line">2222 #4#4#4#4 3 3#432#12 #4#4#4 3 #12223#43 #123#43 2223#4336#4</span><br><span class="line"></span><br><span class="line">23 #4#4#4#4 #476 #4#4#4333 3222 25#4</span><br><span class="line">(7)#1 222 #4#4#4#4 3 #1#1#123 (6)(6)(6)65#4 #4#45#4</span><br><span class="line">23 #4#4#4#4 #476 #4#4#4333 3222 25#4</span><br><span class="line">(7)(7)#12 2#4#4#4#4 3 #1#1#1#123 (6)(6)(6)6655 #4</span><br><span class="line">223#4</span><br><span class="line">23#43#476#43#432 23#43#47[#1]76[#1#12]</span><br><span class="line"></span><br><span class="line">23 #4#4#4#4 #476 #4#4#4333 3222 25#4</span><br><span class="line">(7)#1 222 #4#4#4#4 3 #1#1#123 (6)(6)(6)65#4 #4#45#4</span><br><span class="line">23 #4#4#4#4 #476 #4#4#4333 3222 25#4</span><br><span class="line">(77)#12 2#4#4#4#4 3 #1#1#1#123 (666)6655 #4</span><br><span class="line"></span><br><span class="line">3#4 #5#5#5#5 #5[#1]7 #5#5#5#4#4#4#4 #4333 36#5</span><br><span class="line">#1#2 333 #5#5#5#5 #4 #2#2#2#23#4 (7)(7)(7)76#5 #5#56#5</span><br><span class="line">3#4 #5#5#5#5 #5[#1]7 #5#5#5#4#4#4#4 #4333 36#5</span><br><span class="line">#1#1#23 3#5#5#5#5 #4 #2#2#2#23#4 (7)(7)(7)766#5#5</span><br><span class="line">33#4#5 #5#5#5#5 #4 3#23</span><br><span class="line">3#4#5#5 #5#5#4#4 3#23</span><br><span class="line">3#4#5#5 #5#5#4#4 3#23</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原链接&quot;&gt;&lt;a href=&quot;#原链接&quot; class=&quot;headerlink&quot; title=&quot;原链接&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1jx411A7gw/&quot;&gt;原链接&lt;/a&gt;&lt;/h1&gt;&lt;figure cl</summary>
      
    
    
    
    <category term="口琴" scheme="http://remedios14.github.io/categories/%E5%8F%A3%E7%90%B4/"/>
    
    
    <category term="音乐" scheme="http://remedios14.github.io/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>美丽之物-口琴谱</title>
    <link href="http://remedios14.github.io/2025/08/14/music-life/harmonica/%E7%BE%8E%E4%B8%BD%E4%B9%8B%E7%89%A9-%E5%8F%A3%E7%90%B4%E8%B0%B1/"/>
    <id>http://remedios14.github.io/2025/08/14/music-life/harmonica/%E7%BE%8E%E4%B8%BD%E4%B9%8B%E7%89%A9-%E5%8F%A3%E7%90%B4%E8%B0%B1/</id>
    <published>2025-08-13T16:41:34.000Z</published>
    <updated>2025-08-27T15:38:39.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原链接"><a href="#原链接" class="headerlink" title="原链接"></a><a href="https://www.bilibili.com/video/BV11G4y1N7ZQ/">原链接</a></h1><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#4 7 【#1 2#1】 76#4 32 36 #4</span><br><span class="line">7【#1 2#1】 76#4 #432 32 2</span><br><span class="line">7【#1 2#1】 76#4 #432 36 #4</span><br><span class="line">#432 36 #4 #432 32 2</span><br><span class="line"></span><br><span class="line">||:</span><br><span class="line">43 21(6 545)1 (6)</span><br><span class="line">23 43 21(6 54 544)</span><br><span class="line">23 43 21(6 545)1 (6)</span><br><span class="line">(545)1 (6 54 54 4)</span><br><span class="line">【第二遍升高音】</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">#56 【22 21】</span><br><span class="line">#66 #66 #6【1 22 21】</span><br><span class="line">【21】 #665 566</span><br><span class="line">|</span><br><span class="line">66543 5 431</span><br><span class="line">2(6) 12 1234 345</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">6 66675 #43</span><br><span class="line">33 #45#4 32</span><br><span class="line">(7)#12 #43 23</span><br><span class="line">23#456 66675 #43</span><br><span class="line">33 #463 22</span><br><span class="line">(7)#12 #4323</span><br><span class="line">6 66675 #43</span><br><span class="line">33 #45#4 32</span><br><span class="line">(7)#12 #4323</span><br><span class="line">23#456 66675 #43</span><br><span class="line">33#4 【2#1】 6#4</span><br><span class="line">23#4 5#433</span><br><span class="line">23 456</span><br><span class="line">56 【11】 55</span><br><span class="line">654 454 32 21</span><br><span class="line">777 67 【#12】</span><br><span class="line">【#1#1#1】 7【#1】 76</span><br><span class="line">(7)#12 3#456 #4 #6 7 【#1】</span><br><span class="line">【2#1】76#4 #432 36 #4</span><br><span class="line">7【#1 2#1】 76#4 #432 32 2</span><br><span class="line">7【#1 2#1】 76#4 #432 36 #4</span><br><span class="line">#432 36 #4 #432 32 2</span><br><span class="line">:||</span><br><span class="line"></span><br><span class="line">23456 #6654 3456</span><br><span class="line">#66 #66 54 454</span><br><span class="line">2345 666 #665 4564</span><br><span class="line">【21 1】#6 65 64</span><br><span class="line"></span><br><span class="line">#5#4 3#2 3#4 7#5 #4#5</span><br><span class="line">#13#4 #5#5 #5#4#5</span><br><span class="line">(7)3#4 #5#5#5#5 #56 #5#43#4 #47</span><br><span class="line">#1#2#4#4#4 #4#5676 #5#43 76</span><br><span class="line">67【#1】 667【#1 #1】77</span><br><span class="line">#4#5 6#56 73【#1#1】 76 #5#4 33</span><br><span class="line">#4#5 6#56 73【#1#1#1 #1】7 6#5#4 3#4</span><br><span class="line">#4#5 6#56 73【#1#1】 77 6#5#4 33</span><br><span class="line">#4#5 6#56 73【#1#1#1 #1】7 6#5#4 3#4</span><br><span class="line">#67【#1 2#1】 76#4 32 36 #4</span><br><span class="line">7【#1 2#1】 76#4 #432 32 2</span><br><span class="line">7【#1 2#1】 76#4 #432 36 #4</span><br><span class="line">#432 36 #4 #432 32 2</span><br><span class="line">43 21(6 545)1 (6)</span><br><span class="line">23 43 21(6 54 544)</span><br><span class="line">23 43 21(6 545)1 (6)</span><br><span class="line">(545)1 (6 54 54 4)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原链接&quot;&gt;&lt;a href=&quot;#原链接&quot; class=&quot;headerlink&quot; title=&quot;原链接&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV11G4y1N7ZQ/&quot;&gt;原链接&lt;/a&gt;&lt;/h1&gt;&lt;figure cl</summary>
      
    
    
    
    <category term="口琴" scheme="http://remedios14.github.io/categories/%E5%8F%A3%E7%90%B4/"/>
    
    
    <category term="音乐" scheme="http://remedios14.github.io/tags/%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
  <entry>
    <title>Npm 概述</title>
    <link href="http://remedios14.github.io/2023/12/24/FrontEnd/Npm-%E6%A6%82%E8%BF%B0/"/>
    <id>http://remedios14.github.io/2023/12/24/FrontEnd/Npm-%E6%A6%82%E8%BF%B0/</id>
    <published>2023-12-24T14:16:29.000Z</published>
    <updated>2023-12-24T14:23:44.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="yosoro"><a href="#yosoro" class="headerlink" title="yosoro~"></a>yosoro~</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;yosoro&quot;&gt;&lt;a href=&quot;#yosoro&quot; class=&quot;headerlink&quot; title=&quot;yosoro~&quot;&gt;&lt;/a&gt;yosoro~&lt;/h1&gt;</summary>
      
    
    
    
    <category term="通用工具" scheme="http://remedios14.github.io/categories/%E9%80%9A%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="前端" scheme="http://remedios14.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>React-QuickIntro</title>
    <link href="http://remedios14.github.io/2023/12/24/FrontEnd/React/React-QuickIntro/"/>
    <id>http://remedios14.github.io/2023/12/24/FrontEnd/React/React-QuickIntro/</id>
    <published>2023-12-24T11:34:57.000Z</published>
    <updated>2023-12-24T14:19:44.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="yosoro"><a href="#yosoro" class="headerlink" title="yosoro~"></a>yosoro~</h1><p>比较适合喜欢 ‘手动搓轮子’ 的选手，如果对前端没有很多经验，不如学 Vue 更直接有效。</p><h2 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h2><h3 id="安装与启动"><a href="#安装与启动" class="headerlink" title="安装与启动"></a>安装与启动</h3><ul><li>先获取 npm 以及配置镜像仓库，正式创建项目需要 <code>create-react-app</code> 脚手架，但运行项目并不必要</li><li><code>npx create-react-app &lt;project-name&gt;</code> 使用 npx 可以临时安装并且在初始化后自动删除</li><li><code>npm start</code> 来启动项目</li></ul><h3 id="基本项目结构"><a href="#基本项目结构" class="headerlink" title="基本项目结构"></a>基本项目结构</h3><ul><li><code>index.js</code> 为项目总入口，启动时默认在该页面</li><li><code>App.js</code> 为基础组建，读入数据并模块化显示，需要将组件内的函数 export 才能供外部使用</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;yosoro&quot;&gt;&lt;a href=&quot;#yosoro&quot; class=&quot;headerlink&quot; title=&quot;yosoro~&quot;&gt;&lt;/a&gt;yosoro~&lt;/h1&gt;&lt;p&gt;比较适合喜欢 ‘手动搓轮子’ 的选手，如果对前端没有很多经验，不如学 Vue 更直接有效。&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    <category term="React" scheme="http://remedios14.github.io/categories/React/"/>
    
    
    <category term="前端" scheme="http://remedios14.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="QuickStart" scheme="http://remedios14.github.io/tags/QuickStart/"/>
    
    <category term="React" scheme="http://remedios14.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>WebGL-入门环境搭建</title>
    <link href="http://remedios14.github.io/2022/09/11/Graphics/WebGL-%E5%85%A5%E9%97%A8%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://remedios14.github.io/2022/09/11/Graphics/WebGL-%E5%85%A5%E9%97%A8%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2022-09-11T12:30:55.000Z</published>
    <updated>2022-09-11T12:31:28.000Z</updated>
    
    
    
    
    <category term="WebGL" scheme="http://remedios14.github.io/categories/WebGL/"/>
    
    
  </entry>
  
  <entry>
    <title>Golang-常规算法实现</title>
    <link href="http://remedios14.github.io/2022/09/10/Golang/Golang-%E5%B8%B8%E8%A7%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://remedios14.github.io/2022/09/10/Golang/Golang-%E5%B8%B8%E8%A7%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-09-10T15:20:41.000Z</published>
    <updated>2023-12-24T07:14:33.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="暂时不更新"><a href="#暂时不更新" class="headerlink" title="暂时不更新"></a>暂时不更新</h1><p>虽然没有变成很厉害的程序员，但是已经开始工作了，非必要情况下反而没意愿去实现算法了，所以此篇章可能长期保持不更新状态</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;暂时不更新&quot;&gt;&lt;a href=&quot;#暂时不更新&quot; class=&quot;headerlink&quot; title=&quot;暂时不更新&quot;&gt;&lt;/a&gt;暂时不更新&lt;/h1&gt;&lt;p&gt;虽然没有变成很厉害的程序员，但是已经开始工作了，非必要情况下反而没意愿去实现算法了，所以此篇章可能长期保持不更新状态</summary>
      
    
    
    
    <category term="Golang" scheme="http://remedios14.github.io/categories/Golang/"/>
    
    
    <category term="algorithm" scheme="http://remedios14.github.io/tags/algorithm/"/>
    
    <category term="datastruct" scheme="http://remedios14.github.io/tags/datastruct/"/>
    
  </entry>
  
  <entry>
    <title>Golang-QuickIntro</title>
    <link href="http://remedios14.github.io/2022/09/03/Golang/Golang-QuickIntro/"/>
    <id>http://remedios14.github.io/2022/09/03/Golang/Golang-QuickIntro/</id>
    <published>2022-09-02T16:26:02.000Z</published>
    <updated>2022-09-02T17:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="yosoro"><a href="#yosoro" class="headerlink" title="yosoro~"></a>yosoro~</h1><p>编写一个简单的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在当前目录下 <code>go build</code> 编译所有 <code>.go</code> 文件并生成同名的二进制文件(或者 <code>go build &lt;name.go&gt;</code> 编译指定文件)，在终端直接执行；</p><p>或者 <code>go run &lt;name.go&gt;</code> 直接运行指定代码文件</p><p>主要特性：</p><ul><li>自动垃圾回收 GC</li><li>更丰富的内置类型</li><li>函数多返回值</li><li>错误处理</li><li>匿名函数和闭包</li><li>类型和接口</li><li>并发编程</li><li>反射</li><li>语言交互性</li></ul><h2 id="Go-语言结构"><a href="#Go-语言结构" class="headerlink" title="Go 语言结构"></a>Go 语言结构</h2><p>基础组成包括如下：</p><ul><li>包声明（必须在第一行声明所属）；<code>package main</code> 表示一个可独立执行的程序，每个 Go 应用程序都至少要有一个</li><li>引入包，格式 <code>import &quot;pname&quot;</code>，其中 fmt 包进行 IO，<code>fmt.Println()</code></li><li>函数（<code>main</code> 函数是可执行程序必须的，但若有 <code>init()</code> 函数会先执行它）</li><li>变量</li><li>语句&amp;表达式</li><li>注释（同 Java）</li></ul><p>标识符（包括常量、变量、类型、函数名、结构字段等）若以大写字母开头如 <code>Group1</code> 则可被外部的包使用（类似 public）；否则类似 protected，仅包内部可见</p><p>注意 <code>&#123;</code> 不能单独构成一行</p><h2 id="Go-语言基础语法"><a href="#Go-语言基础语法" class="headerlink" title="Go 语言基础语法"></a>Go 语言基础语法</h2><p>通常一行完成一条语句无需 <code>;</code> 换行，但若多条写在同一行（虽然不推荐）则需要用 <code>;</code> 分隔</p><p>字符串直接用 <code>+</code> 拼接</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><div class="table-container"><table><thead><tr><th>break</th><th>default</th><th>func</th><th>interface</th><th>select</th></tr></thead><tbody><tr><td>case</td><td>defer</td><td>go</td><td>map</td><td>struct</td></tr><tr><td>chan</td><td>else</td><td>goto</td><td>package</td><td>switch</td></tr><tr><td>const</td><td>fallthrough</td><td>if</td><td>range</td><td>type</td></tr><tr><td>continue</td><td>for</td><td>import</td><td>return</td><td>var</td></tr></tbody></table></div><p>以及预定义标识符</p><div class="table-container"><table><thead><tr><th>append</th><th>bool</th><th>byte</th><th>cap</th><th>close</th><th>complex</th><th>complex64</th><th>complex128</th><th>uint16</th></tr></thead><tbody><tr><td>copy</td><td>false</td><td>float32</td><td>float64</td><td>imag</td><td>int</td><td>int8</td><td>int16</td><td>uint32</td></tr><tr><td>int32</td><td>int64</td><td>iota</td><td>len</td><td>make</td><td>new</td><td>nil</td><td>panic</td><td>uint64</td></tr><tr><td>print</td><td>println</td><td>real</td><td>recover</td><td>string</td><td>true</td><td>uint</td><td>uint8</td><td>uintptr</td></tr></tbody></table></div><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><p>空格增加可读性</p><p><code>fmt.Sprintf</code> 格式化输出字符串</p><h2 id="Go-语言数据类型"><a href="#Go-语言数据类型" class="headerlink" title="Go 语言数据类型"></a>Go 语言数据类型</h2><p>数据类型用于声明函数和变量，申请内存</p><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">类型和描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>布尔型</strong> 布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。默认值 <strong>false</strong></td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>数字类型</strong> 整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。默认值（包括 complex64/128） 为 <strong>0</strong></td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>字符串类型:</strong> 字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。默认值为 <strong>“”</strong> （空字符串）</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>派生类型:</strong> 包括：(a) 指针类型（Pointer）(b) 数组类型(c) 结构化类型(struct)(d) Channel 类型(e) 函数类型(f) 切片类型(g) 接口类型（interface）(h) Map 类型</td></tr></tbody></table></div><p>派生类型中， 1) 指针；2) 数组；3) Map；4) Chan；5) Func；6) error (接口) 类型的默认值为 <strong>nil</strong></p><h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">类型和描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>uint8</strong> 无符号 8 位整型 (0 到 255)</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>uint16</strong> 无符号 16 位整型 (0 到 65535)</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>uint32</strong> 无符号 32 位整型 (0 到 4294967295)</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>uint64</strong> 无符号 64 位整型 (0 到 18446744073709551615)</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>int8</strong> 有符号 8 位整型 (-128 到 127)</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><strong>int16</strong> 有符号 16 位整型 (-32768 到 32767)</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><strong>int32</strong> 有符号 32 位整型 (-2147483648 到 2147483647)</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><strong>int64</strong> 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)</td></tr></tbody></table></div><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">类型和描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>float32</strong> IEEE-754 32位浮点型数</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>float64</strong> IEEE-754 64位浮点型数</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>complex64</strong> 32 位实数和虚数</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>complex128</strong> 64 位实数和虚数</td></tr></tbody></table></div><h4 id="其他数字类型"><a href="#其他数字类型" class="headerlink" title="其他数字类型"></a>其他数字类型</h4><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">类型和描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>byte</strong> 类似 uint8</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>rune</strong> 类似 int32</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>uint</strong> 32 或 64 位</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>int</strong> 与 uint 一样大小</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>uintptr</strong> 无符号整型，用于存放一个指针</td></tr></tbody></table></div><h2 id="Go-语言变量"><a href="#Go-语言变量" class="headerlink" title="Go 语言变量"></a>Go 语言变量</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier1[, identifier2] <span class="keyword">type</span></span><br></pre></td></tr></table></figure><p>一般使用 <code>var</code> 关键字，可同时声明多个变量，在最后指定类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">string</span> = <span class="string">&quot;Runoob&quot;</span></span><br><span class="line">    fmt.Println(a) <span class="comment">// Runoob</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> b, c <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    fmt.Println(b, c) <span class="comment">// 1 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三种声明方法"><a href="#三种声明方法" class="headerlink" title="三种声明方法"></a>三种声明方法</h3><ol><li>先初始化再赋值，需要指定类型</li><li>直接赋值，可以自动判断类型无需显式写 <code>type</code></li><li><code>:=</code> 完成声明和赋值，只能用于初次声明变量（也只能用在函数体中）</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x, y <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> (  <span class="comment">// 这种因式分解关键字的写法一般用于声明全局变量</span></span><br><span class="line">    a <span class="type">int</span></span><br><span class="line">    b <span class="type">bool</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c, d <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> e, f = <span class="number">123</span>, <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这种不带声明格式的只能在函数体中出现</span></span><br><span class="line"><span class="comment">//g, h := 123, &quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    g, h := <span class="number">123</span>, <span class="string">&quot;hello&quot;</span></span><br><span class="line">    <span class="built_in">println</span>(x, y, a, b, c, d, e, f, g, h)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h3><h4 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h4><p>所有像 int、float、bool 和 string 这些基本类型都属于值类型，其变量直接指向内存中的值，在 <code>=</code> 赋值时在内存中进行了拷贝</p><p><code>&amp;i</code> 获取到变量 <code>i</code> 的内存地址，如 0xf840000040 （每次运行的地址都可能不一样）。值类型变量的值存储在栈中。</p><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p><code>r1</code> 存储的是 <code>r1</code> 的值所在的内存地址（数字），或内存地址中第一个字所在的位置。</p><p>这个内存地址称之为指针，这个指针实际上也被存在另外的某一个值中。</p><p>当使用 <code>r2 = r1</code> 时，只有引用（地址）被复制</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li>在代码块中不使用一个声明的局部变量会<strong>编译错误</strong>，仅赋值也不行</li><li>全局变量允许声明不使用</li><li>交换变量值 <code>a, b = b, a</code> 在同类型变量间可用</li><li>空白标识符 <code>_</code> 用于抛弃值，其是一个只写变量，不能获取值</li></ul><h2 id="Go-语言常量-const"><a href="#Go-语言常量-const" class="headerlink" title="Go 语言常量 const"></a>Go 语言常量 const</h2><p>常量是一个简单值的标识符，在程序运行时不会被修改的量。</p><p>常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。定义格式如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> identifier [<span class="keyword">type</span>] = value</span><br></pre></td></tr></table></figure><p>可以省略 <code>[type]</code> 交给编译器自行判断</p><p>常量不能用 <code>:=</code> 语法声明</p><p>常量还可以用作枚举，也可以用内置函数计算表达式的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;unsafe&quot;</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="string">&quot;abc&quot;</span></span><br><span class="line">    <span class="comment">// 常量表达式用到的函数只能使用内置函数</span></span><br><span class="line">    b = <span class="built_in">len</span>(a)</span><br><span class="line">    c = unsafe.Sizeof(a)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">println</span>(a, b, c) <span class="comment">// abc 3 16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h3><p>特殊常量，可以认为是一个可以被编译器修改的常量</p><p>在 <code>const</code> 语句块中构成行索引，初始化 0，每行 <code>+1</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">            a = <span class="literal">iota</span>   <span class="comment">//0</span></span><br><span class="line">            b          <span class="comment">//1</span></span><br><span class="line">            c          <span class="comment">//2</span></span><br><span class="line">            d = <span class="string">&quot;ha&quot;</span>   <span class="comment">//独立值，iota += 1</span></span><br><span class="line">            e          <span class="comment">//&quot;ha&quot;   iota += 1</span></span><br><span class="line">            f = <span class="number">100</span>    <span class="comment">//iota +=1</span></span><br><span class="line">            g          <span class="comment">//100  iota +=1</span></span><br><span class="line">            h = <span class="literal">iota</span>   <span class="comment">//7,恢复计数</span></span><br><span class="line">            i          <span class="comment">//8</span></span><br><span class="line">    )</span><br><span class="line">    fmt.Println(a,b,c,d,e,f,g,h,i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">const</span> ( <span class="comment">// 进行了位运算</span></span><br><span class="line">    i=<span class="number">1</span>&lt;&lt;<span class="literal">iota</span></span><br><span class="line">    j=<span class="number">3</span>&lt;&lt;<span class="literal">iota</span></span><br><span class="line">    k</span><br><span class="line">    l</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;i=&quot;</span>,i) <span class="comment">// 1 —— 1 &lt;&lt; 0</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;j=&quot;</span>,j) <span class="comment">// 6 —— 3 &lt;&lt; 1</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;k=&quot;</span>,k) <span class="comment">// 12 —— 3 &lt;&lt; 2</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;l=&quot;</span>,l) <span class="comment">// 24 —— 3 &lt;&lt; 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Go-语言运算符"><a href="#Go-语言运算符" class="headerlink" title="Go 语言运算符"></a>Go 语言运算符</h2><p>算数、关系、逻辑、位、赋值、其他</p><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p><code>+ - * / % ++ --</code> 完全一致，其中 <code>/</code> 对整数为整除</p><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p><code>== != &gt; &lt; &gt;= &lt;=</code></p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p><code>&amp;&amp; || !</code></p><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p><code>&amp;</code> 与 <code>|</code> 或 <code>^</code> 异或 <code>&lt;&lt;</code> 左移 <code>&gt;&gt;</code> 右移</p><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>略</p><h3 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h3><div class="table-container"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">&amp;</td><td style="text-align:left">返回变量存储地址</td><td style="text-align:left">&a; 将给出变量的实际地址。</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">指针变量。</td><td style="text-align:left">*a; 是一个指针变量</td></tr></tbody></table></div><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><div class="table-container"><table><thead><tr><th style="text-align:left">优先级</th><th style="text-align:left">运算符</th></tr></thead><tbody><tr><td style="text-align:left">5</td><td style="text-align:left">* / % &lt;&lt; &gt;&gt; &amp; &amp;^</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">+ - \</td><td>^</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">== != &lt; &lt;= &gt; &gt;=</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">&amp;&amp;</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">\</td><td>\</td></tr></tbody></table></div><h2 id="Go-语言条件语句"><a href="#Go-语言条件语句" class="headerlink" title="Go 语言条件语句"></a>Go 语言条件语句</h2><p><code>if ... else if ... else ...</code> 类似 <code>Python</code> 无需括号，但 <code>&#123;&#125;</code> 必须</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在条件语句中声明变量（仅在条件语句 <code>if ... else ...</code> 内部生效的局部变量）</p><h3 id="Switch-语句"><a href="#Switch-语句" class="headerlink" title="Switch 语句"></a>Switch 语句</h3><p>自上到下逐一测试直到匹配（默认在 <code>case</code> 最后自带 <code>break</code> ，若不希望终止可以使用 <code>fallthrough</code> ）支持多值 match</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> var1 &#123;</span><br><span class="line">    <span class="keyword">case</span> val1:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> val2, val3, val4:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>var1</code> 可以是任何类型，而 <code>val1</code> 和 <code>val2</code> 只需要是同类型值（或表达式）即可</p><h4 id="Type-Switch"><a href="#Type-Switch" class="headerlink" title="Type Switch"></a>Type Switch</h4><p><code>switch</code> 的用法之一，用于判断某个 <code>interface</code> 变量中实际存储的变量类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> x.(<span class="keyword">type</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">type</span>:</span><br><span class="line">    statement(s)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">type</span>:</span><br><span class="line">    statement(s)</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 可选 */</span></span><br><span class="line">    statement(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fallthrough"><a href="#fallthrough" class="headerlink" title="fallthrough"></a>fallthrough</h4><p>写在原来 <code>break</code> 的位置，当遇到时会无视下一条 <code>case</code> 的条件执行下一条</p><h3 id="Select-语句"><a href="#Select-语句" class="headerlink" title="Select 语句"></a>Select 语句</h3><p>类似于通信的 <code>switch</code> 语句，每个 <code>case</code> 必须是一个通信操作（发送或接收）</p><p><code>select</code> 随机执行一个可运行的 <code>case</code> ，如果没有 <code>case</code> 可运行，则会阻塞直到有。</p><p>一个默认的子句应该总是可运行的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> c1, c2, c3 <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">   <span class="keyword">var</span> i1, i2 <span class="type">int</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> i1 = &lt;-c1:</span><br><span class="line">         fmt.Printf(<span class="string">&quot;received &quot;</span>, i1, <span class="string">&quot; from c1\n&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> c2 &lt;- i2:</span><br><span class="line">         fmt.Printf(<span class="string">&quot;sent &quot;</span>, i2, <span class="string">&quot; to c2\n&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> i3, ok := (&lt;-c3):  <span class="comment">// same as: i3, ok := &lt;-c3</span></span><br><span class="line">         <span class="keyword">if</span> ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;received &quot;</span>, i3, <span class="string">&quot; from c3\n&quot;</span>)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;c3 is closed\n&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Printf(<span class="string">&quot;no communication\n&quot;</span>)</span><br><span class="line">   &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>select</code> 语句的语法如下：</p><ul><li><p>每个 case 都必须是一个通信</p></li><li><p>所有 channel 表达式都会被求值</p></li><li><p>所有被发送的表达式都会被求值</p></li><li><p>如果人以某个通信可以进行，它就执行，<strong>其他被忽略</strong></p></li><li><p>如果有多个 case 都可以运行，Select 会<strong>随机</strong>公平地选出一个执行。<strong>其他不会执行</strong>。</p><p>否则：</p><ol><li>如果有 default 子句，则执行该语句</li><li>如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值</li></ol></li></ul><h2 id="Go-语言循环语句"><a href="#Go-语言循环语句" class="headerlink" title="Go 语言循环语句"></a>Go 语言循环语句</h2><p><code>for</code> 循环 </p><ul><li><code>for init; condition; post &#123;&#125;</code> 可以省略其中的 <code>init</code> 和 <code>post</code> （但要有分号）</li><li><p><code>for condition &#123;&#125;</code> 类同 <code>while</code> </p></li><li><p>直接 <code>for &#123;&#125;</code> 类同 C 中的 <code>for (;;)</code> ，会直接无限循环</p></li></ul><h4 id="For-each-range-循环"><a href="#For-each-range-循环" class="headerlink" title="For-each range 循环"></a>For-each range 循环</h4><p>可以对字符串、数组、切片等进行迭代输出元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> oldMap &#123;</span><br><span class="line">    newMap[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h3><h4 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h4><ul><li>用于循环语句中跳出循环，并开始执行<strong>循环之后</strong>的语句</li><li>在 switch 语句中执行一条 case 后跳出语句</li><li>在多重循环中用标号 label 标出想 break 的循环</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不使用标记</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;---- break ----&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;i: %d\n&quot;</span>, i)</span><br><span class="line">                <span class="keyword">for</span> i2 := <span class="number">11</span>; i2 &lt;= <span class="number">13</span>; i2++ &#123;</span><br><span class="line">                        fmt.Printf(<span class="string">&quot;i2: %d\n&quot;</span>, i2)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用标记</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;---- break label ----&quot;</span>)</span><br><span class="line">    re:</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;i: %d\n&quot;</span>, i)</span><br><span class="line">            <span class="keyword">for</span> i2 := <span class="number">11</span>; i2 &lt;= <span class="number">13</span>; i2++ &#123;</span><br><span class="line">                fmt.Printf(<span class="string">&quot;i2: %d\n&quot;</span>, i2)</span><br><span class="line">                <span class="keyword">break</span> re</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h4><p>可以使用 label ，其他无变化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不使用标记</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;---- continue ---- &quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;i: %d\n&quot;</span>, i)</span><br><span class="line">            <span class="keyword">for</span> i2 := <span class="number">11</span>; i2 &lt;= <span class="number">13</span>; i2++ &#123;</span><br><span class="line">                fmt.Printf(<span class="string">&quot;i2: %d\n&quot;</span>, i2)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用标记</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;---- continue label ----&quot;</span>)</span><br><span class="line">    re:</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;i: %d\n&quot;</span>, i)</span><br><span class="line">                <span class="keyword">for</span> i2 := <span class="number">11</span>; i2 &lt;= <span class="number">13</span>; i2++ &#123;</span><br><span class="line">                    fmt.Printf(<span class="string">&quot;i2: %d\n&quot;</span>, i2)</span><br><span class="line">                    <span class="keyword">continue</span> re</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="goto-语句"><a href="#goto-语句" class="headerlink" title="goto 语句"></a>goto 语句</h4><p>不推荐使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 循环 */</span></span><br><span class="line">   LOOP: <span class="keyword">for</span> a &lt; <span class="number">20</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> a == <span class="number">15</span> &#123;</span><br><span class="line">         <span class="comment">/* 跳过迭代 */</span></span><br><span class="line">         a = a + <span class="number">1</span></span><br><span class="line">         <span class="keyword">goto</span> LOOP</span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;a的值为 : %d\n&quot;</span>, a)</span><br><span class="line">      a++    </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Go-语言函数"><a href="#Go-语言函数" class="headerlink" title="Go 语言函数"></a>Go 语言函数</h2><p>最少有一个 main() 函数</p><p>函数声明告诉编译器 函数的名称，返回类型和参数</p><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">( [parameter list] )</span></span> [return_types] &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数定义解析：</p><ul><li>func ：函数由 func 开始声明</li><li>function_name ：函数名称，参数列表和返回值类型构成了函数签名</li><li>parameter list ：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的时参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数</li><li>return_types ：返回类型，函数返回一列值。return_types 时该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的</li><li>函数体：函数定义的代码集合</li></ul><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>可以前缀关键词实现不同形式的函数调用</p><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a><a href="http://blog.go-zh.org/defer-panic-and-recover">defer</a></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>defer 会将函数推迟到外层函数返回之后执行</p><p>推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用</p><p>推迟的函数调用会被压入一个栈中，最后按照后进先出顺序调用</p><h3 id="函数返回多个值"><a href="#函数返回多个值" class="headerlink" title="函数返回多个值"></a>函数返回多个值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">string</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a, b := swap(<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>)</span><br><span class="line">   fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>函数如果使用参数，该变量可称为函数的形参，形参就像定义在函数体内的局部变量</p><ul><li>值传递</li></ul><p>在调用函数时将实际参数复制一份传递到函数中，从而在函数中的修改不会影响到实际参数</p><p><strong>默认情况</strong>下，Go 语言使用的是值传递</p><ul><li>引用传递</li></ul><p>在调用函数时将实际参数的地址传递到函数中，从而在函数中对参数所进行的修改将影响到实际参数</p><p>操作上是将指针参数传递到函数内</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">100</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">int</span>= <span class="number">200</span></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换前，a 的值 : %d\n&quot;</span>, a )</span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换前，b 的值 : %d\n&quot;</span>, b )</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 调用 swap() 函数</span></span><br><span class="line"><span class="comment">   * &amp;a 指向 a 指针，a 变量的地址</span></span><br><span class="line"><span class="comment">   * &amp;b 指向 b 指针，b 变量的地址</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   swap(&amp;a, &amp;b)</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换后，a 的值 : %d\n&quot;</span>, a )</span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换后，b 的值 : %d\n&quot;</span>, b )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x *<span class="type">int</span>, y *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> temp <span class="type">int</span></span><br><span class="line">   temp = *x    <span class="comment">/* 保存 x 地址上的值 */</span></span><br><span class="line">   *x = *y      <span class="comment">/* 将 y 值赋给 x */</span></span><br><span class="line">   *y = temp    <span class="comment">/* 将 temp 值赋给 y */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数用法"><a href="#函数用法" class="headerlink" title="函数用法"></a>函数用法</h3><ul><li>传递给变量构成一个函数变量</li><li>闭包，借助匿名函数可直接使用函数内的变量而不必声明</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSequence</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   i:=<span class="number">0</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">      i+=<span class="number">1</span></span><br><span class="line">     <span class="keyword">return</span> i  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">/* nextNumber 为一个函数，函数 i 为 0 */</span></span><br><span class="line">   nextNumber := getSequence()  </span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 调用 nextNumber 函数，i 变量自增 1 并返回 */</span></span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 创建新的函数 nextNumber1，并查看结果 */</span></span><br><span class="line">   nextNumber1 := getSequence()  </span><br><span class="line">   fmt.Println(nextNumber1())</span><br><span class="line">   fmt.Println(nextNumber1())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法，即一个包含了接受者的函数，接受者可以使命名类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集（类似面向对象）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(variable_name variable_data_type)</span></span> function_name() [return_type] &#123;</span><br><span class="line">    <span class="comment">/* 函数体 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义结构体 */</span></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">  radius <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> c1 Circle</span><br><span class="line">  c1.radius = <span class="number">10.00</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;圆的面积 = &quot;</span>, c1.getArea())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该 method 属于 Circle 类型对象中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span></span> getArea() <span class="type">float64</span> &#123;</span><br><span class="line">  <span class="comment">//c.radius 即为 Circle 类型对象中的属性</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">3.14</span> * c.radius * c.radius</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Go-语言变量作用域"><a href="#Go-语言变量作用域" class="headerlink" title="Go 语言变量作用域"></a>Go 语言变量作用域</h2><p>作用域为已声明标识符所表示的常量、类型、变量、函数或包在源代码中的作用范围</p><p>变量可以在三个地方声明：</p><ul><li>函数内定义的变量称为局部变量</li><li>函数外定义的变量称为全局变量</li><li>函数定义中的变量称为形式参数（相当于函数体内的局部变量）</li></ul><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>在函数体内声明，包括参数和返回值变量</p><p>可以与全局变量<strong>同名</strong>，在函数内会优先使用局部变量</p><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>在函数体外声明（<code>main</code> 函数外），可以在整个包甚至外部包（被导出后）使用</p><h2 id="Go-语言数组"><a href="#Go-语言数组" class="headerlink" title="Go 语言数组"></a>Go 语言数组</h2><p>数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，类型可以是任意的原始类型（整型、字符串等）或自定义类型</p><p>一个数组变量表示整个数组，在赋值或传递时会复制整个数组，如果希望避免复制则可以传递数组的<strong>指针</strong></p><h3 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h3><p>需要指定元素类型及元素个数</p><p><code>var variable_name [SIZE] variable_type</code> —— <code>var balance [10] float32</code></p><h3 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> balance = [<span class="number">5</span>]<span class="type">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br><span class="line">balance1 := [<span class="number">5</span>]<span class="type">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> balance2 = [...]<span class="type">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br><span class="line"><span class="comment">// 或（长度不确定时可以使用 ... 会在初始化时自行判断长度）</span></span><br><span class="line">balance3 := [...]<span class="type">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  将索引为 1 和 3 的元素初始化</span></span><br><span class="line">balance4 := [<span class="number">5</span>]<span class="type">float32</span>&#123;<span class="number">1</span>:<span class="number">2.0</span>,<span class="number">3</span>:<span class="number">7.0</span>&#125;</span><br></pre></td></tr></table></figure><p><code>&#123;&#125;</code> 中的元素个数不能大于 <code>[]</code></p><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>套几个 <code>[]</code> 来声明，<code>&#123;&#125;</code> 来初始化即可</p><h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><p>同其他语言</p><h2 id="Go-语言指针"><a href="#Go-语言指针" class="headerlink" title="Go 语言指针"></a>Go 语言指针</h2><p>取地址符 <code>&amp;</code></p><h3 id="什么是指针"><a href="#什么是指针" class="headerlink" title="什么是指针"></a>什么是指针</h3><p>一个指针变量指向了一个值的内存地址，声明格式如下：</p><p><code>var var_name *var-type</code> 例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ip *<span class="type">int</span> <span class="comment">/* 指向整型 */</span></span><br><span class="line"><span class="keyword">var</span> fp *<span class="type">float32</span> <span class="comment">/* 指向浮点型 */</span></span><br></pre></td></tr></table></figure><h3 id="如何使用指针"><a href="#如何使用指针" class="headerlink" title="如何使用指针"></a>如何使用指针</h3><p>流程：</p><ol><li>定义指针变量</li><li>为指针变量赋值</li><li>访问指针变量中指向地址的值（<strong>在指针类型前加上 <code>*</code> 来获取指针所指向的内容</strong>）</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">20</span></span><br><span class="line">    <span class="keyword">var</span> ip *<span class="type">int</span></span><br><span class="line">    </span><br><span class="line">    ip = &amp;a</span><br><span class="line">    </span><br><span class="line">    fmt.Printf(<span class="string">&quot;a 变量的地址是：%x\n&quot;</span>, &amp;a)</span><br><span class="line">    </span><br><span class="line">    fmt.Printf(<span class="string">&quot;ip 变量储存的指针地址：%x\n&quot;</span>, ip)</span><br><span class="line">    </span><br><span class="line">    fmt.Printf(<span class="string">&quot;*ip 变量的值：%d\n&quot;</span>, *ip)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特殊指针"><a href="#特殊指针" class="headerlink" title="特殊指针"></a>特殊指针</h3><h4 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h4><p>当一个指针被定义后没有分配到任何变量时，它的值为 <code>nil</code>，也被称为空指针</p><h4 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h4><p><code>var ptr [Max]*int</code> 声明一个存储指针的数组后逐个给其赋值地址</p><p><code>ptr[i] = &amp;a[i]</code></p><h4 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h4><p><code>var ptr **int</code> 即已有一个指针，在获取其地址赋值给一个指针</p><h4 id="指针作为函数参数"><a href="#指针作为函数参数" class="headerlink" title="指针作为函数参数"></a>指针作为函数参数</h4><p>在函数定义时 <code>func swap(x *int, y *int) &#123;&#125;</code></p><p>在函数调用时 <code>swap(&amp;a, &amp;b)</code> （回想<strong>赋值格式</strong>即可）</p><h2 id="Go-语言结构体-Struct"><a href="#Go-语言结构体-Struct" class="headerlink" title="Go 语言结构体 Struct"></a>Go 语言结构体 Struct</h2><p>结构体是由一系列具有相同类型或不同类型的数据构成的数据集合</p><p>可同一般变量一样作为函数参数和指针（且仍用 <code>.</code> 访问成员）</p><h3 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> struct_variable_type <span class="keyword">struct</span> &#123;</span><br><span class="line">    member definition</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">variable_name := struct_variable_type &#123;value1, value2, ...&#125;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">variable_name := struct_variable_type &#123;key1: value1, key2: value2, ...&#125;</span><br></pre></td></tr></table></figure><h3 id="访问结构体成员"><a href="#访问结构体成员" class="headerlink" title="访问结构体成员"></a>访问结构体成员</h3><p><code>结构体.成员名</code> 可用于获取和赋值</p><h2 id="Go-语言切片-（Slice）"><a href="#Go-语言切片-（Slice）" class="headerlink" title="Go 语言切片 （Slice）"></a>Go 语言<a href="https://blog.go-zh.org/go-slices-usage-and-internals">切片</a> （Slice）</h2><p>切片是对数组的抽象，是一种“动态数组”，可追加元素</p><p>切片的零值是 <code>nil</code> ； <code>nil</code> 切片的长度和容量为 0 且没有底层数组</p><p>对切片的修改会作用到实际数组上</p><p><code>var identifier []type</code> 未指定大小的数组即为一个切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 []<span class="keyword">type</span> = <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br><span class="line"><span class="comment">// 也可以简写为</span></span><br><span class="line">slice1 := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br></pre></td></tr></table></figure><p>此处的 <code>make([]T, length, capacity)</code> 中 <strong>capacity</strong> 为可选参数 - 容量（最大长度）</p><p>具体切片操作同 <code>python</code> （貌似没有步长）</p><p>使用自带函数 <code>len()</code> 和 <code>cap()</code> 可获取长度和容量</p><p>切片在未初始化之前默认为 nil，长度为 0</p><p><code>copy(toSlice, fromSlice)</code> 进行切片内容拷贝；</p><p><code>Slice&lt;T&gt; = append(Slice&lt;T&gt;, Ts...)</code> 进行元素追加（不增加容量）</p><p><code>Slice&lt;T&gt; = AppendByte(Slice&lt;T&gt;, Ts...)</code> 自动扩容的追加（原长加上追加长后 * 2）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := []<span class="type">string</span>&#123;<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Paul&quot;</span>&#125;</span><br><span class="line">b := []<span class="type">string</span>&#123;<span class="string">&quot;George&quot;</span>, <span class="string">&quot;Ringo&quot;</span>, <span class="string">&quot;Pete&quot;</span>&#125;</span><br><span class="line">a = <span class="built_in">append</span>(a, b...) <span class="comment">// equivalent to &quot;append(a, b[0], b[1], b[2])&quot;</span></span><br><span class="line"><span class="comment">// 两个切片 append 时要扩展为 ...</span></span><br></pre></td></tr></table></figure><h2 id="Go-语言范围（Range）"><a href="#Go-语言范围（Range）" class="headerlink" title="Go 语言范围（Range）"></a>Go 语言范围（Range）</h2><p>range 关键字用于 for 循环中迭代数组（array）、切片、通道（channel）或集合（map）的元素，无需括号</p><p>在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key 对</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//这是我们使用range去求一个slice的和。使用数组跟这个很类似</span></span><br><span class="line">    nums := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        sum += num</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;sum:&quot;</span>, sum)</span><br><span class="line">    <span class="comment">//在数组上使用range将传入index和值两个变量。上面那个例子我们不需要使用该元素的序号，所以我们使用空白符&quot;_&quot;省略了。有时侯我们确实需要知道它的索引。</span></span><br><span class="line">    <span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">3</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;index:&quot;</span>, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//range也可以用在map的键值对上。</span></span><br><span class="line">    kvs := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;b&quot;</span>: <span class="string">&quot;banana&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> kvs &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s -&gt; %s\n&quot;</span>, k, v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//range也可以用来枚举Unicode字符串。第一个参数是字符的索引，第二个是字符（Unicode的值）本身。</span></span><br><span class="line">    <span class="keyword">for</span> i, c := <span class="keyword">range</span> <span class="string">&quot;go&quot;</span> &#123;</span><br><span class="line">        fmt.Println(i, c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Go-语言-Map-（集合）"><a href="#Go-语言-Map-（集合）" class="headerlink" title="Go 语言 Map （集合）"></a>Go 语言 Map （集合）</h2><p>Map 是一种无序的键值对集合，通过 key 来快速检索数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 声明变量，默认 map 是 nil ，此时不能直接进行插入修改，故一般用 make 函数初始化 */</span></span><br><span class="line"><span class="keyword">var</span> map_variable <span class="keyword">map</span>[key_data_type]value_data_type</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 make 函数 */</span></span><br><span class="line">map_variable := <span class="built_in">make</span>(<span class="keyword">map</span>[key_data_type]value_data_type)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过双赋值检测某个键是否存在 */</span></span><br><span class="line">elem, ok := m[key]</span><br><span class="line"><span class="comment">// 若存在则 ok 为 true</span></span><br></pre></td></tr></table></figure><p>如果不初始化 map，则会创建一个 nil map，其不能用来存放键值对；<strong>所以一定要 make 或者指向已存在的</strong></p><p><code>delete(mapVar, mapKey)</code> 用于删除指定 Map 的指定 Key</p><h2 id="Go-语言类型转换"><a href="#Go-语言类型转换" class="headerlink" title="Go 语言类型转换"></a>Go 语言类型转换</h2><p>用于将一种数据类型的变量转换为另外一种类型的变量</p><p><code>type_name(expression)</code></p><h2 id="Go-语言接口"><a href="#Go-语言接口" class="headerlink" title="Go 语言接口"></a>Go 语言接口</h2><p>是一种数据类型，把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">interface</span> &#123;</span><br><span class="line">    call()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> NokiaPhone <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nokiaPhone NokiaPhone)</span></span> call() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;I am Nokia, I can call you!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> IPhone <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(iPhone IPhone)</span></span> call() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;I am iPhone, I can call you!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> phone Phone</span><br><span class="line"></span><br><span class="line">    phone = <span class="built_in">new</span>(NokiaPhone)</span><br><span class="line">    phone.call()</span><br><span class="line"></span><br><span class="line">    phone = <span class="built_in">new</span>(IPhone)</span><br><span class="line">    phone.call()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Go-错误处理"><a href="#Go-错误处理" class="headerlink" title="Go 错误处理"></a>Go 错误处理</h2><p>通过 error 类型接口提供，其定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(f <span class="type">float64</span>)</span></span> (<span class="type">float64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;math: square root of negative number&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 <code>errors.New(str)</code> 返回一个错误信息</p><h2 id="Go-并发"><a href="#Go-并发" class="headerlink" title="Go 并发"></a>Go 并发</h2><p>只需要通过关键字来启动 goroutine 即可支持并发</p><p>goroutine 是轻量级线程，goroutine 的调度是由 Golang 运行时进行管理的</p><p><code>go 函数名（参数列表）</code> </p><p>以一个不同的、新创建的 goroutine 来执行一个函数</p><p>同一个程序中的所有 goroutine 共享同一个地址空间</p><h3 id="通道（channel）"><a href="#通道（channel）" class="headerlink" title="通道（channel）"></a>通道（channel）</h3><p>是用来传递数据的一个数据结构，可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯</p><p>操作符 <code>&lt;-</code> 用于指定通道的方向，发送或接收。若未指定方向则为双向通道</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) <span class="comment">// 声明</span></span><br><span class="line"> </span><br><span class="line">ch &lt;- v    <span class="comment">// 把 v 发送到通道 ch</span></span><br><span class="line">v := &lt;-ch  <span class="comment">// 从 ch 接收数据</span></span><br><span class="line">           <span class="comment">// 并把值赋给 v</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(s []<span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        sum := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">                sum += v</span><br><span class="line">        &#125;</span><br><span class="line">        c &lt;- sum <span class="comment">// 把 sum 发送到通道 c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        s := []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">        c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">        <span class="keyword">go</span> sum(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c)</span><br><span class="line">        <span class="keyword">go</span> sum(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c)</span><br><span class="line">        x, y := &lt;-c, &lt;-c <span class="comment">// 从通道 c 中接收</span></span><br><span class="line"></span><br><span class="line">        fmt.Println(x, y, x+y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通道缓冲区"><a href="#通道缓冲区" class="headerlink" title="通道缓冲区"></a>通道缓冲区</h4><p>默认没有缓冲区，可通过 <code>make</code> 的第二个参数指定缓冲区大小</p><p><code>ch := make(chan int, 100)</code></p><p>带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。</p><p>不过由于缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，否则缓冲区一满，数据发送端就无法再发送数据了。</p><p><strong>注意</strong>：如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。</p><h4 id="通道遍历与关闭通道"><a href="#通道遍历与关闭通道" class="headerlink" title="通道遍历与关闭通道"></a>通道遍历与关闭通道</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">                c &lt;- x</span><br><span class="line">                x, y = y, x+y</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line">        <span class="comment">// range 函数遍历每个从通道接收到的数据，因为 c 在发送完 10 个</span></span><br><span class="line">        <span class="comment">// 数据之后就关闭了通道，所以这里我们 range 函数在接收到 10 个数据</span></span><br><span class="line">        <span class="comment">// 之后就结束了。如果上面的 c 通道不关闭，那么 range 函数就不</span></span><br><span class="line">        <span class="comment">// 会结束，从而在接收第 11 个数据的时候就阻塞了。</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">                fmt.Println(i)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;yosoro&quot;&gt;&lt;a href=&quot;#yosoro&quot; class=&quot;headerlink&quot; title=&quot;yosoro~&quot;&gt;&lt;/a&gt;yosoro~&lt;/h1&gt;&lt;p&gt;编写一个简单的&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;</summary>
      
    
    
    
    <category term="Golang" scheme="http://remedios14.github.io/categories/Golang/"/>
    
    
    <category term="QuickStart" scheme="http://remedios14.github.io/tags/QuickStart/"/>
    
    <category term="菜鸟教程" scheme="http://remedios14.github.io/tags/%E8%8F%9C%E9%B8%9F%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Shader入门精要-常用编写</title>
    <link href="http://remedios14.github.io/2022/07/14/Games/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81-%E5%B8%B8%E7%94%A8%E7%BC%96%E5%86%99/"/>
    <id>http://remedios14.github.io/2022/07/14/Games/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81-%E5%B8%B8%E7%94%A8%E7%BC%96%E5%86%99/</id>
    <published>2022-07-14T15:19:10.000Z</published>
    <updated>2022-07-14T15:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Shader-常用编写"><a href="#Shader-常用编写" class="headerlink" title="Shader 常用编写"></a>Shader 常用编写</h2><h3 id="标准光照模型"><a href="#标准光照模型" class="headerlink" title="标准光照模型"></a>标准光照模型</h3><p><strong>逐像素光照</strong> 和 <strong>逐顶点光照</strong>；通常逐像素的效果略佳</p><ul><li>环境光部分 <code>fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</code></li></ul><h4 id="Lambert-反射"><a href="#Lambert-反射" class="headerlink" title="Lambert 反射"></a>Lambert 反射</h4><p>考虑环境光和漫反射的着色模型，环境光视作常量，漫反射的光源视作平行光，反射光量由入射角度和法向的余弦值确定，即<strong>两个单位向量点积</strong></p><p>将计算过程置于 vertex 部分或 fragment 部分就是顶点着色和像素着色的区别，不过需要的信息都是一样的；对顶点较少的简单模型通常其像素着色效果更佳，而复杂模型则差不多</p><ul><li>Half Lambert 模型 ：初始的 Lambert 模型对负的余弦值直接取 0 做成纯黑，实际视觉效果不好；该方法即将 [-1,1] 的余弦值缩放平移到 [0,1] 来对负的值也进行着色</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);</span><br><span class="line">...</span><br><span class="line">fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line">fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLightDir));</span><br></pre></td></tr></table></figure><h4 id="Specular-反射"><a href="#Specular-反射" class="headerlink" title="Specular 反射"></a>Specular 反射</h4><p>镜面反射，能计算出高光的出射角，当视线方向在出射角附近时能观察到高光，此附近判断通过计算角度代入一个<strong>指数函数的基</strong>得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);</span><br><span class="line">o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz; // 模型世界坐标</span><br><span class="line">...</span><br><span class="line">fixed3 reflectDir = normalize(reflect(-worldLightDir, worldNormal));</span><br><span class="line">fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line">fixed3 specular = _LightColor0.rbg * _Specular.rgb * pow(saturate(dot(reflectDir, viewDir)), _Gloss);</span><br></pre></td></tr></table></figure><h4 id="Blinn-Phong-光照模型"><a href="#Blinn-Phong-光照模型" class="headerlink" title="Blinn-Phong 光照模型"></a>Blinn-Phong 光照模型</h4><p>简化反射角度的计算，使用光照和视线向量的和 v_sum，若视线接近出射角度则 v_sum 和法线比较接近，因此可以使用 v_sum 点积 normal 来代入上面的指数基</p><p><strong>感觉高光范围更大一点</strong></p><h3 id="纹理映射"><a href="#纹理映射" class="headerlink" title="纹理映射"></a>纹理映射</h3><p>一个模型的顶点通常都会定义 纹理坐标 texcoord 属性，描述该模型的平面展开图到一个 [0,1]^2 范围的映射，而在应用纹理时即通过这个值得到纹理细节分布；纹理 ST 通常为 (1,1,0,0) 表示无缩放无偏移</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_MainTex (&quot;Main tex&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">...</span><br><span class="line">sampler2D _MainTex;</span><br><span class="line">float4 _MainTex_ST;</span><br><span class="line">...</span><br><span class="line">o.uv = v.texcoord.xy * _MainTex_ST.xy * _MainTex_ST.zw;</span><br><span class="line">...</span><br><span class="line">fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line">fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir));</span><br><span class="line">fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss);</span><br></pre></td></tr></table></figure><p>环境光和漫反射部分受材质影响，但镜反射高光与材质颜色无关，为什么呢？</p><h4 id="凹凸纹理"><a href="#凹凸纹理" class="headerlink" title="凹凸纹理"></a>凹凸纹理</h4><p>o.uv 前两个值存 <code>_MainTex</code> 的纹理坐标，后两个存 <code>_BumpMap</code> 的（实际上通常使用同一组纹理坐标）；后续同样要 <code>tex2D(_BumpMap, i.uv.zw)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">_BumpMap (&quot;Normal Map&quot;, 2D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">_BumpScale (&quot;Bump Scale&quot;, Float) = 1.0</span><br><span class="line">...</span><br><span class="line">sampler2D _BumpMap;</span><br><span class="line">float4 _BumpMap_ST;</span><br><span class="line">float _BumpScale;</span><br><span class="line">...</span><br><span class="line">float4 tangent : TANGENT;</span><br><span class="line">...</span><br><span class="line">o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;</span><br><span class="line">// 计算副法线并建立模型空间到法线空间的变换（就是三个方向轴组合矩阵）</span><br><span class="line">float3 binormal = cross(normalize(v.normal), normalize(v.tangent.xyz)) * v.tangent.w;</span><br><span class="line">float3x3 rotation = float3x3(v.tangent.xyz, binormal, v.normal);</span><br><span class="line">o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;</span><br><span class="line">o.viewDir = mul(rotation, ObjeSpaceViewDir(v.vertex)).xyz;</span><br><span class="line">...</span><br><span class="line">// 切线空间的两个 dir 要先 normalize，这里略</span><br><span class="line">fixed4 packedNormal = tex2D(_BumpMap, i.uv.zw);</span><br><span class="line">fixed3 tangentNormal;</span><br><span class="line">tangentNormal.xy = (packedNormal.xy * 2 - 1) * _BumpScale;</span><br><span class="line">tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy)));</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="渐变纹理"><a href="#渐变纹理" class="headerlink" title="渐变纹理"></a>渐变纹理</h4><p>下面实现了渐变的漫反射颜色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fixed halfLambert = 0.5 * dot(worldNormal, worldLightDir) + 0.5;</span><br><span class="line">fixed3 diffuseColor = tex2D(_RampTex, fixed2(halfLambert, halfLambert)).rgb * _Color.rgb;</span><br><span class="line">fixed3 diffuse = _LightColor0.rgb * diffuseColor;</span><br></pre></td></tr></table></figure><h4 id="遮罩纹理"><a href="#遮罩纹理" class="headerlink" title="遮罩纹理"></a>遮罩纹理</h4><p>实际使用中通常可以充分利用 mask_tex 的每个通道</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fixed specularMask = tex2D(_SpecularMask, i.uv).r * _SpecularScale;</span><br><span class="line">fixed3 specular = ... * specularMask;</span><br></pre></td></tr></table></figure><h3 id="透明效果"><a href="#透明效果" class="headerlink" title="透明效果"></a>透明效果</h3><p>必要声明</p><ul><li>透明度测试效果<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SubShader &#123;</span><br><span class="line">Tags &#123; &quot;Queue&quot;=&quot;AlphaTest&quot; &#125;</span><br><span class="line">Pass &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>透明度混合效果（ZWrite Off 也可以写在 SubShader 中）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SubShader &#123;</span><br><span class="line">Tags &#123; &quot;Queue&quot;=&quot;Transparent&quot; &#125;</span><br><span class="line">Pass &#123; </span><br><span class="line">ZWrite Off </span><br><span class="line">... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Alpha-Test"><a href="#Alpha-Test" class="headerlink" title="Alpha Test"></a>Alpha Test</h4><p>使用 CG 语言中的 clip，其可传入标量或向量，只要任一分量小于 0 就舍弃该片元；其他实现没啥差别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">clip(texColor.a - _Cutoff);</span><br><span class="line">// Equal to</span><br><span class="line">// if ((texColor.a - _Cutoff) &lt; 0.0) &#123;</span><br><span class="line">//     discard;</span><br><span class="line">// &#125;</span><br><span class="line">...</span><br><span class="line">Fallback &quot;Transparent/Cutout/VertexLit&quot;</span><br></pre></td></tr></table></figure><h4 id="Alpha-Blend"><a href="#Alpha-Blend" class="headerlink" title="Alpha Blend"></a>Alpha Blend</h4><p>Tags {“Queue”=”Transparent” “IgnoreProjector”=”True” “RenderType”=”Transparent”}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line">Zwrite Off</span><br><span class="line">Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">...</span><br><span class="line">return fixed4(ambient+diffuse, texColor.a * _AlphaScale);</span><br><span class="line">...</span><br><span class="line">Fallback &quot;Transparent/VertexLit&quot;</span><br></pre></td></tr></table></figure><p>不需要 cutoff 部分，只要在 Pass 内声明，并在片元着色器中给透明度赋值即可由内部完成</p><h4 id="开启深度写入的-Alpha-Blending"><a href="#开启深度写入的-Alpha-Blending" class="headerlink" title="开启深度写入的 Alpha Blending"></a>开启深度写入的 Alpha Blending</h4><p>使用两个 Pass，在第一个 Pass 内仅声明 <code>ZWrite On</code> 和 <code>ColorMask 0</code> 来写入深度并且不输出颜色，第二个 Pass 和通常的 Alpha Blending 一致</p><ul><li>ColorMask 后接 RGBA 的任意组合或 0，设置颜色通道的写掩码(write mask)</li></ul><h4 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h4><p>感觉可以另起一篇，回去看第八章最后再写吧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Shader-常用编写&quot;&gt;&lt;a href=&quot;#Shader-常用编写&quot; class=&quot;headerlink&quot; title=&quot;Shader 常用编写&quot;&gt;&lt;/a&gt;Shader 常用编写&lt;/h2&gt;&lt;h3 id=&quot;标准光照模型&quot;&gt;&lt;a href=&quot;#标准光照模型&quot; cla</summary>
      
    
    
    
    <category term="Games-Graphics" scheme="http://remedios14.github.io/categories/Games-Graphics/"/>
    
    
    <category term="图形学应用" scheme="http://remedios14.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%BA%94%E7%94%A8/"/>
    
    <category term="着色器" scheme="http://remedios14.github.io/tags/%E7%9D%80%E8%89%B2%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Shader入门精要-概述</title>
    <link href="http://remedios14.github.io/2022/07/14/Games/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81-%E6%A6%82%E8%BF%B0/"/>
    <id>http://remedios14.github.io/2022/07/14/Games/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81-%E6%A6%82%E8%BF%B0/</id>
    <published>2022-07-14T15:16:45.000Z</published>
    <updated>2022-07-14T15:16:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介-HLSL-语法"><a href="#简介-HLSL-语法" class="headerlink" title="简介 HLSL 语法"></a>简介 HLSL 语法</h2><ul><li>数据类型：bool、int、float、double；half 表示 16位浮点数；fixed 通常使用 11 位，精度范围 -2.0~+2.0</li><li>向量 ：TypeN(2 &lt;= N &lt;= 4) 例如 float3<ul><li>初始化 ：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float2 fvec = float2(0.1f, 0.2f);</span><br><span class="line">float2 fvec1 = &#123;0.3f, 0.4f&#125;;</span><br><span class="line">float4 fvec4 = &#123;fvec, fvec2&#125;;</span><br></pre></td></tr></table></figure></li><li>访问 ：vec[i]; 或者字母语法 xyzw 或 rgba，可以同时用，例如 vec.xy 得到一个二维向量；甚至可以 vec.xxyy 得到四维</li></ul></li><li>矩阵 ：TypeAxB<ul><li>初始化 ：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float2x2 fmat = float2x2(1.0f, 2.0f, 3.0f, 4.0f);</span><br><span class="line">int2x2 imat = &#123;1, 2, 3, 4&#125;;</span><br></pre></td></tr></table></figure></li><li>访问 ：mat[i][j]; 或 mat._12; 或 mat._m12; 其中</li></ul></li><li>数组 ：例如 float arr[i][j]; 以及 int3 vecarr[3]</li><li>结构体 ：struct … 仅允许变量成员，直接下标访问</li><li>内置函数 ：<a href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-intrinsic-functions">官方文档</a></li><li>流程控制 ：基本和 C/C++ 一致，多一条 <code>discard</code> 放弃该像素输出</li><li>语义 ：描述着色器在渲染管线上的标准输入输出内容，通过语义变量传递；<a href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-semantics">官方文档</a></li></ul><h2 id="着色器-Shader"><a href="#着色器-Shader" class="headerlink" title="着色器 Shader"></a>着色器 Shader</h2><p>一般的着色流程是 ：顶点数据-&gt;顶点着色器-&gt;曲面细分着色器-&gt;几何着色器-&gt;裁剪（剔除视野外顶点转为可见点）-&gt;屏幕映射-&gt;三角形设置-&gt;三角形遍历-&gt;片元着色器-&gt;逐片元操作-&gt;屏幕图像</p><ul><li>顶点着色器 Vertex Shader ：主要执行顶点的坐标系变换来模拟不同的材质效果；一个毫无变化的变换即左乘 MVP 变换矩阵进行透视投影</li><li>裁剪 ：经过变换后部分顶点在标准 Cube 之外，也即当前 FOV 的视野外，通过裁剪将外部顶点剔除，或者转为 Cube 上的可见顶点</li><li>屏幕映射 ：直观地从 [-1.1] 映射到屏幕，DirectX 以左上角为 (0,0) 而 OpenGL 以左下角</li><li>片元着色器 Fragment Shader ：将三角形的覆盖关系综合（类似深度缓存等）得到片元的综合信息；纹理采样也在这一步完成</li></ul><p>模型空间 model space 指的是以模型自身定义轴朝向的空间<br>裁剪空间 clip space 指的是以远近平面执行透视投影的视锥范围</p><h3 id="Unity-Shader"><a href="#Unity-Shader" class="headerlink" title="Unity Shader"></a>Unity Shader</h3><p>集成了 Shader 的必要编写和其他渲染的设置开关</p><ul><li>最外部是 ShaderLab 语义块，定义了该 Shader 的名称和目录层级<ol><li>Proderties 语义块内可以定义一些通用属性，会在编辑器内可见<ul><li>格式写为<code>变量名(“说明”,类型)=(默认值)</code></li></ul></li><li>SubShader 语义块用于针对不同的系统定义不同的 Shader<ul><li>Pass 语义块，（必须）其内定义顶点、片元着色器，需要用 <code>CGPROGRAM</code> 和 <code>ENDCG</code> 在首尾行包围；一些特效可使用多个 pass 语句块；（可选）定义一些 Tags 例如光照模式</li></ul></li><li>FallBack 没有适配的 SubShader 时调用这个</li></ol></li></ul><p>一个普通的贴图着色器；其中需要在 Pass 内引入 Properties 定义的属性到变量，函数后接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit/NewUnlitShader&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color(&quot;Total Rad Color!&quot;,Color) = (1,1,1,1)</span><br><span class="line">        _MainTexture(&quot;Main Texture&quot;,2D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">        SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vertexFunction</span><br><span class="line">            #pragma fragment fragmentFunction</span><br><span class="line"></span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line"></span><br><span class="line">            float4 _Color;</span><br><span class="line">            sampler2D _MainTexture;</span><br><span class="line"></span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0; // 0 表示第一组，后续编号</span><br><span class="line">float3 norm : NORMAL; // 法线</span><br><span class="line">float4 teng : TANGENT; // 切线</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 position:SV_POSITION;</span><br><span class="line">                float2 uv:TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vertexFunction(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">// 相当于左乘 MVP 变换矩阵</span><br><span class="line">                o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = v.uv;</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 fragmentFunction(v2f i) :SV_Target &#123;</span><br><span class="line">                return tex2D(_MainTexture,i.uv);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基本语义"><a href="#基本语义" class="headerlink" title="基本语义"></a>基本语义</h4><ul><li>传入顶点着色器<ul><li>POSITION ：模型空间顶点位置，通常为 float4，要转为世界空间</li><li>NORMAL ：顶点法线，通常是 float3</li><li>TANGENT ：顶点切线，通常是 float4，因为有两个垂直的方向</li><li>TEXCOORDn ：顶点的纹理坐标，n 描述第几组，通常 float2 或 float4；前两个分量为 uv，后两个分量表示偏移量</li><li>COLOR ：顶点颜色，通常 fixed4 或 float4</li></ul></li><li>传入片元着色器<ul><li>SV_POSITION ：裁剪空间中的顶点坐标，传入的结构体中必须包含一个用该语义修饰的变量；float4</li><li>COLORn ：通常用于输出几组顶点颜色，但非必须</li><li>TEXCOORDn ：通常用于输出纹理坐标，但非必须</li></ul></li><li>片元着色器输出<ul><li>SV_Target ：输出值将存储到渲染目标中；fixed4</li></ul></li></ul><h4 id="八股"><a href="#八股" class="headerlink" title="八股"></a>八股</h4><ul><li>顶点着色器任务<ul><li>把顶点位置从模型空间转换到裁剪空间，即对 POSITION 的变量施加 MVP 变换传给 SV_POSITION；<code>UnityObjectToClipPos(v.vert)</code></li><li>（片元光照需要）把法向从模型空间转换到世界空间，因为 unity 存了 World2Object，所以反过来乘；<code>wNorm = mul(v.norm, (float3x3)unity_WorldToObject);</code>；当然用 unity_ObjectToWorld 也行</li></ul></li><li>片元着色器任务</li></ul><h2 id="一些常见-Shader-的原理"><a href="#一些常见-Shader-的原理" class="headerlink" title="一些常见 Shader 的原理"></a>一些常见 Shader 的原理</h2><h3 id="标准光照模型"><a href="#标准光照模型" class="headerlink" title="标准光照模型"></a>标准光照模型</h3><ul><li>自发光（emissive）部分：由材质直接决定，但此处不视作光源</li><li>高光反射（specular）部分：在镜面反射的出射方向周围能看到高光<ul><li>使用实际观察视角对比反射方向；或者半角向量对比法向</li><li>Gloss 参数反映高光的范围</li></ul></li><li>漫反射（diffuse）部分：遵从 Lambert 定律，均匀到所有出射方向</li><li>环境光（ambient）部分：此模型下假设为一个常量，实际应当考虑光线多次反射，即全局光照</li></ul><hr><p>一些常用变量，来自 Lighting.cginc</p><ul><li><code>UNITY_LIGHTMODEL_AMBIENT.xyz</code> 四维环境光向量</li><li><code>_WorldSpaceLightPos0.xyz</code> 世界坐标中光源的位置或方向向量；若 w 为 0 表示平行光（描述方向）；为 1 表示点光源或聚光灯（从而描述位置）</li><li><code>_LightColor0.rgb</code> 光照也有颜色，不过通常认为都是白光</li><li><code>_WorldSpaceCameraPos.xyz</code> 世界坐标中相机位置</li></ul><hr><p>一些常用函数</p><ul><li>pow(x, y) 计算以 x 为底 y 为指数的值</li><li>saturate(x) 相当于 max(0, x)</li></ul><h3 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h3><p>在 Shader.Properties 中提供 <code>_MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;</code> 可以赋予纹理贴图，然后在 HLSL 代码片段中声明 <code>sampler2D _MainTex; float4 _MainTex_ST;</code> 其中后者要与前者变量名对应，并以 <code>_ST</code> （Scale、Translation）结尾，该四维向量描述了 xy 缩放值和 zw 偏移值；</p><p>因此实际的纹理 uv 要用 <code>o.uv = texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</code> 然后再到纹理上采样 <code>tex2D(_MainTex, i.uv).rgb</code></p><h4 id="纹理类型"><a href="#纹理类型" class="headerlink" title="纹理类型"></a>纹理类型</h4><ul><li>Texture ：<ul><li>Alpha from Grayscale ：使用像素灰度值生成透明度通道</li><li>Wrap Mode ：平铺模式，有 Repeat 和 Clamp(截取)</li><li>Filter Mode ：拉伸时的滤波模式；其中 Trilinear 需要纹理使用 mipmap 才由于 Bilinear</li></ul></li><li>Normal map ：</li><li>Cubemap ：</li></ul><h4 id="法线纹理"><a href="#法线纹理" class="headerlink" title="法线纹理"></a>法线纹理</h4><ul><li>法线纹理 ：在每个顶点的切线空间中描述法线，则法线为 z 轴正向的单位向量；存储了法线经过映射后得到的像素值，将原本的 [-1,1] 区间映射到 [0,1] 区间，因此在从 BumpMap 采样后要反映射；<strong>虽然没太懂，反正用切线空间做法线贴图就对了，TA的工作</strong></li><li>高度纹理 ：存储强度值（intensity）描述局部海拔高度，模拟表面的顶点位移</li></ul><p>需要 <code>_BumpMap (&quot;Normal Map&quot;, 2D) = &quot;bump&quot; &#123;&#125;</code> 和 <code>_BumpScale (&quot;Bump Scale&quot;, Float) = 1.0</code> 引入</p><p>声明时 <code>sampler2D _BumpMap; float4 _BumpMap_ST;</code></p><h4 id="渐变纹理"><a href="#渐变纹理" class="headerlink" title="渐变纹理"></a>渐变纹理</h4><p>使用简单的 [0,1] 区间的渐变色映射达成非真实渲染效果，可以用于漫反射等部分</p><p>同样使用 <code>_RampTex</code> 引入，并声明 <code>sampler2D _RampTex; float4 _RampTex_ST;</code> （虽然好像没用到 ST）</p><h4 id="遮罩纹理"><a href="#遮罩纹理" class="headerlink" title="遮罩纹理"></a>遮罩纹理</h4><p>mask texture，通常用于保护某些区域不被修改，例如采样纹素后用某个通道的值乘上某个表面属性，控制纹素值为 0 即避免被修改变化；</p><p>同样引入 2D 的 Texture 不过也无需声明 ST（<strong>因为大多数时候无需缩放偏移，或者都使用同一套缩放偏移</strong>）</p><h3 id="透明效果"><a href="#透明效果" class="headerlink" title="透明效果"></a>透明效果</h3><p>透明通道，为 0 表示全透明，在 Unity 中通过<strong>透明度测试</strong>或者<strong>透明度混合</strong>实现；深度缓存足够解决非透明（opaque）物体的渲染</p><ul><li>Alpha Test：暴力二值化，透明度小于阈值就不光栅化，大于就视作不透明</li><li>Alpha Blending：使用透明度做片元的混合因子；需要关闭深度写入，但不关闭深度测试<ul><li>即构建一个只读的 depth buffer，尽可能把最近的不透明物写入深度</li></ul></li></ul><ol><li>先渲染所有不透明物体，并开启深度测试和深度写入</li><li>从远到近排序半透明物体，并此顺序渲染；开启深度测试但关闭深度写入<ul><li>然而物体还是可能循环遮罩，因此可能需要分割网格</li></ul></li></ol><h4 id="Unity-的解决方法"><a href="#Unity-的解决方法" class="headerlink" title="Unity 的解决方法"></a>Unity 的解决方法</h4><p>提供了 render queue，队列索引号越小越先进行渲染</p><div class="table-container"><table><thead><tr><th>名称</th><th>队列索引号</th><th>描述</th></tr></thead><tbody><tr><td>Background</td><td>1000</td><td>在任何其他队列之前，用于渲染背景上的物体</td></tr><tr><td>Geometry</td><td>2000</td><td>默认队列，大多数物体、不透明物体</td></tr><tr><td>AlphaTest</td><td>2450</td><td>需要透明度测试的物体使用</td></tr><tr><td>Transparent</td><td>3000</td><td>任何使用了 alpha blending 的物体都应该使用</td></tr><tr><td>Overlay</td><td>4000</td><td>用于实现叠加效果，最上层（UI等）</td></tr></tbody></table></div><p>透明度测试的额外工作比较少；而透明度混合需要使用 Unity 提供的混合命令</p><ul><li>Blend Off : 关闭混合</li><li>Blend SrcFactor DstFactor : 开启并设置混合因子，该片元颜色乘以 Src，缓存颜色乘以 Dst 相加后存入颜色缓存</li><li>Blend SrcFactor DstFactor, SrcFactorA DstFactorA : 针对 rgb 和 A 通道使用不同的混合因子</li><li>BlendOp BlendOperation : 非简单相加，而是指定其他 Operation</li></ul><p>开启混合模式(第二项)默认以 SrcAlpha 和 1 - SrcAlpha 为因子；当然可以自行指定</p><h3 id="特效类模型"><a href="#特效类模型" class="headerlink" title="特效类模型"></a>特效类模型</h3><p>操作上即使仅仅用把法向转为颜色来输出都能看到效果，因此 Shader 其实是个看重想法的工具</p><ol><li>锈蚀效果 ：另增添一个 tex2，采样点若在 tex2 上超过某个阈值则更改他（实际上也不是必要 tex2）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介-HLSL-语法&quot;&gt;&lt;a href=&quot;#简介-HLSL-语法&quot; class=&quot;headerlink&quot; title=&quot;简介 HLSL 语法&quot;&gt;&lt;/a&gt;简介 HLSL 语法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;数据类型：bool、int、float、double；half </summary>
      
    
    
    
    <category term="Games-Graphics" scheme="http://remedios14.github.io/categories/Games-Graphics/"/>
    
    
    <category term="图形学应用" scheme="http://remedios14.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%BA%94%E7%94%A8/"/>
    
    <category term="着色器" scheme="http://remedios14.github.io/tags/%E7%9D%80%E8%89%B2%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Games202-实时全局光照</title>
    <link href="http://remedios14.github.io/2022/07/02/Games/202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/Games202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/"/>
    <id>http://remedios14.github.io/2022/07/02/Games/202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/Games202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/</id>
    <published>2022-07-02T05:29:52.000Z</published>
    <updated>2022-07-02T05:42:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Real-Time-Global-Illumination"><a href="#Real-Time-Global-Illumination" class="headerlink" title="Real-Time Global Illumination"></a>Real-Time Global Illumination</h2><p>全局光照即描述光线多次反射照亮物体的效果，递进式地先考虑间接光照</p><h3 id="Reflective-Shadow-Maps-（RSM）"><a href="#Reflective-Shadow-Maps-（RSM）" class="headerlink" title="Reflective Shadow Maps （RSM）"></a>Reflective Shadow Maps （RSM）</h3><p>要计算间接光照首先要得到直接光照点，即光源首次照射到的物体，回顾 Shadow Map 显然就是需要的方法，光线穿过足量的网格落在场景点上</p><p>此时需要假设在每个直接光照点处，光线都发生漫反射，向所有方向均匀地反射光线</p><p><img src="/images/CG/Reflective-Shadow-Maps.png" alt="从面光源 q 向 p 点"></p><p>在考虑间接光照的时候已经顾不上去计算间接光的 visibility</p><h4 id="提速"><a href="#提速" class="headerlink" title="提速"></a>提速</h4><p>为了提升效率达到实时，使用了非常大胆的 trick ：只有足够近的点作为次级光源会照亮着色点</p><p>对于 RSM 上记录的着色点 p，需要同时记录其 深度、世界坐标、法向、flux 等，然后通过世界坐标确定其他足够近的着色点 rs，计算 rs 到 p 的间接光照最终完成着色</p><ul><li>针对手电筒类光源效果最好</li></ul><h3 id="Light-Propagation-Volumes-LPV"><a href="#Light-Propagation-Volumes-LPV" class="headerlink" title="Light Propagation Volumes (LPV)"></a>Light Propagation Volumes (LPV)</h3><p>基于光线在直线传播时能量不变的性质，考虑在三维上划分空间网格；算法大致流程如下</p><ol><li>Generation ：使用 RSM（足矣）或其他算法得到直接光源照亮的样本点，经过可选的采样得到虚拟光源</li><li>Injection ：基于预划分的网格逐个对其内部各朝向的 radiance 求和，然后投影到二阶（4个）球谐函数上</li><li>Propagation ：每个网格统计其六个面上接收的光照，向对应的相邻网格传播，持续多轮迭代直到光照在所有网格上稳定</li><li>Rendering ：对任意的着色点，确认其所在网格，根据网格内的各朝向 radiance 进行着色</li></ol><p>因为统计了方向，因此对 diffuse 和 glossy 都有效</p><p>问题 ：网格过大发生漏光，网格过小耗费内存和效率</p><h3 id="Voxel-Global-Illumination-VXGI"><a href="#Voxel-Global-Illumination-VXGI" class="headerlink" title="Voxel Global Illumination (VXGI)"></a>Voxel Global Illumination (VXGI)</h3><p>类似 RSM 是一种执行两步的算法，相较之下的主要区别是 ：</p><ol><li>将场景内的建模物体划分为网格，直接光照照射物体时描述具体到单个网格（体素 Voxel）</li><li>网格具有树状的层级关系，多个网格的集合构成上层节点</li></ol><ul><li>Pass 1 from the light ：从光源出发向场景采样式（RSM 等）发出光线，落到树结构上，在每个层级节点上记录入射光线和该层级反射面法线的分布</li><li>Pass 2 from the camera ：同样发出视线落到场景着色点上，反射出一条射线并构成锥体，该锥体再与第一步完成的树结构交互来统计对着色点有贡献的间接光源；针对 diffuse 则使用相邻的几个圆锥覆盖半球面</li></ul><h2 id="GI-in-Screen-Space"><a href="#GI-in-Screen-Space" class="headerlink" title="GI in Screen Space"></a>GI in Screen Space</h2><p>大致概括为从已知直接光照渲染结果的屏幕图出发，实现全局光照的渲染效果</p><h3 id="Screen-Space-Ambient-Occlusion-SSAO"><a href="#Screen-Space-Ambient-Occlusion-SSAO" class="headerlink" title="Screen Space Ambient Occlusion (SSAO)"></a>Screen Space Ambient Occlusion (SSAO)</h3><p>环境光遮蔽，即邻近物体间的阴影效果，使场景更具有立体感</p><p>假设：</p><ol><li>所有位置都会有来自各个方向的等量环境光（同 Blinn-Phong 模型思想）</li><li>不同的着色点不一定能对所有环境光可见，因此实现遮蔽</li></ol><p>因此环境光遮蔽效果实际上就是使用常量光去乘上着色点的平均 visibility 得到</p><h4 id="计算-visibility"><a href="#计算-visibility" class="headerlink" title="计算 visibility"></a>计算 visibility</h4><p>在模型空间上很容易理解可见性的计算，实际从着色点出发进行 Ray Tracing ，在一定距离内若未发生遮挡则认为该该方向可见</p><p><strong>在屏幕空间上</strong>，我们可以使用渲染时记录的深度图，对每个着色点进行球体范围内的采样，每个样本点映射到深度图上比较记录的深度，由此得到样本点是否位于物体内部，转化为是否能被着色点可见；由此近似着色点的 visibility</p><p>因为 AO 效果通常不会单独实现，因此不必要过多采样，而是用少量采样（约 16 个）得到有噪声的结果，然后模糊处理再叠加到渲染图上即可</p><h4 id="HBAO"><a href="#HBAO" class="headerlink" title="HBAO"></a>HBAO</h4><p>相交于 SSAO 进一步考虑着色点的法线方向，由此可以仅对半球采样，效果更好</p><h3 id="Screen-Space-Directional-Occlusion"><a href="#Screen-Space-Directional-Occlusion" class="headerlink" title="Screen Space Directional Occlusion"></a>Screen Space Directional Occlusion</h3><p>类似 AO 考虑着色点的可见性，但是 AO 认为近处的物体造成遮蔽效果，使得实际着色变暗；而 DO 认为近处遮挡物体造成间接光照，向着色点染上其他颜色，未被遮挡的光线为固定的环境光照</p><p><img src="/images/CG/SS-Directional-Occlusion.png" alt="类似使用深度，只是从camera出发"></p><p>同样考虑间接光照时，也像考虑遮挡性一样仅计算较近距离内的遮挡物</p><h3 id="Screen-Space-Reflection-SSR"><a href="#Screen-Space-Reflection-SSR" class="headerlink" title="Screen Space Reflection (SSR)"></a>Screen Space Reflection (SSR)</h3><p>在屏幕空间做光线追踪</p><p><img src="/images/CG/SSR-Process.png" alt=""></p><ol><li>先从视线处向反射表面射出 ray</li><li>根据 depth buffer 到达 ray 与反射面的交点，根据存储的法线、粗糙度信息得到反射 ray</li><li>分 step 追踪反射 ray 并比较深度，直到当前点大于深度，认为已经到达物体内部<ul><li>步长的确定显著影响效率和效果，使用 Hierarchical Tracing 算法，通过 minPooling 建立原始图像的 mipmap（从高到低细分），则光线与高层像素未相交时，显然与低层像素不会相交</li><li><pre><code class="lang-pesudo">mip = 0;while (level &gt; -1)  step through current cell;  if (above Z plane) ++level;  if (below Z plane) ++level;</code></pre></li></ul></li></ol><ul><li>屏幕空间只能看到二维深度记录的点，如果光线反射到外部都未发生交则认为没有反射（使用时根据反射光线的长度减弱反射效果）</li><li>屏幕空间上的遮挡点未记录深度，会有部分反射效果无法实现（不知道怎么解决）</li></ul><h4 id="Our-requirements"><a href="#Our-requirements" class="headerlink" title="Our requirements"></a>Our requirements</h4><ul><li>Sharp and blurry reflection</li><li>Contact hardening </li><li>Specular elongation 各向同性的反射面上，形成（雨天水面）拉长的效果</li><li>Per-pixel roughness and normal</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Real-Time-Global-Illumination&quot;&gt;&lt;a href=&quot;#Real-Time-Global-Illumination&quot; class=&quot;headerlink&quot; title=&quot;Real-Time Global Illumination&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Games-Graphics" scheme="http://remedios14.github.io/categories/Games-Graphics/"/>
    
    
    <category term="games" scheme="http://remedios14.github.io/tags/games/"/>
    
    <category term="计算机图形学" scheme="http://remedios14.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Games202-实时渲染阴影</title>
    <link href="http://remedios14.github.io/2022/06/20/Games/202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/Games202-%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E9%98%B4%E5%BD%B1/"/>
    <id>http://remedios14.github.io/2022/06/20/Games/202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/Games202-%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E9%98%B4%E5%BD%B1/</id>
    <published>2022-06-20T13:50:15.000Z</published>
    <updated>2022-06-27T01:15:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="内容概述"><a href="#内容概述" class="headerlink" title="内容概述"></a>内容概述</h3><p><strong>RTR dose not trust in Complexity</strong> 实时渲染不相信复杂度，只相信速度；2n 就是不如 n</p><p>Real-Time High Quality Rendering 高质量实时渲染</p><ul><li>Real-Time 实时性<ul><li>Speed ：高于 30 FPS 甚至更高</li><li>Interactivity ：实时交互性</li></ul></li><li>High Quality 保持较高质量<ul><li>Realism ：具有真实性</li><li>Dependability ：维持正确的渲染</li></ul></li></ul><p>涉及</p><ul><li>Shadow and Environment Mapping ：动态物体的实时多维阴影</li><li>Interactive Global Illumination Techniques ：实时的全局光照</li><li>Precomputed Radiance Transfer ：预计算</li><li>Real-Time Ray Tracing ：实时光追</li><li>Non-Photorealistic Rendering ：非真实感渲染（略述，另起专题）</li><li>Antialiasing and Supersampling ：反走样和上采样</li></ul><p><img src="/images/CG/Graphics-Pipeline.png" alt="渲染管线"></p><p>Glossy 是介于 Diffuse 和 Specular 之间的类似金属材质的反射</p><h3 id="作业框架"><a href="#作业框架" class="headerlink" title="作业框架"></a>作业框架</h3><p>分为 Vertex Shader 和 Fragment Shader</p><ul><li>Vertex Shader ：<ul><li>attribute 关键字声明顶点属性，仅在顶点着色器内使用</li><li>uniform 关键字表示从 CPU 直接拷贝入 GPU 的全局变量</li><li>varying 关键字描述要处理后交给片元着色器的变量</li><li>highp 表示高精度</li><li>变换后的顶点位置要赋值给 gl_Position 变量，一个 vec4</li></ul></li><li>Fragment Shader ：<ul><li>更多的全局变量，如折射率，光源位置等</li><li>声明 varying 的变量用于表示从顶点着色器中收到</li><li>输出的颜色要赋值给 gl_FragColor 变量，一个 vec4</li></ul></li></ul><p><img src="/images/CG/Real-Time-Rendering-Equation.png" alt="实时渲染下的方程"></p><h2 id="Shadows-阴影"><a href="#Shadows-阴影" class="headerlink" title="Shadows 阴影"></a>Shadows 阴影</h2><h3 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h3><ul><li>Shadow Mapping ：执行两次渲染，先从光源出发得到所有可照射点的深度，然后从相机出发将可视点对照其在前一次渲染中的深度来确定是否有阴影；有几个缺陷<ul><li>Self Occlusion 自遮挡 ：光源斜射向平面，由于没穿过一个像素射出的光线打到平面上都认为是常数的深度，分布在一个与该光线垂直的小方片上，此结果就可能遮挡在小方片后面的平面点，造成“不存在的阴影”；<strong>解决Trick</strong> ：当深度显著大于记录时才认为有阴影，即引入一个 threshold，可以根据角度变动；或者使用<strong>二次深度</strong>，但工业上没人用，增加时间</li><li>Aliasing 走样 ：跟光栅化时的走样原因一样</li></ul></li></ul><h3 id="数学近似"><a href="#数学近似" class="headerlink" title="数学近似"></a>数学近似</h3><p>在实时渲染中有一个贯穿始终的近似式，其在 g(x) 的支撑集较小或者取值较平滑时都能有很好的近似效果</p><script type="math/tex; mode=display">\int_{\Omega}f(x)g(x)dx\simeq \frac{\int_{\Omega}f(x)dx}{\int_{\Omega}dx}\cdot \int_{\Omega}g(x)dx</script><p>基于这个近似将 RTR 的渲染方程中 <strong>可见性</strong> 一项视作 f(x) ，处理点光源或平行光源照射到漫反射表面的模型时近似效果最佳</p><h3 id="Percentage-Closer-Soft-Shadows-PCSS"><a href="#Percentage-Closer-Soft-Shadows-PCSS" class="headerlink" title="Percentage Closer Soft Shadows PCSS"></a>Percentage Closer Soft Shadows PCSS</h3><p>软阴影描述了一种由面光源产生的具有一定渐变性的阴影效果</p><p>使用 PCF（Percentage Closer Filter） 实现的软阴影效果，其中前者本身用于抗锯齿</p><ul><li>PCF 原理 ：可以理解为基于原始的 Shadow map，采用一个卷积核 Filter 观察每个点在核视域内的可见点占比，以此比率作为该点的可见性，形成软阴影效果；公式如下</li></ul><script type="math/tex; mode=display">V(x)=\sum_{q\in \mathcal{N}(p)}w(p,q)\cdot \chi^+[D_{SM}(p)-D_{scene}(x)]</script><p>其中 x 表示着色点，p 为向光源中心射线后到 Shadow map 的交点，邻域由 Filter 大小确定，权重通常使用高斯核</p><p>使用时越小的 Filter 得到锐利的阴影，越大的则得到软阴影；为了更符合现实，通常使靠近遮挡物的阴影更锐利，远处则采用更大的卷积核做出软阴影</p><p><img src="/images/CG/PCSS-Filter-Selection.png" alt="左值越大越适用软阴影"></p><p><strong>完整流程</strong></p><ol><li>Blocker search ：从着色点向<strong>面光源中心</strong>射线，得到 shadow map 上的像素，然后使用可调的 Filter 获取区域内所有深度小于该点的平均深度，表示遮挡物的平均深度<ul><li>一个启发式的方法，不向光源中心而是向面光源顶点射线，由此得到 shadow map 上的区域</li></ul></li><li>Penumbra estimation ：使用平均深度来确定合适的 PCF 大小</li><li>PCF</li></ol><p><strong>注意</strong> ：非常遗憾，反复的卷积操作非常耗时，因此工业上还需要很多的 Tricks 才能应用</p><h3 id="Variance-Soft-Shadow-Mapping"><a href="#Variance-Soft-Shadow-Mapping" class="headerlink" title="Variance Soft Shadow Mapping"></a>Variance Soft Shadow Mapping</h3><p>PCSS 主要耗时在于第一步和第三步，比较直觉的优化是引入噪声采样而非全部遍历，但缺点也很明显</p><hr><p><strong>针对第三步</strong></p><p>由于 PCF 步骤需要根据卷积核内的更深像素数占比来确定阴影强度，相当于检查深度名次，因此近似看作高斯分布，确定 均值、方差、当前值 来快速确定该“名次”</p><p>为此需要快速查询区域的均值和方差方法：</p><ul><li>均值 ：使用 Hardware Mipmap 或者 Summed Area Tables （推荐）</li><li>方差 ：使用平方的期望减期望的平方计算方差，因此即使用两张 SM 来完成查询，正好查均值也要用；在生成 SM 时就可以完成</li></ul><p>然而根据高斯分布查表或求数值解还是不算快，因此又引入切比雪夫不等式用于近似（把不等号直接视作越等号，要求 t 值在均值右侧）</p><script type="math/tex; mode=display">P(x>t)\le \frac{\sigma^2}{\sigma^2+(t-\mu)^2}</script><hr><p><strong>针对第一步</strong></p><p>容易查询得知区域内的所有点深度均值 $Z<em>{avg}$，需要获知深度小于当前点的平均深度 $Z</em>{ooc}$，与之对应的非遮挡物平均深度为 $Z_{unooc}$</p><p>由此有个简单的公式 </p><script type="math/tex; mode=display">\frac{N_1}{N}Z_{unooc}+\frac{N_2}{N}Z_{ooc}=Z_{avg}</script><p>使用切比雪夫近似地估计 $\frac{N_1}{N}$ 并且将非遮挡点的深度视作和当前点深度一致为 t （纯纯的 Trick），由此即可计算出遮挡点的平均深度</p><h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><p>上面都说了查到均值后如何计算，这里则给出如何快速查询均值，即使用 MIPMAP 或 <strong>SAT</strong></p><ul><li>MIPMAP ：（仅能查询方形区域）根据目标点找到两个层级，然后插值完成</li></ul><p>Summed Area Tables ：即是用前后的前缀和做差得到范围内的和（一维），二维则使用矩形区域</p><pre><code>- 问题在于构建和存储 ：存储必定要和原图一样的大小，构建时先横向求和，再纵向求和；为了提升效率需要正确地并行</code></pre><h3 id="Moment-Shadow-Mapping"><a href="#Moment-Shadow-Mapping" class="headerlink" title="Moment Shadow Mapping"></a>Moment Shadow Mapping</h3><p>VSSM 在非均匀的深度分布下可能漏光，因为切比雪夫的近似仅使用到二阶矩</p><p>MSM 即使用高阶矩（通常 4 阶）来近似分布函数去计算比率</p><h3 id="Distance-Field-Soft-Shadows"><a href="#Distance-Field-Soft-Shadows" class="headerlink" title="Distance Field Soft Shadows"></a>Distance Field Soft Shadows</h3><p>Optimal Transport</p><p>在空间中定义一个物体的距离场，描述各个点到该物体表面的最近距离，（可以考虑带符号，内部为负）用于实现运动的插值；距离场函数用 SDF(p) 描述，表示点 p 到物体的最近距离</p><p>此时可知从点 p 出发向任意方向运动 SDF(p) 都不会撞上物体</p><p><img src="/images/CG/Distance-Field-Soft-Shadows.png" alt="逐步在光线方向上采样点，根据其 SDF 值判断必定非遮挡的角度"></p><p><strong>注意</strong> ：渲染上尽量避免复杂的运算，因此 arcsin 这类也要避免，转而使用下式近似描述角度，同时 k 可调整软硬程度，k 越大越锐利</p><script type="math/tex; mode=display">min{\frac{k\cdot SDF(p)}{p-o}, 1.0}</script><p>然而还要考虑生成 SDF 的时间，针对形变的物体都要重新生成</p><h2 id="Environment-Mapping"><a href="#Environment-Mapping" class="headerlink" title="Environment Mapping"></a>Environment Mapping</h2><p>描述环境光是指从当前点向任意方向看去所能捕获到的光照，有两种图像表现形式 ：Spherical、Cube ；其中球状的映射在南北极会有明显的拉伸变形</p><h3 id="Image-Based-Lighting-（IBL）"><a href="#Image-Based-Lighting-（IBL）" class="headerlink" title="Image-Based Lighting （IBL）"></a>Image-Based Lighting （IBL）</h3><p>已知环境光照的存储图像，还原任意物体的着色；通过 Rendering Equation 借助蒙特卡洛方法能实现，但其效率通常认为无法用在实时渲染上</p><p>回顾在 SM 中使用过的积分近似，针对 glossy 表面的 brdf 仅在较小的反射区域取值，而针对 smooth 表面则在半球面上保持平稳，正好符合要求</p><p><img src="/images/CG/Environment-Mapping-Approx.png" alt="渲染方程中的近似"></p><h4 id="The-Split-Sum"><a href="#The-Split-Sum" class="headerlink" title="The Split Sum"></a>The Split Sum</h4><p>针对近似的渲染方程，分两个部分考虑积分值：</p><ol><li>框选分式部分 ：基于高斯滤波对环境光照图像进行预处理（mipmap），然后按照 brdf 去单次采样特定方向的光照图；例如镜面反射方向（glossy）或法线方向（漫反射）</li><li>余下积分式部分 ：回顾 101（五） 中提及的 “微表面 BRDF”，将式子中的 f 拆分为分子中的三式；考虑菲涅尔项的 Schlick 近似，将 f 除以 F 再乘以近似式并展开，得到积分可写成仅与粗糙度和角度有关，足以做成 LookUpTable<br><img src="/images/CG/Divide-Fresnel-LUT.png" alt="简化参数表示"></li></ol><p>最终将所有的积分都转为小变量求和，即构成 Split Sum</p><h3 id="Shadow-from-Environment-Lighting"><a href="#Shadow-from-Environment-Lighting" class="headerlink" title="Shadow from Environment Lighting"></a>Shadow from Environment Lighting</h3><p>具体很难实现，工业上有一个做法是仅实现一个最强光源产生的阴影</p><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>频域图可以理解为以坐标为变化频率的点数统计，中心即代表变化频率 (0,0) ，因此表示低频信息</p><p><img src="/images/CG/Spherical-Harmonics-Functions.png" alt="球谐函数，三维空间上描述方向的二维基函数"></p><p>每一阶的球谐函数都构成一组基，对于任意角度函数 f(ω) ，其表示成相应基的线性组合时的系数可计算</p><script type="math/tex; mode=display">c_i = \int_{\Omega}f(\omega)B_i(\omega)d\omega</script><p>使用前三阶的球谐函数来近似漫反射的 BRDF 和入射光照（两者都是低频信号）足以取得很好的效果</p><h4 id="Precomputed-Radiance-Transfer-（PRT）"><a href="#Precomputed-Radiance-Transfer-（PRT）" class="headerlink" title="Precomputed Radiance Transfer （PRT）"></a>Precomputed Radiance Transfer （PRT）</h4><p><img src="/images/CG/Basic-Idea-of-PRT.png" alt="假定固定观察者视角 o，则仅有光照方向 i 发生变化"></p><ul><li>针对漫反射情况，将光照项分解成球谐函数的线性组合，提取出系数项并将基函数项保留在积分式中，预计算积分部分（也可以展开成基函数的线性组合）；最终与任何角度都无关<ul><li>代价就是，一旦场景中物体发生位置变化，就会影响可见性的部分，即需要重新预计算</li></ul></li></ul><p><img src="/images/CG/Diffuse-Case-PRT.png" alt=""></p><ul><li>针对 Glossy 情况，输出结果与观察方向有关，将出射方向 o 展开成基函数形式，最终针对一个着色点需要存储一个矩阵大小的信息</li></ul><p><img src="/images/CG/Glossy-Case-PRT.png" alt=""></p><h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><p>往后还有使用小波变换来代替球谐函数的研究</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;内容概述&quot;&gt;&lt;a href=&quot;#内容概述&quot; class=&quot;headerlink&quot; title=&quot;内容概述&quot;&gt;&lt;/a&gt;内容概述&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;RTR dose not trust in Complexity&lt;/strong&gt; 实时渲染不相信复杂度，只</summary>
      
    
    
    
    <category term="Games-Graphics" scheme="http://remedios14.github.io/categories/Games-Graphics/"/>
    
    
    <category term="games" scheme="http://remedios14.github.io/tags/games/"/>
    
    <category term="计算机图形学" scheme="http://remedios14.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Games104-游戏引擎中的渲染、动画、物理</title>
    <link href="http://remedios14.github.io/2022/06/12/Games/104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Games104-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E3%80%81%E5%8A%A8%E7%94%BB%E3%80%81%E7%89%A9%E7%90%86/"/>
    <id>http://remedios14.github.io/2022/06/12/Games/104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Games104-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E3%80%81%E5%8A%A8%E7%94%BB%E3%80%81%E7%89%A9%E7%90%86/</id>
    <published>2022-06-12T04:03:33.000Z</published>
    <updated>2022-06-12T12:00:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Basic-of-Game-Rendering"><a href="#Basic-of-Game-Rendering" class="headerlink" title="Basic of Game Rendering"></a><strong>Basic of Game Rendering</strong></h2><p>针对场景、材质等渲染和动画的渲染，可以花费时间代价来追求效果，而游戏中的渲染则更加注重实时性</p><ul><li>Challenges on Game Rendering<ul><li>实时性</li><li>针对不同硬件平台的统一性</li><li>帧率的稳定性</li><li>算力限制，不能在渲染上花费太多资源，要分给其他部分</li></ul></li></ul><p><strong>非真实感渲染</strong></p><p><strong>渲染问题总是非常耗时，为了实现好的渲染效果，一个很基本的思想即是预计算转化为少量参数，成像时仅需要采样即可</strong></p><p>投影和光栅化；补充上反走样的处理</p><ul><li>Hardware architecture<ul><li>SIMT (Single Instruction Multiple Threads) 现代显卡的理念</li></ul></li><li>Render data organization<ul><li>将网格、材质等描述的 Game Object 组织起来进行渲染</li><li>网格顶点的数据实际存储，而构成的面则可以仅存储顶点的索引</li><li>材质数据主要由纹理来描述</li><li>经过 Renderer 完成具体效果的渲染</li><li><strong>架构问题</strong> ：一个完整网格物体通常由很多部分不同材质构成，以 submesh 区分；很多对象通常有一致的模型，因此在渲染一种材质后构成一个 pool，通过对应检索即可略过大量重复计算</li></ul></li><li>Visibility：<ul><li>仅需要渲染当前视野内可见范围的对象，即一个从相机出发的四棱锥；引入一些树划分方法（如 BVH）来快速地确定可见区域内地对象</li><li>Potential Visibility Set ：一种早期想法，以房间划分则仅有门窗可透视，此时仅需要渲染有门窗相连地场景</li></ul></li></ul><h3 id="贴图压缩-Texture-Compression"><a href="#贴图压缩-Texture-Compression" class="headerlink" title="贴图压缩 Texture Compression"></a>贴图压缩 Texture Compression</h3><p>为了节约存储同时又保证随机访问的效率，通常采用 Block 压缩，将贴图每四个方形像素分块，保存少量信息实现压缩</p><h3 id="Cluster-Based-Mesh-Pipeline"><a href="#Cluster-Based-Mesh-Pipeline" class="headerlink" title="Cluster-Based Mesh Pipeline"></a>Cluster-Based Mesh Pipeline</h3><p>现代化的新发展方向、Nanite</p><h3 id="Materials-Shaders-and-Lighting"><a href="#Materials-Shaders-and-Lighting" class="headerlink" title="Materials, Shaders and Lighting"></a>Materials, Shaders and Lighting</h3><p>渲染方程（见 <a href="../../../../5/31/Games-Graphics/Games101-计算机图形学（四）/#渲染方程">Games101</a>）</p><ul><li>三大难点：1.如何计算各个方向的入射 irradiance；2. 如何精确地在半球面上积分；3. 如何考虑光线的多次反射</li></ul><p>考虑散射光、Blinn Phong、Shadow Mapping，实现的效果以及差不多够看了</p><ul><li>球谐函数 Spherical Harmonics —— 一组三维空间中使用两个角度 θ 和 φ 描述的基函数，因为是基函数，可用于近似任意的三维函数，只要提升阶数就能降低偏差</li></ul><p><a href="https://zhuanlan.zhihu.com/p/359856625">使用球谐函数简化光照</a></p><ul><li>PBR(SG, MR) Physics-Based Rendering</li><li>Shader permutation</li><li>Lighting</li></ul><h3 id="Special-Rendering"><a href="#Special-Rendering" class="headerlink" title="Special Rendering"></a>Special Rendering</h3><p>地形、大气、云层；以及后处理</p><p>渲染上的实现通常控制屏幕中的像素量保持不变，原始的大地模型都采用比较大的网格，根据相机位置将近处的网格细分，保证在同样的 FOV 下观察到的网格总量尽可能一致；一些射击游戏中的倍镜通过缩小视角实现，此时在保持网格数不变的情况下，对远处图像的表示精度就提升了</p><ul><li>Terrain：通常借助等高线 HeightField；<ul><li>QuadTree 四叉树，将大面积的地形切割存储 —— 切割时总会有一个边界上两侧的切割数不一致，解决方法是将更细分得到的顶点吸附到粗分的顶点，称为 stiching</li><li>Mesh Shader</li><li>Real-Time Deformable Terrian ：外部 GO 交互影响材质，形成类似“雪痕”效果</li><li><strong>Camera-Raletive</strong> Rendering —— 制作大地形时，对远处的网格渲染很容易发生浮点数精度误差而抖动；一种 trick 就是挪动相机后使用相对相机的位置</li></ul></li><li>数目、装饰物（如草丛等）的渲染：近处实现精细渲染，远处简化为柱体等</li><li>Sky / Fog ：都通过介质描述，光路在通过介质时会发生 散射、通透；其中通透部分经过积分削弱即完成<ul><li>Rayleigh Scattering、Mie Scattering<br><img src="/images/Engine/Analytic-Atmosphere-Appearance-Modeling.png" alt="基础的地面视角解析"></li></ul></li><li>Clouds ：使用 Volumetric Modeling（体积度量的模型），引入噪声实现不同的形状，模拟分形效果</li></ul><h3 id="Pipline"><a href="#Pipline" class="headerlink" title="Pipline"></a>Pipline</h3><p>Ambient Occlusion ：环境光遮蔽，描述一种表面凹陷形成黑暗区域的视觉效果</p><pre><code>- Screen Space AO ：视线穿过像素点落在表面上，计算视线落点在球空间的可见性，用采样点计算比例表示- SSAO+ ：上述方法采样整个球，但通常半个球在表面内侧，必然不可见；该 plus 方法即根据落点法向采样半球- HBAO（Horizon-based AO）：同样半球面，不过根据角度确定多少范围内的光被遮挡- GTAO（Ground Truth-based AO）：</code></pre><p>雾效 Fog Everything</p><pre><code>- Depth Fog ：描述不同深度的雾效，选择 线性、指数、指数平方 等关系- Height Fog ：- Voxel-based Volumetric Fog</code></pre><p>反走样 Anti-aliasing ：由于输出以像素为单位，总是存在走样问题</p><pre><code>- Super-sample AA ：上采样，直接将单个像素均分为四个然后着色取之后的比例作为最终结果- MASS ：针对网格仅对边界上采样，效率没啥优化；对精细模型没啥提升- FXAA ：比较当前像素与上下左右像素的色差大致确定轮廓- TAA（Temporal AA）：时序上的 blending</code></pre><p>后处理 Post-process</p><pre><code>- Bloom 光晕 ：    1. 先对图像二值化得到高亮度区域    2. 逐层下次采样并保留，达到指定水平    3. 通过高斯滤波逐层还原，并与下采样时同层的叠加    4. 得到原始分辨率的成果图，与原图叠加实现效果- Tone Mapping 曝光 ：做法通常是根据图像中总体光强度通过一个曲线改变其分布；ACES- Color Gradient 颜色梯度 ：即给出始末两个颜色水平，均匀采样后进行插值，得到原始颜色空间到颜色梯度空间的 Lookup Table；低耗高效    - 通常使用 256 \* 16 的尺寸存储 LUT，分为 16 块，每块固定一个 blue 通道值向右递增，块内部横向 red 通道递增，纵向 green 通道递增</code></pre><ul><li>Real pipeline with mixed effects</li><li>Ring buffer and V-Sync</li><li>Tiled-based rendering</li></ul><h2 id="Basic-of-Animation-Technology"><a href="#Basic-of-Animation-Technology" class="headerlink" title="Basic of Animation Technology"></a>Basic of Animation Technology</h2><p>基于视觉残留</p><ul><li>游戏动画的挑战 ：<ol><li>交互性和动态变化</li><li>实时需求，和所有的功能模块竞争单帧算力</li><li>动画的真实性，包括整体动作和微观细节，如表情</li></ol></li></ul><h3 id="2D-动画"><a href="#2D-动画" class="headerlink" title="2D 动画"></a>2D 动画</h3><p>Sprite Animation —— 使用大量的连续帧构成动画；早期节约资源的方法</p><p><strong>Live2D</strong> —— 将各种需要分别设计动作的部分（眼睛、眉毛、嘴巴等）分为图元，调节深度可控制显式，加入控制点实现局部形变来模拟动作</p><h3 id="3D-动画"><a href="#3D-动画" class="headerlink" title="3D 动画"></a>3D 动画</h3><p>DoF (Degrees of Freedom) —— 对刚体运动的表达，例如三个轴向的平移加上绕三个轴的旋转即达到 6DoF；再加上三个方向的 Scale 达到 9DoF</p><p>几种动画方法：</p><ul><li>Per-vertex Animation —— 记录每个顶点的位置离线模拟，顶点变化影响法向，从而影响材质的表现</li><li>Morph Target Animation —— 由顶点动画发展来，通过关键帧顶点位置插值完成动画</li><li><strong>3D Skinned Animation</strong> —— 使用骨骼结构穿插到模型内，模拟动作；使用最广泛的一种，2D 也有</li><li>Physics-based Animation —— 布娃娃系统，使用纯物理来模拟骨架；IK (Inverse Kinematic)</li></ul><h4 id="Skined-动画如何实现"><a href="#Skined-动画如何实现" class="headerlink" title="Skined 动画如何实现"></a>Skined 动画如何实现</h4><p>先建立骨骼然后在外部套上网格，基本固定网格相对骨骼位置，控制骨骼运动</p><p>几个重要的设计点：</p><ol><li>先确立骨骼的局部坐标系，以此为基准确定外部网格，然后转为世界坐标系进行渲染；其中转化的矩阵运算需要确保无误</li><li>不同动物体的骨骼都有所不同，都需要符合现实分别设计</li><li>实际上骨骼的运动是通过关节运动实现的，正向运动学已知关节变化角度来确定位置，但不方便设计；逆向动力学已知位置逆推关节角度</li><li>需要初期设计好一个<strong>标准模型</strong>的骨骼架构，而针对一些复杂模型如带大服饰、物件的模型再追加设计</li><li>在椎骨末端增加一个尾骨连接到两足中间，不影响模型位置，同时方便实现跳跃、下蹲等动作的高度调整</li><li>两个或多个骨骼模型的绑定实现，当绑定后将有部分形变保持一致</li></ol><h4 id="Math-of-3D-Rotation"><a href="#Math-of-3D-Rotation" class="headerlink" title="Math of 3D Rotation"></a>Math of 3D Rotation</h4><p><img src="/images/Engine/Roll-Pitch-Yaw.png" alt="三维物体角度描述"></p><p>欧拉角度的几个问题：</p><ol><li>Gimbal Lock ：一定角度下会失去一个 DoF（查一下）</li><li>难以插值，线性插值结果不正确</li><li>无法进行旋转组合，仅方便描述单物体单次旋转</li><li>难以给定向量绕其旋转</li></ol><p><strong>Quaternion</strong> <a href="https://zhuanlan.zhihu.com/p/97186723">四元数，神中神</a> （定时22/10/01自己整理一篇）</p><p><img src="/images/Engine/Skinning-Matrix.png" alt="运算"></p><p>将等式同时左乘关节的 pose 矩阵，可以理解为在绑定时刻仅知道绑定关节的空间位姿和本节点的坐标，以此算出本节点相对绑定关节的局部空间坐标</p><p>以此局部空间坐标，在任意时刻左乘绑定关节的空间位姿，即得到本节点在该时刻的模型空间坐标</p><ul><li>Skin 的网格坐标通常取几个关节点的 model space 坐标加权后插值得到<ul><li>插值前做一个点积运算判断往那边是更近的插值</li><li>插值方法 ：NLerp 首尾点连线上插值，然后伸长到弧上（不均匀）、SLerp 反三角函数运算，根据角度插值</li><li>通常角度较小时 NLerp 节约时间；较大时 SLerp 保持自然</li></ul></li></ul><h3 id="动画压缩-Animation-Compression"><a href="#动画压缩-Animation-Compression" class="headerlink" title="动画压缩 Animation Compression"></a>动画压缩 Animation Compression</h3><p>大致思路是分为 Rotation、Transparent、Scale 三个维度，逐帧检查是否需要插入关键帧，若以某处为关键帧向前插值会造成较大误差，则取前面发生该误差的时间点作为关键帧，然后继续向后搜索</p><hr><h2 id="Advanced-of-Animation"><a href="#Advanced-of-Animation" class="headerlink" title="Advanced of Animation"></a><strong>Advanced of Animation</strong></h2><h3 id="动画混合-Blending"><a href="#动画混合-Blending" class="headerlink" title="动画混合 Blending"></a>动画混合 Blending</h3><ul><li>线性 Blending</li></ul><p>实现连贯的动画效果转换，以人物的行走到跑动的转变为例 ：</p><ol><li>行走和跑动都有一组循环的动画，并且分别有一个速度水平</li><li>根据实际动画中的速度水平线性插值计算出当前速度下的两者权重</li><li>将行走和跑动的动画都根据<strong>时长归一化</strong>，然后对应每一个点都是用上面算出的权重插值得到中间的动画</li></ol><p>更进一步的有更多方向的运动，但要进行插值都至少要有几组确定好的循环动画；关于多方向运动的插值有 Delaunay Triangulation 进行二维空间划分然后使用三角形重心坐标插值</p><ul><li>Skeleton Mask Blending ：遮罩混合（不翻译更好），类比图像的 mask，即一部分骨骼不应用动画；例如坐着摆手</li><li>Additive Blending ：仅保存动画的变化量，例如点头动画，可以任意加上旋转；但也要适度，否则会有 joint 异常</li></ul><h3 id="动作状态机-Animation-State-Machine"><a href="#动作状态机-Animation-State-Machine" class="headerlink" title="动作状态机 Animation State Machine"></a>动作状态机 Animation State Machine</h3><p>就是状态机，按照一定的规则切换动画；<strong>具体的状态机仅判断输入和前一刻状态完成状态更新，具体动画通过读取当前状态以及是否发生更新来选择输出</strong></p><ul><li>Cross Fade ：切换过程中采用一定时长及曲线来渐变转换，有很多种 Fade Curves</li><li>Layer ASM ：分层状态机（鬼泣5），查查看</li></ul><h3 id="动画树-Animation-Blend-Tree"><a href="#动画树-Animation-Blend-Tree" class="headerlink" title="动画树 Animation Blend Tree"></a>动画树 Animation Blend Tree</h3><p>学习虚幻引擎</p><h3 id="IK-技术"><a href="#IK-技术" class="headerlink" title="IK 技术"></a>IK 技术</h3><ul><li>Two Bone IK ：以脚踩凸出地块为例，确定大腿根部和凸出地块坐标，分别以大小腿骨骼长度做出两个球，则球表面相交环都可以作为中间关节的位置；然后考虑运动方向，只取通向侧的最外点即得到结果</li></ul><hr><p>稍微长一点的骨骼结构就很难，一些启发式算法（都不能确保达到终点，需要给出一个接受水平来停止迭代）：</p><ul><li>CCD (Cyclic Coordinate Decent) ：几乎纯 hack 的方法，从叶子关节往上迭代，每次都调整当前关节使末关节靠近目标点（达到一定范围后进入下一次），迭代到根关节时再重开</li><li>FABRIK (Forward And Backward Reaching IK) ：循环执行向前和向后步骤直到一定水平<ul><li>向前步骤，强制移动叶关节到目标位置，向前一个关节连线，保留骨骼长度得到前几段的终点，然后递归；完成一步后通常根关节会变化位置</li><li>向后步骤，即把初始的根关节位置作为目标点，反向执行上面描述的步骤</li></ul></li></ul><h3 id="动画重定向"><a href="#动画重定向" class="headerlink" title="动画重定向"></a>动画重定向</h3><p>相同的一组动画效果应用到不同的骨骼结构上</p><hr><h2 id="Physics-System"><a href="#Physics-System" class="headerlink" title="Physics System"></a>Physics System</h2><h3 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><p>通常把游戏实现分为逻辑层和渲染层，物理效果大部分在逻辑层实现</p><p>一个物理系统的参与者称为 actor，可分为四类：Static、Dynamic、Trigger、Kinematic（运动学规则约束，违背物理）</p><p>基础的几何形体（方便求交）：球体、胶囊体（通常用在人物上）、Box、Convex Mesh（石块类）、Triangle Mesh、Height Field（地形等）</p><p>形体属性：质量、密度、质心、物理材质 Material（摩擦力 Friction、弹性 Restitution）</p><h4 id="力与运动"><a href="#力与运动" class="headerlink" title="力与运动"></a>力与运动</h4><ul><li>常规持续的作用力，如重力，拖拽力，摩擦力</li><li>瞬时触发力<strong>冲量</strong> impulse</li></ul><p>运动的实现 ：见<a href="../../../04/Games-Graphics/Games101-计算机图形学（六）/#粒子运动的求解">简述粒子运动</a></p><p>动量 = 质量 × 速度</p><h4 id="刚体动力学"><a href="#刚体动力学" class="headerlink" title="刚体动力学"></a>刚体动力学</h4><ul><li>朝向 Orientation $\mathbf{R}$（矩阵或四元数表达）</li><li>角速度 Angular velocity $\vec{\omega}$</li><li>角加速度 Angular acceleration $\vec{\alpha}$</li><li>惯性张量 Inertia tensor $\mathbf{I}$</li><li>角动量 Angular momentum $\vec{L}=\mathbf{I}\vec{\omega}$</li><li>Torque $\vec{\tau}=\frac{d\vec{L}}{dt}$</li></ul><h4 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h4><p>一般通过粗细两次筛选</p><p>粗筛中可用 BVH、Sort and Sweep —— 分轴向排序盒子边界来判断是否相交</p><p>细筛中有三种方法：</p><ul><li>形状相交检测 ：基于简单形状判断，球、胶囊类</li><li>Minkowski Difference-based Methods<ul><li>Minkowski 和，描述两个集合内各取任意一（向量）点的和的集合；同理定义差</li><li>平面上的两个凸包点集有交 iff 两者的 Minkowski 差包含原点</li><li>后续引入 GJK 算法对有交的情况快速找交点</li></ul></li><li>Separation Axis Theorem<ul><li>不相交的两个形状一定能找到分离轴；三维上即分离面</li></ul></li></ul><h3 id="Applications"><a href="#Applications" class="headerlink" title="Applications"></a>Applications</h3><p>暂略</p><p>PBD、XPBD</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Basic-of-Game-Rendering&quot;&gt;&lt;a href=&quot;#Basic-of-Game-Rendering&quot; class=&quot;headerlink&quot; title=&quot;Basic of Game Rendering&quot;&gt;&lt;/a&gt;&lt;strong&gt;Basic of </summary>
      
    
    
    
    <category term="Game-Engine" scheme="http://remedios14.github.io/categories/Game-Engine/"/>
    
    
    <category term="games" scheme="http://remedios14.github.io/tags/games/"/>
    
    <category term="现代游戏引擎" scheme="http://remedios14.github.io/tags/%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>Python-游戏脚本</title>
    <link href="http://remedios14.github.io/2022/06/08/OpenCV/Python-%E6%B8%B8%E6%88%8F%E8%84%9A%E6%9C%AC/"/>
    <id>http://remedios14.github.io/2022/06/08/OpenCV/Python-%E6%B8%B8%E6%88%8F%E8%84%9A%E6%9C%AC/</id>
    <published>2022-06-08T11:51:41.000Z</published>
    <updated>2022-07-07T00:41:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>基于 opencv、pillow、pywin 来捕获图像并模拟按键操作</p><h2 id="星露谷物语钓鱼脚本"><a href="#星露谷物语钓鱼脚本" class="headerlink" title="星露谷物语钓鱼脚本"></a>星露谷物语钓鱼脚本</h2><p>设计工作流程：（确保预先调整好钓鱼位置并切换到钓竿）</p><ol><li>获取窗体并正常显示后置于最前</li><li>执行单次钓鱼流程<ol><li>模拟鼠标左击并等到蓄力满时模拟释放左键</li><li>等待画面，人物头顶出现感叹号时模拟左击，鱼上钩</li><li>追踪钓鱼条直到完成捕获</li></ol></li><li>循环执行钓鱼流程，等待终止命令</li></ol><h3 id="细节完成"><a href="#细节完成" class="headerlink" title="细节完成"></a>细节完成</h3><p>模拟蓄力目前使用 <code>time.sleep(1.03)</code> 来完成了，实际中偶尔出现卡顿而发生偏差。<del>但不蓄满力不影响钓上鱼，暂且先不管了</del></p><hr><p>捕获感叹号：目前截取屏幕中央的矩形区域，采样后发现叹号出现约 0.6+ 秒，考虑刚出现叹号的帧，用较小区域内的像素变化来捕获</p><p>当场景背景深色时前后截图的差较小，场景背景亮色时前后截图的差较大，暂且凭感觉根据负相关性给出一个阈值了</p><ul><li>TODOs：<ul><li>部分钓鱼点由于处在游戏区域边缘，人物模型不在屏幕中央，改进矩形捕获位置 —— 可以试试轮廓检测能否捕获到人物位置所在矩形，然后以此确定叹号位置</li></ul></li></ul><hr><p>捕获鱼条位置：</p><ul><li>由于鱼条的绿色不纯正，还经常变成浅色，与背景框混淆，目前采用通道 g - r 同时将鱼条和鱼都捕获，然后根据尺寸区分</li><li>鱼块比较容易确定，定位后比较位置来判断执行左键按下或抬起</li></ul><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> win32api</span><br><span class="line"><span class="keyword">import</span> win32con</span><br><span class="line"><span class="keyword">import</span> win32gui</span><br><span class="line"><span class="keyword">import</span> win32print</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageGrab</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">intLerp</span>(<span class="params">a, b, t</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>((<span class="number">1</span>-t)*a+t*b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">varCompare</span>(<span class="params">pre, cur, l = <span class="number">0</span></span>):</span><br><span class="line">    hist1 = cv2.calcHist([pre], [l], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">    hist2 = cv2.calcHist([cur], [l], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">    </span><br><span class="line">    h1 = hist1[:, <span class="number">0</span>]</span><br><span class="line">    h2 = hist2[:, <span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 这里理论上不应该用前一帧该通道的均值，而用其值与黄色在该通道下的值的差值更好，但是我也就说说</span></span><br><span class="line">    res = (h2 - h1).var() / <span class="number">256</span></span><br><span class="line">    res = res / pre[:, :, l].mean()</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FishBar</span>():</span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> 捕鱼的操作可以再优化一下；如果能检测出鱼框上下边界，考虑进碰撞的反弹，那可以试试强化学习    </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.cur_speed = <span class="number">0.0</span></span><br><span class="line">        self.last_top = <span class="number">420</span></span><br><span class="line">        self.vert_mid = <span class="number">0</span></span><br><span class="line">        self.inited = <span class="literal">False</span></span><br><span class="line">        self.mouse_down = <span class="literal">False</span></span><br><span class="line">    <span class="comment"># 控制钓鱼条，可以优化</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, brect, frect, dt</span>):</span><br><span class="line">        bar2f = brect[<span class="number">1</span>] - (frect[<span class="number">1</span>] + frect[<span class="number">3</span>])</span><br><span class="line">        fish2b = frect[<span class="number">1</span>] - (brect[<span class="number">1</span>] + brect[<span class="number">3</span>])</span><br><span class="line">        self.cur_speed = (self.last_top - brect[<span class="number">1</span>]) / dt</span><br><span class="line">        self.last_top = brect[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> bar2f &gt; <span class="number">0</span>:</span><br><span class="line">            win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">elif</span> fish2b &gt; <span class="number">0</span>:</span><br><span class="line">            win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> self.cur_speed &lt; <span class="number">0</span> <span class="keyword">or</span> \</span><br><span class="line">                (frect[<span class="number">1</span>] + frect[<span class="number">3</span>] / <span class="number">2</span>) &lt; (brect[<span class="number">1</span>] + brect[<span class="number">3</span>] / <span class="number">4</span>):</span><br><span class="line">                win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">clear</span>(<span class="params">self</span>):</span><br><span class="line">        win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FishingScript</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.whandle = <span class="literal">None</span></span><br><span class="line">        self.left_top = (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        self.h_width = <span class="number">0</span></span><br><span class="line">        self.h_height = <span class="number">0</span></span><br><span class="line">        self.wind_prop = <span class="number">1.0</span></span><br><span class="line">        <span class="comment"># 识别叹号的阈值，越大越不容易误识别，可视输出调整</span></span><br><span class="line">        self.marker_thresh = <span class="number">0.3</span></span><br><span class="line">        self.shot_t = <span class="number">0.1</span></span><br><span class="line">        <span class="comment"># <span class="doctag">TODO:</span> 有机会再追加函数确定人物所在位置</span></span><br><span class="line">        self.cha_hmid = <span class="number">0</span></span><br><span class="line">        self.cha_vmid = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 激活窗口并放置鼠标</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">activateWnd</span>(<span class="params">self, hsv</span>):</span><br><span class="line">        l, t, r, b = win32gui.GetWindowRect(hsv)</span><br><span class="line">        <span class="comment"># 若处于缩略窗口就先切换正常显示</span></span><br><span class="line">        <span class="keyword">if</span> r &lt; <span class="number">0</span>:</span><br><span class="line">            win32gui.ShowWindow(hsv, win32con.SW_SHOWNORMAL)</span><br><span class="line">        win32gui.SetForegroundWindow(hsv)</span><br><span class="line">        l, t, r, b = win32gui.GetWindowRect(hsv)</span><br><span class="line">        proportion = <span class="built_in">round</span>(win32print.GetDeviceCaps(win32gui.GetDC(<span class="number">0</span>), win32con.DESKTOPHORZRES)/win32api.GetSystemMetrics(<span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">        self.setWindowProp((l, t, r, b), proportion)</span><br><span class="line">        win32api.SetCursorPos((intLerp(l, r, <span class="number">0.5</span>), intLerp(t, b, <span class="number">0.5</span>)))</span><br><span class="line">        win32gui.SetForegroundWindow(self.whandle)</span><br><span class="line">        cv2.waitKey(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 截屏整个游戏窗口</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">grabFullImg</span>(<span class="params">self</span>):</span><br><span class="line">        l, t, r, b = win32gui.GetWindowRect(self.whandle)</span><br><span class="line">        l = <span class="built_in">int</span>(l * self.wind_prop)</span><br><span class="line">        t = <span class="built_in">int</span>(t * self.wind_prop)</span><br><span class="line">        r = <span class="built_in">int</span>(r * self.wind_prop)</span><br><span class="line">        b = <span class="built_in">int</span>(b * self.wind_prop)</span><br><span class="line">        bbox = (l, t, r, b)</span><br><span class="line">        img = ImageGrab.grab(bbox)</span><br><span class="line">        img_cv = cv2.cvtColor(np.asarray(img), cv2.COLOR_RGB2BGR)</span><br><span class="line">        <span class="keyword">return</span> img_cv</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 定时甩杆</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">FisherOut</span>(<span class="params">self, svtime = <span class="number">1.03</span></span>):</span><br><span class="line">        win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        time.sleep(svtime) <span class="comment"># 1.02 和 1.03 都能 max；不知道是否和钓鱼等级有关</span></span><br><span class="line">        win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 赋值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setWindowProp</span>(<span class="params">self, bbox, prop</span>):</span><br><span class="line">        self.left_top = (bbox[<span class="number">0</span>], bbox[<span class="number">1</span>])</span><br><span class="line">        self.h_width = bbox[<span class="number">2</span>] - bbox[<span class="number">0</span>]</span><br><span class="line">        self.h_height = bbox[<span class="number">3</span>] - bbox[<span class="number">1</span>]</span><br><span class="line">        self.wind_prop = prop</span><br><span class="line">        self.cha_hmid = self.left_top[<span class="number">0</span>] + self.h_width // <span class="number">2</span></span><br><span class="line">        self.cha_vmid = self.left_top[<span class="number">1</span>] + self.h_height // <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 截屏部分窗口</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">grabRangeImg</span>(<span class="params">self, bbox</span>):</span><br><span class="line">        img = ImageGrab.grab(bbox)</span><br><span class="line">        img_cv = cv2.cvtColor(np.asarray(img), cv2.COLOR_RGB2BGR)</span><br><span class="line">        <span class="keyword">return</span> img_cv</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 前期测试时截屏采样用</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">debugShot</span>(<span class="params">self, bbox, shape, nums = <span class="number">20</span></span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nums):</span><br><span class="line">            time.sleep(self.shot_t)</span><br><span class="line">            img = self.grabRangeImg(bbox)</span><br><span class="line">            <span class="keyword">if</span> shape[<span class="number">0</span>] != <span class="number">0</span>:</span><br><span class="line">                img = cv2.resize(img, dsize = shape)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;image write &quot;</span>, i)</span><br><span class="line">            cv2.imwrite(<span class="string">&quot;tmp/no&#123;&#125;.png&quot;</span>.<span class="built_in">format</span>(i), img)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 等待🐟上钩，即叹号出现</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">waitMarker</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># <span class="doctag">TODO:</span> 目前仅考虑人物位于屏幕中央，条件允许后续加上检测，如识别人物的轮廓转换为矩形区域来确定叹号区域</span></span><br><span class="line">        width = self.h_width / <span class="number">80</span></span><br><span class="line">        height = self.h_height / <span class="number">16</span></span><br><span class="line">        h_mid = self.left_top[<span class="number">0</span>] + self.h_width / <span class="number">2</span></span><br><span class="line">        v_mid = self.left_top[<span class="number">1</span>] + self.h_height / <span class="number">2</span></span><br><span class="line">        val_list = [self.cha_hmid, self.cha_vmid - height * <span class="number">2</span>, self.cha_hmid + width, self.cha_vmid - height]</span><br><span class="line">        bbox = <span class="built_in">tuple</span>(<span class="built_in">int</span>(x * self.wind_prop) <span class="keyword">for</span> x <span class="keyword">in</span> val_list)</span><br><span class="line">        <span class="comment"># self.debugShot(bbox,(60, 180))</span></span><br><span class="line">        pre = cv2.resize(self.grabRangeImg(bbox), dsize=(<span class="number">60</span>, <span class="number">180</span>))</span><br><span class="line">        timer = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            time.sleep(self.shot_t)</span><br><span class="line">            timer += self.shot_t</span><br><span class="line">            cur = cv2.resize(self.grabRangeImg(bbox), dsize=(<span class="number">60</span>, <span class="number">180</span>))</span><br><span class="line">            vared = self.imgCompare(pre, cur)</span><br><span class="line">            pre = cur</span><br><span class="line">            <span class="keyword">if</span> vared:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;fish caught!&quot;</span>)</span><br><span class="line">                time.sleep(<span class="number">0.2</span>) </span><br><span class="line">                <span class="comment"># 捕获到感叹号有时没法正确发送左击指令，可能是 python 非严格串行的原因，多执行几次得到解决</span></span><br><span class="line">                win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, <span class="built_in">int</span>(h_mid), <span class="built_in">int</span>(v_mid))</span><br><span class="line">                win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, <span class="number">0</span>, <span class="number">0</span>) </span><br><span class="line">                win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, <span class="built_in">int</span>(h_mid), <span class="built_in">int</span>(v_mid))</span><br><span class="line">                win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, <span class="built_in">int</span>(h_mid), <span class="built_in">int</span>(v_mid))</span><br><span class="line">                <span class="comment"># win32gui.SendMessage(self.whandle, win32con.WM_LBUTTONDOWN,win32con.MK_LBUTTON,win32api.MAKELONG(8,30))</span></span><br><span class="line">                time.sleep(<span class="number">0.1</span>)</span><br><span class="line">                win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">                <span class="comment"># win32gui.SendMessage(self.whandle,win32con.WM_LBUTTONUP,win32con.MK_LBUTTON,win32api.MAKELONG(8,30))</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> timer &gt; <span class="number">7.0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Wait for too long, might too large threshold&quot;</span>)</span><br><span class="line">                self.marker_thresh -= <span class="number">0.05</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> timer &lt; <span class="number">0.2</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Too fast, might occured misdetection&quot;</span>)</span><br><span class="line">            self.marker_thresh += <span class="number">0.05</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">    <span class="comment"># 用于判断是否出现叹号</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">imgCompare</span>(<span class="params">self, pre, cur</span>):</span><br><span class="line">        jv1 = varCompare(pre, cur)</span><br><span class="line">        jv2 = varCompare(pre, cur, <span class="number">1</span>)</span><br><span class="line">        jv3 = varCompare(pre, cur, <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(jv1, jv2, jv3)</span><br><span class="line">        blue = jv1 &gt; self.marker_thresh</span><br><span class="line">        green = jv2 &gt; self.marker_thresh</span><br><span class="line">        red = jv3 &gt; self.marker_thresh</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">int</span>(blue) + <span class="built_in">int</span>(green) + <span class="built_in">int</span>(red) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 追踪鱼条执行鼠标动作</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traceBar</span>(<span class="params">self</span>):</span><br><span class="line">        fb = FishBar()</span><br><span class="line">        width = self.h_width / <span class="number">8</span></span><br><span class="line">        height = self.h_height / <span class="number">20</span></span><br><span class="line">        val_list = [self.cha_hmid - width, self.cha_vmid - <span class="number">7</span> * height, self.cha_hmid + width, self.cha_vmid + <span class="number">5</span>*height]</span><br><span class="line">        bbox = <span class="built_in">tuple</span>(<span class="built_in">int</span>(x * self.wind_prop) <span class="keyword">for</span> x <span class="keyword">in</span> val_list)</span><br><span class="line">        box_w = <span class="number">320</span></span><br><span class="line">        box_h = <span class="number">460</span></span><br><span class="line">        </span><br><span class="line">        round_ticker = <span class="number">0</span> <span class="comment"># 连续三次未捕获到符合的目标则退出该函数</span></span><br><span class="line">        smknl = cv2.getStructuringElement(cv2.MORPH_RECT, (<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">        lgknl = cv2.getStructuringElement(cv2.MORPH_RECT, (<span class="number">15</span>, <span class="number">15</span>))</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            time.sleep(self.shot_t)</span><br><span class="line">            round_ticker += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> round_ticker &gt; <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 先确定鱼</span></span><br><span class="line">            cur = cv2.resize(self.grabRangeImg(bbox),dsize=(box_w, box_h))</span><br><span class="line">            b, g, r = cv2.split(cur)</span><br><span class="line">            fish = cv2.subtract(cv2.subtract(b, r), cv2.subtract(b, g))</span><br><span class="line">            fish = cv2.threshold(fish, <span class="number">100</span>, <span class="number">255</span>, cv2.THRESH_BINARY)[<span class="number">1</span>]</span><br><span class="line">            fish = cv2.morphologyEx(fish, cv2.MORPH_OPEN, smknl)</span><br><span class="line">            fish = cv2.dilate(fish, lgknl)</span><br><span class="line">            fcons, _ = cv2.findContours(fish, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(fcons) &lt; <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Fish miss detected, need further check&quot;</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            frect = cv2.boundingRect(fcons[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> fb.inited:</span><br><span class="line">                fb.vert_mid = frect[<span class="number">0</span>] + frect[<span class="number">2</span>] // <span class="number">2</span></span><br><span class="line">                fb.inited = <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 再对比确定浮标</span></span><br><span class="line">            bina = cv2.threshold(cv2.subtract(g, r), <span class="number">50</span>, <span class="number">255</span>, cv2.THRESH_BINARY)[<span class="number">1</span>]</span><br><span class="line">            erd = cv2.erode(bina, smknl)</span><br><span class="line">            adjed = cv2.morphologyEx(erd, cv2.MORPH_CLOSE, lgknl)</span><br><span class="line">            cons, _ = cv2.findContours(adjed, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">            rect_list = []</span><br><span class="line">            <span class="keyword">for</span> (i, c) <span class="keyword">in</span> <span class="built_in">enumerate</span>(cons):</span><br><span class="line">                rect = cv2.boundingRect(c)</span><br><span class="line">                <span class="comment"># 根据位置、形状筛选</span></span><br><span class="line">                <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                if rect[2] &gt; 32 or rect[3] &gt; 200:</span></span><br><span class="line"><span class="string">                    continue</span></span><br><span class="line"><span class="string">                if (rect[0] &gt; 80 and rect[0] &lt; 240):</span></span><br><span class="line"><span class="string">                    continue</span></span><br><span class="line"><span class="string">                if rect[0] &lt; 20 or rect[0] &gt; 280:</span></span><br><span class="line"><span class="string">                    continue</span></span><br><span class="line"><span class="string">                if rect[3] &lt; rect[2] / 2 or rect[3] &lt; 32:</span></span><br><span class="line"><span class="string">                    continue</span></span><br><span class="line"><span class="string">                &quot;&quot;&quot;</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(rect[<span class="number">0</span>] - fb.vert_mid) &gt; frect[<span class="number">2</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(rect_list) == <span class="number">0</span>:</span><br><span class="line">                    rect_list.append(rect)</span><br><span class="line">                <span class="keyword">elif</span> rect_list[-<span class="number">1</span>][<span class="number">3</span>] &lt; rect[<span class="number">3</span>]:</span><br><span class="line">                    rect_list.append(rect)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(rect_list) &lt; <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Bar miss detected, need further check&quot;</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            fb.update(rect_list[-<span class="number">1</span>], frect, self.shot_t * round_ticker)</span><br><span class="line">            round_ticker = <span class="number">0</span> <span class="comment"># 顺利更新，归 0</span></span><br><span class="line">        fb.clear()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 确定抓到🐟就左击一下收进背包，否则不用左击</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fishComfirm</span>(<span class="params">self</span>):</span><br><span class="line">        box_w = self.h_width / <span class="number">10</span></span><br><span class="line">        box_h = self.h_height / <span class="number">12</span></span><br><span class="line">        val_list = [self.cha_hmid - box_w, self.cha_vmid - <span class="number">3.5</span> * box_h, self.cha_hmid + box_w, self.cha_vmid - box_h]</span><br><span class="line">        bbox = <span class="built_in">tuple</span>(<span class="built_in">int</span>(x * self.wind_prop) <span class="keyword">for</span> x <span class="keyword">in</span> val_list)</span><br><span class="line">        img = self.grabRangeImg(bbox)</span><br><span class="line">        knl = cv2.getStructuringElement(cv2.MORPH_RECT, (<span class="number">15</span>, <span class="number">15</span>))</span><br><span class="line">        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">        bing = cv2.threshold(gray, <span class="number">230</span>, <span class="number">255</span>, cv2.THRESH_BINARY)[<span class="number">1</span>]</span><br><span class="line">        res = cv2.dilate(bing, knl)</span><br><span class="line">        cons, _ = cv2.findContours(res, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(cons) &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        rects = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> cons:</span><br><span class="line">            rect = cv2.boundingRect(c)</span><br><span class="line">            sur = rect[<span class="number">2</span>] * rect[<span class="number">3</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(rects) &lt; <span class="number">1</span>:</span><br><span class="line">                rects.append(rect)</span><br><span class="line">            <span class="keyword">elif</span> rects[-<span class="number">1</span>][<span class="number">2</span>] * rects[-<span class="number">1</span>][<span class="number">3</span>] &lt; sur:</span><br><span class="line">                rects.append(rect)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> rects[-<span class="number">1</span>][<span class="number">2</span>] * rects[-<span class="number">1</span>][<span class="number">3</span>] * <span class="number">2</span> &gt; img.shape[<span class="number">0</span>] * img.shape[<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">loop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Start one loop&quot;</span>)</span><br><span class="line">            self.FisherOut()</span><br><span class="line">            time.sleep(<span class="number">1.5</span>) <span class="comment"># 完成下杆</span></span><br><span class="line">            caught = self.waitMarker()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> caught:</span><br><span class="line">                self.FisherOut(<span class="number">0.01</span>)</span><br><span class="line">                time.sleep(<span class="number">1.5</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            time.sleep(<span class="number">1.2</span>) <span class="comment"># 进入浮标控制</span></span><br><span class="line">            self.traceBar()</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            confirmed = self.fishComfirm()</span><br><span class="line">            <span class="keyword">if</span> confirmed:</span><br><span class="line">                <span class="comment"># 这个函数只是定时左击，所以写在这里代替了</span></span><br><span class="line">                self.FisherOut(<span class="number">0.01</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Finish one loop&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">work</span>(<span class="params">self</span>):</span><br><span class="line">        hsv = win32gui.FindWindow(<span class="string">&quot;SDL_app&quot;</span>, <span class="string">&quot;Stardew Valley&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> hsv == <span class="number">0</span>:</span><br><span class="line">            win32api.MessageBeep()</span><br><span class="line">            ret = win32api.MessageBox(<span class="number">0</span>, <span class="string">&quot;未找到运行中的窗口，请打开游戏再运行此脚本&quot;</span>, <span class="string">&quot;注意&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> ret == <span class="number">1</span>:</span><br><span class="line">                sys.exit(<span class="number">0</span>)</span><br><span class="line">        self.whandle = hsv</span><br><span class="line">        self.activateWnd(hsv)</span><br><span class="line">        <span class="comment"># <span class="doctag">TODO:</span> 可以加上按键终止、启动循环</span></span><br><span class="line">        self.loop()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    fs = FishingScript()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Object created&quot;</span>)</span><br><span class="line">    fs.work()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">other</span>():</span><br><span class="line">    imglist = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">        imglist.append(cv2.imread(<span class="string">&quot;tmp/no&#123;&#125;.png&quot;</span>.<span class="built_in">format</span>(j)))</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="死亡细胞自动格挡脚本"><a href="#死亡细胞自动格挡脚本" class="headerlink" title="死亡细胞自动格挡脚本"></a>死亡细胞自动格挡脚本</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;基于 opencv、pillow、pywin 来捕获图像并模拟按键操作&lt;/p&gt;
&lt;h2 id=&quot;星露谷物语钓鱼脚本&quot;&gt;&lt;a href=&quot;#星露谷物语钓鱼脚本&quot; class=&quot;headerlink&quot; title=&quot;星露谷物语钓鱼脚本&quot;&gt;&lt;/a&gt;星露谷物语钓鱼脚本&lt;/h2&gt;&lt;p</summary>
      
    
    
    
    <category term="Python" scheme="http://remedios14.github.io/categories/Python/"/>
    
    
    <category term="game-script" scheme="http://remedios14.github.io/tags/game-script/"/>
    
  </entry>
  
  <entry>
    <title>Cpp环境配置及编译流程</title>
    <link href="http://remedios14.github.io/2022/06/04/C++/Cpp%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/"/>
    <id>http://remedios14.github.io/2022/06/04/C++/Cpp%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/</id>
    <published>2022-06-04T13:03:07.000Z</published>
    <updated>2022-06-07T13:13:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><del>虽然个人目前未接触过很多 c++ 工程，不懂多少编译手段，但是先在此记录能起步使用程度的知识，并祈祷今后会不断增加</del></p><h2 id="Windows-环境"><a href="#Windows-环境" class="headerlink" title="Windows 环境"></a>Windows 环境</h2><ul><li>编辑器随意选择，使用习惯的即可，或者 VSCode 比较优秀</li><li>编译器通常使用 mingw 完成单文件编译，配合 cmake 完成多文件编译，具体安装教程很多</li></ul><p><a href="https://zhuanlan.zhihu.com/p/401188789">编辑环境配置及三方库安装</a></p><p>一般安装第三方库时先使用 MSYS 的命令检索 <code>pacman -Ss keywords</code> 找到之后根据操作系统对应的编译器来选择安装，Windows 下为 mingw64，在其子环境下安装 cmake 使用 <code>pacman -S mingw-w64-x86_64-cmake</code></p><p><strong>补充</strong> ：使用 msys 安装的外部库在 VSC 中不能立刻看到代码提示，此时需要 ctrl+shift+p 搜索 “edit configuration” 编辑 C/C++ 的配置，在其 <code>includePath</code> 条目下追加上 <code>**/msys64/mingw64/include</code> 具体目录视自身情况修改，大致是这个位置</p><h3 id="g-编译"><a href="#g-编译" class="headerlink" title="g++ 编译"></a>g++ 编译</h3><p>mingw64 内置 g++ / gcc 等，通常编译 c++ 程序使用 g++ 即可；其中 <code>-g</code> 参数会后续生成调试信息，进行调试前需要编辑 launch.json 和 tasks.json，若无调试需求可以不加这个参数</p><ul><li>编译单文件，生成带调试信息的可执行文件、并调试</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -g main.cpp -o my_single_swap</span><br></pre></td></tr></table></figure><ul><li>编译多文件，生成带调试信息的可执行文件、并调试；（不推荐，需要把所有文件都加入）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -g main.cpp swap.cpp -o my_multi_swap</span><br></pre></td></tr></table></figure><h3 id="cmake-编译"><a href="#cmake-编译" class="headerlink" title="cmake 编译"></a>cmake 编译</h3><p>ctrl + shift + P 输入 cmake 来指定 GCC 编译器，可以基于工作区文件生成 CMakeLists.txt（或者自行先编写好）</p><ol><li><p>编写 CMakeLists.txt 写入必要信息</p></li><li><p>工程项目下执行指令将完成 cmake 编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -G &quot;MinGW Makefiles&quot; ..</span><br><span class="line">mingw32-make.exe</span><br></pre></td></tr></table></figure></li></ol><h4 id="cmakelists-文件编写"><a href="#cmakelists-文件编写" class="headerlink" title="cmakelists 文件编写"></a>cmakelists 文件编写</h4><p><a href="https://www.jianshu.com/p/2bdcd7d7b164">参考文档</a></p><p>通常子目录都可以编写 cmakelists 生成一个 lib 然后在父目录内添加</p><ul><li>一般的例子：<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.2)</span><br></pre></td></tr></table></figure></li></ul><h3 id="调试工作的配置"><a href="#调试工作的配置" class="headerlink" title="调试工作的配置"></a>调试工作的配置</h3><p>调试工作是由 VSCode 读取调试信息和调试配置完成的，其中调试信息由编译器在编译中处理并储存，我们则需要需改调试配置</p><p>VSCode 上可以直接找到调试栏 “创建 launch.json 文件” 来快捷完成</p><p>关键点要将 “program” 属性定位到编译完成的 <code>*.exe</code> 文件</p><ul><li>tasks.json 用于指定在 debug 前的 build 工作，如果子集完成编译和调试信息则无需该文件</li></ul><h2 id="Visual-Studio-的项目配置"><a href="#Visual-Studio-的项目配置" class="headerlink" title="Visual Studio 的项目配置"></a>Visual Studio 的项目配置</h2><p>以 SDL2 为例，<a href="https://blog.csdn.net/m0_37872216/article/details/124545623">参考博客</a></p><ol><li>修改工程的 VC++-&gt;包含目录和库目录；</li><li>修改 链接器-&gt;输入-&gt;附加依赖项-&gt;追加 <code>.lib</code></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;del&gt;虽然个人目前未接触过很多 c++ 工程，不懂多少编译手段，但是先在此记录能起步使用程度的知识，并祈祷今后会不断增加&lt;/del&gt;&lt;/p&gt;
&lt;h2 id=&quot;Windows-环境&quot;&gt;&lt;a href=&quot;#Windows-环境&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="Cpp" scheme="http://remedios14.github.io/categories/Cpp/"/>
    
    
    <category term="cpp" scheme="http://remedios14.github.io/tags/cpp/"/>
    
    <category term="pre-tasks" scheme="http://remedios14.github.io/tags/pre-tasks/"/>
    
  </entry>
  
  <entry>
    <title>Games101-计算机图形学（六）</title>
    <link href="http://remedios14.github.io/2022/06/04/Games/101%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <id>http://remedios14.github.io/2022/06/04/Games/101%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E5%85%AD%EF%BC%89/</id>
    <published>2022-06-04T02:50:20.000Z</published>
    <updated>2022-06-26T15:19:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://www.bilibili.com/video/BV1X7411F744?p=1&amp;spm_id_from=pageDriver">博客图片及学习路径来源 Gamse 101课程，在此记录以方便个人查阅为主，强烈建议自行观看学习</a></strong></p><h2 id="Animation-Simulation"><a href="#Animation-Simulation" class="headerlink" title="Animation / Simulation"></a>Animation / Simulation</h2><p>历史；关键帧动画；物理仿真；运动学 Kinematics；Rigging</p><ul><li>fps ：frames per second；通常电影 24 就足够，一般的视频 30；往上游戏、虚拟现实等要求才高起来</li><li>关键帧动画 Keyframe Animation：连续动作的“转折点”，关键帧之间的内容可以<strong>使用插值</strong>填充过程，当然不是简单的线性插值<ul><li>为了符合平滑的运动，至少要加上 连续性、样条 等约束</li></ul></li><li>物理仿真 Physical Simulation ：即通过模拟力在每个点上的作用和碰撞检测来仿真现实物理效果<ul><li>质点弹簧系统 Mass Spring System ：见下段落</li><li>有限元分析 Finite Element Method (FEM) ：可以代替弹簧系统实现模拟</li></ul></li><li>粒子系统 Particle Systems ：用众多粒子建模并模拟粒子受到的力和粒子间的相互力；也算物理仿真的一部分，要考虑的力有：<ul><li>关联力：引力、斥力、电磁力、弹性力等；Damping 力：摩擦力、空气阻力等；碰撞作用力：与场景或其他粒子<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">For each frame in animation</span><br><span class="line">[if needed] Create new particles</span><br><span class="line">Calculate forces on each particle</span><br><span class="line">Update each particle&#x27;s position and velocity</span><br><span class="line">[if needed] Remove dead particles</span><br><span class="line">Render particles</span><br></pre></td></tr></table></figure></li></ul></li><li>Rigging ：相当于在网格模型上设立关键的操控点，以及执行相应控制后对其它部位的影响和约束；例如完成提线木偶的控制、人物表情的变化、细微动作的实现<ul><li>动作捕捉 Motion Capture ：基于前者的逆向想法，真人携带控制点来执行动作，反馈给虚拟模型完成模拟；现有更广泛使用的方法还是 光学动作捕捉</li></ul></li></ul><h3 id="运动学-Kinematics"><a href="#运动学-Kinematics" class="headerlink" title="运动学 Kinematics"></a>运动学 Kinematics</h3><p>类比一个基础的骨架结构，运动学模型需要进行几个基本定义：</p><ol><li>拓扑结构 ；即各个组件（组件有长度并附带关节）之间的连接关系</li><li>关节处的几何关系 ：例如三维中用两个角度描述，其坐标系基于关节的父组件</li><li>树状结构 ：组件之间的层级构成树结构，避免成环</li></ol><ul><li>正向运动学 Forward Kinematics ：即通过每个关节的运动情况描述整体模型的运动<ul><li>优点 ：关节的描述很容易，且计算渐变</li><li>缺点 ：使用数值输入而非视觉确定，不方便设计</li></ul></li><li>逆向运动学 Inverse Kinematics ：可理解为主观控制组件的端点位置，求解各个组件的适当位置<ul><li>存在多解或误解情况，无直接求解方法，采用优化方法来调整</li></ul></li></ul><h3 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h3><h4 id="质点弹簧系统"><a href="#质点弹簧系统" class="headerlink" title="质点弹簧系统"></a>质点弹簧系统</h4><ul><li><strong>单个弹簧</strong></li></ul><p>考虑一个简单的 a,b 端点弹簧，具有自然长度 l 称为 rest length，其拉伸作用力</p><script type="math/tex; mode=display">f_{a\rightarrow b} = k_s\frac{b-a}{||b-a||}(||b-a||-l)</script><p>然而弹簧显然是不会“永动”的，因此要引入能量损耗，也即摩擦力</p><p><img src="/images/CG/Internal-Damping-for-Spring.png" alt="弹簧内部作用力"></p><p>其中 $\dot{b}$ 表示 位置 b 点的导数，也即 b 端点的速度</p><ul><li><strong>弹簧网格</strong></li></ul><p>仅完成单个弹簧的力显然不足以模拟物理效果，甚至连一块平面布都模拟不了：</p><ol><li>考虑屏幕上的方形弹簧网格，则其无法抵抗对角线上同时向外的切边力，也无法模拟沿对角线翻折的旋转力 —— 每个小方格都连接两个对角线</li><li>到上一步仍无法沿模拟水平、竖直方向的翻折，在此基础上增加横竖方向上端点的单步跳跃连接 “skip connection” —— 至此的弹簧系统能不错地模拟布匹的效果了</li></ol><h3 id="动画生产流程"><a href="#动画生产流程" class="headerlink" title="动画生产流程"></a>动画生产流程</h3><p><img src="/images/CG/The-Production-Pipline.png" alt="蛮有趣的"></p><p>但是实时渲染太牛啦，直接统括了很多流程</p><h2 id="求解方法"><a href="#求解方法" class="headerlink" title="求解方法"></a>求解方法</h2><h3 id="粒子运动的求解"><a href="#粒子运动的求解" class="headerlink" title="粒子运动的求解"></a>粒子运动的求解</h3><p>先考虑单个粒子在一个速度场内的运动，速度场可以由 v(x, t) 表述，因此建立了一个常微分方程 Ordinary Differential Equation</p><script type="math/tex; mode=display">\frac{dx}{dt}=\dot{x}=v(x, t)</script><ul><li>欧拉方法 Euler Method ：引入一个很小的 Δt 的微分来计算下一时刻的位置，有不稳定等诸多问题，且对很多场景没有正确的解</li><li>中点法 Midpoint Method ：基于欧拉法略微优化，实践有更好的效果<ol><li>在 Δt 下计算出单步的下一个点 a ，取到 a 的中点 b</li><li>以速度场在中点的速度作为当前点速度计算 Δt 后的位置</li><li>公式 $x(t+\Delta t=x(t)+\Delta t \cdot v(x_{mid}, t$</li></ol><ul><li>Adaptive Step Size 自适应步长 ：比较当前步长 Δt 下欧拉法结果和执行两次 Δt/2 的欧拉法结果的差异，若足够小就采用中点法，否则步长折半</li></ul></li><li>隐式欧拉法 Implicit Euler Method ：见下段落</li><li>龙格库塔法 Runge-Kutta Methods ：使用典型的四阶方法求解</li></ul><p>欧拉法会能量自增，隐式欧拉法会能量衰减；综合后有<strong>半隐式欧拉</strong></p><h4 id="隐式欧拉法"><a href="#隐式欧拉法" class="headerlink" title="隐式欧拉法"></a>隐式欧拉法</h4><p>相比于显式欧拉法用 t 时刻的微分推导 t+Δt 时刻，隐式欧拉法采用向后差商</p><script type="math/tex; mode=display">\dot{x}(t+\Delta t) = \frac{x(t+\Delta t) - x(t)}{\Delta t}</script><p>代入微分方程导数项得到 </p><script type="math/tex; mode=display">x(t+\Delta t) = x(t) + \Delta t v(x(t + \Delta t), t + \Delta t)</script><p>然后解方程得到下一步结果</p><ul><li>隐式欧拉法还有一个改进方法，其使用近似的积分形式来建立下一时刻的值方程</li></ul><h4 id="龙格库塔法"><a href="#龙格库塔法" class="headerlink" title="龙格库塔法"></a>龙格库塔法</h4><p>同样已知初值 $\dot{x} = v(x, t), \space x(t_0)=x_0$</p><p>经典四阶方法 RK4 由如下方程给出</p><script type="math/tex; mode=display">x_{t+dt} = x_t + \frac{dt}{6}(k_1 + 2k_2 +2k_3 +k_4)</script><p>描述了下一步的值由当前值、间隔 dt 和一个估算的斜率确定；其中</p><ul><li>$k_1 = v(x_t, t)$ 是片段起始的斜率</li><li>$k_2=v(x_t+\frac{dt}{2}k_1, t+\frac{dt}{2})$ 是片段中点的斜率，通过欧拉法采用 k1 来确定</li><li>$k_3=v(x_t+\frac{dt}{2}k_2, t+\frac{dt}{2})$ 也是中点斜率，但是通过欧拉法采用 k2 来确定</li><li>$k_4=v(x_t+dt \dot k_3, t + dt)$ 是片段终点的斜率，用 k3 确定</li></ul><p>该方法是四阶的，单步误差 O(dt^2) ，总误差 O(dt)</p><hr><ul><li>Position-Based / Verlet Integration ：给出一些约束来限制属性，会直接违背物理系统，但是用于保持稳定</li></ul><h3 id="刚体模拟-Rigid-Body-Simulation"><a href="#刚体模拟-Rigid-Body-Simulation" class="headerlink" title="刚体模拟 Rigid Body Simulation"></a>刚体模拟 Rigid Body Simulation</h3><p>刚体即视为内部点相对位置绝对不变的 “大粒子”，相对于粒子运动，其多考虑两个维度，即朝向角和角速度（旋转相关）</p><p><img src="/images/CG/Rigid-Body-Simulation.png" alt="刚体模拟"></p><h3 id="流体模拟-Fluid-Simulation"><a href="#流体模拟-Fluid-Simulation" class="headerlink" title="流体模拟 Fluid Simulation"></a>流体模拟 Fluid Simulation</h3><ul><li>核心想法：<ul><li>假定流体是由很多刚体小球构成的</li><li>假定流体在任何位置都是不可压缩的</li></ul></li></ul><p>此时为了模拟流体的运动，即引入 Verlet Integration，通过给出密度的约束，检测空间各位置上小球的密度，总是执行运动使其保持常数水平</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>作业框架没搞定，实现几个弹簧作用力很简单，有机会再补充</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1X7411F744?p=1&amp;amp;spm_id_from=pageDriver&quot;&gt;博客图片及学习路径来源 Gamse 101课程，在此记录以方便个人查阅为主，强烈建议自行</summary>
      
    
    
    
    <category term="Games-Graphics" scheme="http://remedios14.github.io/categories/Games-Graphics/"/>
    
    
    <category term="games" scheme="http://remedios14.github.io/tags/games/"/>
    
    <category term="计算机图形学" scheme="http://remedios14.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Games101-计算机图形学（五）</title>
    <link href="http://remedios14.github.io/2022/06/02/Games/101%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://remedios14.github.io/2022/06/02/Games/101%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E4%BA%94%EF%BC%89/</id>
    <published>2022-06-02T11:42:48.000Z</published>
    <updated>2022-06-26T15:19:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://www.bilibili.com/video/BV1X7411F744?p=1&amp;spm_id_from=pageDriver">博客图片及学习路径来源 Gamse 101课程，在此记录以方便个人查阅为主，强烈建议自行观看学习</a></strong></p><h2 id="Materials-and-Apperances-材质与外观"><a href="#Materials-and-Apperances-材质与外观" class="headerlink" title="Materials and Apperances 材质与外观"></a>Materials and Apperances 材质与外观</h2><p>对于一个材质，到现在已经接触过的与其关联的属性有</p><ul><li>渲染方程中的 BRDF，即已知 “入射、出射、法向” 的条件下计算出反射量的系数（镜面反射略，仅需考虑角度计算和吸收率即可实现）；<ul><li>考虑完全的漫反射，则对任一角度的入射光线，其都会向半球面均匀地反射，反过来即是说，对任一出射角度，其输出都是由半球面上的入射光线均匀地反射贡献的；将 f_r 视作常数提出积分式</li><li>考虑能量守恒，出射的总 irradiance 不会大于入射的，仅在完全反射（如白色表面）时相等；因此变换积分式如下<br><img src="/images/CG/Diffuse-Lambertian-Material.png" alt="漫反射材质"></li><li>结论即 f_r 在 [0, 1/Π] 中取值</li></ul></li><li>材质表面发生的光线折射，需要定义出入介质的折射率 η，$\eta_i sin\theta_i=\eta_t sin\theta_t$，使用时通常计算 $cos\theta_t$，存在一些情况下无解，即全反射情形</li><li>菲涅尔项 Fresnel Term ：描述不同的入射角度下不同材质对光线的反射水平，已经有完整的计算公式，以及 Schlick 近似<br><img src="/images/CG/Fresnel-Term-Formula.png" alt="F菲涅尔项公式及其近似"></li></ul><h3 id="微表面理论-Microfacet-Theory"><a href="#微表面理论-Microfacet-Theory" class="headerlink" title="微表面理论 Microfacet Theory"></a>微表面理论 Microfacet Theory</h3><p>认为根据视角远近观察一个表面有不同的效果：</p><ul><li>远处观察：表面可视作一个平面，具有粗糙不均匀的材质；表面的每个微元上进行完全的镜面反射</li><li>近处观察：可以看到表面上完整的几何形状，即构成曲面</li></ul><p>微表面理论将凹凸不平的表面近似成平面，该平面的法向视作所有凹凸镜面的法向的综合，即在一定范围内变动（变动范围视具体表面的凹凸水平），在此基础上构建材质的 BRDF，其中中间项 G 描述了凹凸块互相遮挡的情况，在入射光较水平时作用显著<br><img src="/images/CG/Microfacet-BRDF.png" alt="微表面 BRDF"></p><h3 id="各向异性-BRDF"><a href="#各向异性-BRDF" class="headerlink" title="各向异性 BRDF"></a>各向异性 BRDF</h3><p>回顾空间中的极坐标表示，其有两个角度 φ 和 θ 分别表示与 x 正向和 y 正向的夹角；</p><p>当一个材质的 BRDF 随 φ 的变化而不同时，称为<strong>各向异性</strong> —— 现实例子有各种金属表面形成辐射状的高光</p><p>在渲染实现上：</p><ul><li>各向同性通常构成有聚散的高光</li><li>各向异性通常构成条状分布的高光</li></ul><h3 id="BRDF-的性质"><a href="#BRDF-的性质" class="headerlink" title="BRDF 的性质"></a>BRDF 的性质</h3><ol><li>非负性</li><li>线性性：可随材质线性组合？</li><li>可逆性：入射和出射方向对换时保持值不变</li><li>能量守恒：文首给出的取值范围</li></ol><h3 id="测量-BRDF"><a href="#测量-BRDF" class="headerlink" title="测量 BRDF"></a>测量 BRDF</h3><p>使用固定光入射，从不同角度观察采集，然后通过角度关系来生成所有角度下的值情况；</p><p>现有可调库使用</p><h2 id="Advanced-Topics-in-Rendering"><a href="#Advanced-Topics-in-Rendering" class="headerlink" title="Advanced Topics in Rendering"></a>Advanced Topics in Rendering</h2><p>介绍为主</p><h3 id="Advanced-Light-Transport"><a href="#Advanced-Light-Transport" class="headerlink" title="Advanced Light Transport"></a>Advanced Light Transport</h3><h4 id="无偏的光线传播方法"><a href="#无偏的光线传播方法" class="headerlink" title="无偏的光线传播方法"></a>无偏的光线传播方法</h4><ul><li>双向路径追踪 Bidirectional Path Tracing (BDPT) ：思想即从光源和相机都打出 ray ，相连时渲染成像<ul><li>已经是非常牛的算法了，只要能够实现，就足以自制渲染器</li></ul></li><li>Metropolis Light Transport (MLT) ：已知一条正确光路后使用随机扰动来生成其他光路；在困难的渲染任务中效果尤佳</li></ul><h4 id="有偏的方法"><a href="#有偏的方法" class="headerlink" title="有偏的方法"></a>有偏的方法</h4><ul><li>Photon Mapping ：能很好地实现 caustics 效果，做法大致是从光源发射光子，正确地经过折射和镜面反射，直到漫反射表面上，然后在该表面上进行密度估计来着色<ul><li>密度估计：现有做法是固定一个光子数 N ，在着色点周围找面积 A 内含该数量的光子，以此估计密度，结果是<strong>有偏的，但一致的</strong>；若固定面积记光子数，则结果不是一致的</li></ul></li><li>Vertex Connection and Merging (VCM) ：结合 BDPT 和 Photon Mapping 的方法，即双向路径中部分没有连接上但是落到相近位置的子路径，将其视作光子来密度估计，最终完成着色</li></ul><h4 id="实时辐射度算法-Instant-Radiosity"><a href="#实时辐射度算法-Instant-Radiosity" class="headerlink" title="实时辐射度算法 Instant Radiosity"></a>实时辐射度算法 Instant Radiosity</h4><p>整体思路是将直接光源照射到的点视作虚拟的光源 Virtual Point Light ，后续有很多研究</p><h3 id="Advanced-Appearance-Modeling"><a href="#Advanced-Appearance-Modeling" class="headerlink" title="Advanced Appearance Modeling"></a>Advanced Appearance Modeling</h3><h4 id="Non-surface-Models"><a href="#Non-surface-Models" class="headerlink" title="Non-surface Models"></a>Non-surface Models</h4><ul><li>Participating media ：散射介质<ul><li>光线在介质传播过程中，被吸收或者散射，其中吸收部分使用系数即可</li><li>散射部分在介质内进行多次得到一条路径上多个着色点，然后都与光源连接并综合即得到单条路径在屏幕上的成像</li><li>例子如 烟雾效果，浓烟即吸收的多，散射的少；大多数物体都能作为散射介质，如各种流体</li></ul></li><li>Hair / fur / fiber (BCSDF) ：非常遗憾的，这几种材质的光作用效果并不完全相同<ul><li>头发通常视作玻璃柱体，接收到光线 部分反射，部分折射进入内壁再反射出来 … Marschner model 现有的已经取得很好头发渲染效果的模型，贴合现实</li><li>动物毛发相比人类头发有更大的髓质，因此相当于双层玻璃管，针对此构建了 Double Cylinder Model，反过来也能用到头发上；模型中带 s 表示穿过髓质发生散射的部分<br><img src="/images/CG/Double-Cylinder-Model.png" alt="双圆柱模型"></li></ul></li><li>Granular material ：粒状堆积的材料</li></ul><h4 id="Surface-Models"><a href="#Surface-Models" class="headerlink" title="Surface Models"></a>Surface Models</h4><ul><li>Translucent material (BSSRDF) 如玉石等接近半透明的材质，光线从某个点进入材质，在内部发生大量散射，最终离开材质 —— 称为 <strong>次表面散射</strong> BSSRDF<ul><li>Dipole Approximation，实际上没搞定这种效果，用材质表面的内外两个点光源近似实现的观察效果</li></ul></li><li>Cloth 由一系列缠绕形成的 Fibers -&gt; Plys -&gt; Yarn -&gt; Cloth ；暴力的将某个层级的单位视作玻璃主题进行渲染，使用越原始层级则越复杂</li><li>Detailed material (non-statistical BRDF) ：即微表面上的凹凸效果渲染，神了</li><li>Wave Optics 波动光学，更细微到将光线细分到波 …</li></ul><h4 id="Procedural-Appearance"><a href="#Procedural-Appearance" class="headerlink" title="Procedural Appearance"></a>Procedural Appearance</h4><p>使用噪声来对空间中任意的坐标点定义纹理，完成视觉效果</p><h2 id="Cameras-Lenses-and-Light-Fields"><a href="#Cameras-Lenses-and-Light-Fields" class="headerlink" title="Cameras, Lenses and Light Fields"></a>Cameras, Lenses and Light Fields</h2><p>相机、透镜和光场</p><h3 id="摄像机原理"><a href="#摄像机原理" class="headerlink" title="摄像机原理"></a>摄像机原理</h3><p>之前介绍的图形学上成像方法都是合成方法，光栅化和光线追踪都是将虚拟的由 坐标、关系、属性 定义的空间物体经过物理模拟算法变换到成像平面上的结果</p><p>这里大致介绍一下现实中的摄像机原理，以助理解</p><h4 id="Field-of-View"><a href="#Field-of-View" class="headerlink" title="Field of View"></a>Field of View</h4><p>相比于光栅化中提及的，摄像机的外物和成像平面在透镜两侧，先穿过透镜完成倒立的画面</p><h4 id="Exposure-曝光"><a href="#Exposure-曝光" class="headerlink" title="Exposure 曝光"></a>Exposure 曝光</h4><p>Exposure = time × irradiance</p><p>相机上有 快门 等来从时间上控制曝光量</p><h4 id="透镜和焦点"><a href="#透镜和焦点" class="headerlink" title="透镜和焦点"></a>透镜和焦点</h4><p>高中物理知识；平行光过焦点、过焦点光会平行</p><h4 id="Light-Field-Lumigraph"><a href="#Light-Field-Lumigraph" class="headerlink" title="Light Field / Lumigraph"></a>Light Field / Lumigraph</h4><p>在一个三维极坐标系下记录每一个角度 (θ, φ) 下看到的光即得到个体的视觉世界，在此基础上增加时间维度形成动画，后续也可以追加其他可视点作为视角位置进行拓展，由此构成了 <strong>全光函数</strong> ：$P(\theta, \phi, V_x, V_y, V_z)$</p><p>光场 ：描述了在任意一个位置向任意一个方向的光强度，是全光函数的一部分；光场即一个四维函数，方便表述观察某个点的光效果</p><p>对于这个四维函数，可以由两个前后平行平面上的两个点确定，因此也可以理解客观世界在平面 2 后方，观测者在平面 1 前方，透过 1 观察 2 的效果</p><p>昆虫复眼的成像原理就像光场一样，每一个复眼的单位视作平面 2 和 1 的组合，将观察外部得到的光线方向记录下来</p><h2 id="Color-and-Perception"><a href="#Color-and-Perception" class="headerlink" title="Color and Perception"></a>Color and Perception</h2><ul><li>Spectrum 光谱：是复色光经过色散系统（如棱镜、光栅）分光后，被色散开的单色光按波长（或频率）大小而依次排列的图案，全称为光学频谱</li><li>Spectral Power Distribution 谱功率密度 (SPD) ：描述光在单位波长的分布情况，具有线性叠加的性质</li></ul><p>颜色源自于人的感知，而非光的一般性质：</p><ol><li>光线的光谱进入人眼到达视网膜<ul><li>光谱视作与波长有关的函数</li></ul></li><li>视网膜上三种细胞感受到光谱<ul><li>每种细胞对光谱的接受度不一样，同样是与波长有关的函数，根据其分布分为 S、M、L 分别对 短、中、长 波长强接受</li></ul></li><li>三种细胞综合处理将结果传给大脑 （处理可以理解为积分运算）</li></ol><h3 id="Metamerism-同色异谱"><a href="#Metamerism-同色异谱" class="headerlink" title="Metamerism 同色异谱"></a>Metamerism 同色异谱</h3><p>使用不同的光谱调配出相同的颜色结果</p><p>认为地定义三个分布函数去模拟上述地 S、M、L 细胞的组合，可以自行构建颜色空间</p><h3 id="颜色空间"><a href="#颜色空间" class="headerlink" title="颜色空间"></a>颜色空间</h3><p>加色系统</p><ul><li>HSV (Hue-Saturation-Value) ：色调、饱和度、值 的三维组合</li><li>CIELAB 空间：使用 亮度加上两队互补色</li></ul><p>减色系统</p><ul><li>CMYK</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1X7411F744?p=1&amp;amp;spm_id_from=pageDriver&quot;&gt;博客图片及学习路径来源 Gamse 101课程，在此记录以方便个人查阅为主，强烈建议自行</summary>
      
    
    
    
    <category term="Games-Graphics" scheme="http://remedios14.github.io/categories/Games-Graphics/"/>
    
    
    <category term="games" scheme="http://remedios14.github.io/tags/games/"/>
    
    <category term="计算机图形学" scheme="http://remedios14.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
</feed>
