<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mikyi喵喵呜~</title>
  
  <subtitle>So we beat on, boats against the current, borne back ceaselessly into the past.</subtitle>
  <link href="http://remedios14.github.io/atom.xml" rel="self"/>
  
  <link href="http://remedios14.github.io/"/>
  <updated>2022-09-11T12:31:28.000Z</updated>
  <id>http://remedios14.github.io/</id>
  
  <author>
    <name>Mikyi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WebGL-入门环境搭建</title>
    <link href="http://remedios14.github.io/2022/09/11/Graphics/WebGL-%E5%85%A5%E9%97%A8%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://remedios14.github.io/2022/09/11/Graphics/WebGL-%E5%85%A5%E9%97%A8%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2022-09-11T12:30:55.000Z</published>
    <updated>2022-09-11T12:31:28.000Z</updated>
    
    
    
    
    <category term="WebGL" scheme="http://remedios14.github.io/categories/WebGL/"/>
    
    
  </entry>
  
  <entry>
    <title>Golang-常规算法实现</title>
    <link href="http://remedios14.github.io/2022/09/10/Golang/Golang-%E5%B8%B8%E8%A7%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://remedios14.github.io/2022/09/10/Golang/Golang-%E5%B8%B8%E8%A7%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-09-10T15:20:41.000Z</published>
    <updated>2023-12-24T07:14:33.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="暂时不更新"><a href="#暂时不更新" class="headerlink" title="暂时不更新"></a>暂时不更新</h1><p>虽然没有变成很厉害的程序员，但是已经开始工作了，非必要情况下反而没意愿去实现算法了，所以此篇章可能长期保持不更新状态</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;暂时不更新&quot;&gt;&lt;a href=&quot;#暂时不更新&quot; class=&quot;headerlink&quot; title=&quot;暂时不更新&quot;&gt;&lt;/a&gt;暂时不更新&lt;/h1&gt;&lt;p&gt;虽然没有变成很厉害的程序员，但是已经开始工作了，非必要情况下反而没意愿去实现算法了，所以此篇章可能长期保持不更新状态</summary>
      
    
    
    
    <category term="Golang" scheme="http://remedios14.github.io/categories/Golang/"/>
    
    
    <category term="algorithm" scheme="http://remedios14.github.io/tags/algorithm/"/>
    
    <category term="datastruct" scheme="http://remedios14.github.io/tags/datastruct/"/>
    
  </entry>
  
  <entry>
    <title>Golang-QuickIntro</title>
    <link href="http://remedios14.github.io/2022/09/03/Golang/Golang-QuickIntro/"/>
    <id>http://remedios14.github.io/2022/09/03/Golang/Golang-QuickIntro/</id>
    <published>2022-09-02T16:26:02.000Z</published>
    <updated>2022-09-02T17:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="yosoro"><a href="#yosoro" class="headerlink" title="yosoro~"></a>yosoro~</h1><p>编写一个简单的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在当前目录下 <code>go build</code> 编译所有 <code>.go</code> 文件并生成同名的二进制文件(或者 <code>go build &lt;name.go&gt;</code> 编译指定文件)，在终端直接执行；</p><p>或者 <code>go run &lt;name.go&gt;</code> 直接运行指定代码文件</p><p>主要特性：</p><ul><li>自动垃圾回收 GC</li><li>更丰富的内置类型</li><li>函数多返回值</li><li>错误处理</li><li>匿名函数和闭包</li><li>类型和接口</li><li>并发编程</li><li>反射</li><li>语言交互性</li></ul><h2 id="Go-语言结构"><a href="#Go-语言结构" class="headerlink" title="Go 语言结构"></a>Go 语言结构</h2><p>基础组成包括如下：</p><ul><li>包声明（必须在第一行声明所属）；<code>package main</code> 表示一个可独立执行的程序，每个 Go 应用程序都至少要有一个</li><li>引入包，格式 <code>import &quot;pname&quot;</code>，其中 fmt 包进行 IO，<code>fmt.Println()</code></li><li>函数（<code>main</code> 函数是可执行程序必须的，但若有 <code>init()</code> 函数会先执行它）</li><li>变量</li><li>语句&amp;表达式</li><li>注释（同 Java）</li></ul><p>标识符（包括常量、变量、类型、函数名、结构字段等）若以大写字母开头如 <code>Group1</code> 则可被外部的包使用（类似 public）；否则类似 protected，仅包内部可见</p><p>注意 <code>&#123;</code> 不能单独构成一行</p><h2 id="Go-语言基础语法"><a href="#Go-语言基础语法" class="headerlink" title="Go 语言基础语法"></a>Go 语言基础语法</h2><p>通常一行完成一条语句无需 <code>;</code> 换行，但若多条写在同一行（虽然不推荐）则需要用 <code>;</code> 分隔</p><p>字符串直接用 <code>+</code> 拼接</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><div class="table-container"><table><thead><tr><th>break</th><th>default</th><th>func</th><th>interface</th><th>select</th></tr></thead><tbody><tr><td>case</td><td>defer</td><td>go</td><td>map</td><td>struct</td></tr><tr><td>chan</td><td>else</td><td>goto</td><td>package</td><td>switch</td></tr><tr><td>const</td><td>fallthrough</td><td>if</td><td>range</td><td>type</td></tr><tr><td>continue</td><td>for</td><td>import</td><td>return</td><td>var</td></tr></tbody></table></div><p>以及预定义标识符</p><div class="table-container"><table><thead><tr><th>append</th><th>bool</th><th>byte</th><th>cap</th><th>close</th><th>complex</th><th>complex64</th><th>complex128</th><th>uint16</th></tr></thead><tbody><tr><td>copy</td><td>false</td><td>float32</td><td>float64</td><td>imag</td><td>int</td><td>int8</td><td>int16</td><td>uint32</td></tr><tr><td>int32</td><td>int64</td><td>iota</td><td>len</td><td>make</td><td>new</td><td>nil</td><td>panic</td><td>uint64</td></tr><tr><td>print</td><td>println</td><td>real</td><td>recover</td><td>string</td><td>true</td><td>uint</td><td>uint8</td><td>uintptr</td></tr></tbody></table></div><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><p>空格增加可读性</p><p><code>fmt.Sprintf</code> 格式化输出字符串</p><h2 id="Go-语言数据类型"><a href="#Go-语言数据类型" class="headerlink" title="Go 语言数据类型"></a>Go 语言数据类型</h2><p>数据类型用于声明函数和变量，申请内存</p><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">类型和描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>布尔型</strong> 布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。默认值 <strong>false</strong></td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>数字类型</strong> 整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。默认值（包括 complex64/128） 为 <strong>0</strong></td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>字符串类型:</strong> 字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。默认值为 <strong>“”</strong> （空字符串）</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>派生类型:</strong> 包括：(a) 指针类型（Pointer）(b) 数组类型(c) 结构化类型(struct)(d) Channel 类型(e) 函数类型(f) 切片类型(g) 接口类型（interface）(h) Map 类型</td></tr></tbody></table></div><p>派生类型中， 1) 指针；2) 数组；3) Map；4) Chan；5) Func；6) error (接口) 类型的默认值为 <strong>nil</strong></p><h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">类型和描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>uint8</strong> 无符号 8 位整型 (0 到 255)</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>uint16</strong> 无符号 16 位整型 (0 到 65535)</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>uint32</strong> 无符号 32 位整型 (0 到 4294967295)</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>uint64</strong> 无符号 64 位整型 (0 到 18446744073709551615)</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>int8</strong> 有符号 8 位整型 (-128 到 127)</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><strong>int16</strong> 有符号 16 位整型 (-32768 到 32767)</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><strong>int32</strong> 有符号 32 位整型 (-2147483648 到 2147483647)</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><strong>int64</strong> 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)</td></tr></tbody></table></div><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">类型和描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>float32</strong> IEEE-754 32位浮点型数</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>float64</strong> IEEE-754 64位浮点型数</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>complex64</strong> 32 位实数和虚数</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>complex128</strong> 64 位实数和虚数</td></tr></tbody></table></div><h4 id="其他数字类型"><a href="#其他数字类型" class="headerlink" title="其他数字类型"></a>其他数字类型</h4><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">类型和描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>byte</strong> 类似 uint8</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>rune</strong> 类似 int32</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>uint</strong> 32 或 64 位</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>int</strong> 与 uint 一样大小</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>uintptr</strong> 无符号整型，用于存放一个指针</td></tr></tbody></table></div><h2 id="Go-语言变量"><a href="#Go-语言变量" class="headerlink" title="Go 语言变量"></a>Go 语言变量</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier1[, identifier2] <span class="keyword">type</span></span><br></pre></td></tr></table></figure><p>一般使用 <code>var</code> 关键字，可同时声明多个变量，在最后指定类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">string</span> = <span class="string">&quot;Runoob&quot;</span></span><br><span class="line">    fmt.Println(a) <span class="comment">// Runoob</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> b, c <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    fmt.Println(b, c) <span class="comment">// 1 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三种声明方法"><a href="#三种声明方法" class="headerlink" title="三种声明方法"></a>三种声明方法</h3><ol><li>先初始化再赋值，需要指定类型</li><li>直接赋值，可以自动判断类型无需显式写 <code>type</code></li><li><code>:=</code> 完成声明和赋值，只能用于初次声明变量（也只能用在函数体中）</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x, y <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> (  <span class="comment">// 这种因式分解关键字的写法一般用于声明全局变量</span></span><br><span class="line">    a <span class="type">int</span></span><br><span class="line">    b <span class="type">bool</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c, d <span class="type">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> e, f = <span class="number">123</span>, <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这种不带声明格式的只能在函数体中出现</span></span><br><span class="line"><span class="comment">//g, h := 123, &quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    g, h := <span class="number">123</span>, <span class="string">&quot;hello&quot;</span></span><br><span class="line">    <span class="built_in">println</span>(x, y, a, b, c, d, e, f, g, h)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h3><h4 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h4><p>所有像 int、float、bool 和 string 这些基本类型都属于值类型，其变量直接指向内存中的值，在 <code>=</code> 赋值时在内存中进行了拷贝</p><p><code>&amp;i</code> 获取到变量 <code>i</code> 的内存地址，如 0xf840000040 （每次运行的地址都可能不一样）。值类型变量的值存储在栈中。</p><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p><code>r1</code> 存储的是 <code>r1</code> 的值所在的内存地址（数字），或内存地址中第一个字所在的位置。</p><p>这个内存地址称之为指针，这个指针实际上也被存在另外的某一个值中。</p><p>当使用 <code>r2 = r1</code> 时，只有引用（地址）被复制</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li>在代码块中不使用一个声明的局部变量会<strong>编译错误</strong>，仅赋值也不行</li><li>全局变量允许声明不使用</li><li>交换变量值 <code>a, b = b, a</code> 在同类型变量间可用</li><li>空白标识符 <code>_</code> 用于抛弃值，其是一个只写变量，不能获取值</li></ul><h2 id="Go-语言常量-const"><a href="#Go-语言常量-const" class="headerlink" title="Go 语言常量 const"></a>Go 语言常量 const</h2><p>常量是一个简单值的标识符，在程序运行时不会被修改的量。</p><p>常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。定义格式如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> identifier [<span class="keyword">type</span>] = value</span><br></pre></td></tr></table></figure><p>可以省略 <code>[type]</code> 交给编译器自行判断</p><p>常量不能用 <code>:=</code> 语法声明</p><p>常量还可以用作枚举，也可以用内置函数计算表达式的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;unsafe&quot;</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="string">&quot;abc&quot;</span></span><br><span class="line">    <span class="comment">// 常量表达式用到的函数只能使用内置函数</span></span><br><span class="line">    b = <span class="built_in">len</span>(a)</span><br><span class="line">    c = unsafe.Sizeof(a)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">println</span>(a, b, c) <span class="comment">// abc 3 16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h3><p>特殊常量，可以认为是一个可以被编译器修改的常量</p><p>在 <code>const</code> 语句块中构成行索引，初始化 0，每行 <code>+1</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">            a = <span class="literal">iota</span>   <span class="comment">//0</span></span><br><span class="line">            b          <span class="comment">//1</span></span><br><span class="line">            c          <span class="comment">//2</span></span><br><span class="line">            d = <span class="string">&quot;ha&quot;</span>   <span class="comment">//独立值，iota += 1</span></span><br><span class="line">            e          <span class="comment">//&quot;ha&quot;   iota += 1</span></span><br><span class="line">            f = <span class="number">100</span>    <span class="comment">//iota +=1</span></span><br><span class="line">            g          <span class="comment">//100  iota +=1</span></span><br><span class="line">            h = <span class="literal">iota</span>   <span class="comment">//7,恢复计数</span></span><br><span class="line">            i          <span class="comment">//8</span></span><br><span class="line">    )</span><br><span class="line">    fmt.Println(a,b,c,d,e,f,g,h,i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">const</span> ( <span class="comment">// 进行了位运算</span></span><br><span class="line">    i=<span class="number">1</span>&lt;&lt;<span class="literal">iota</span></span><br><span class="line">    j=<span class="number">3</span>&lt;&lt;<span class="literal">iota</span></span><br><span class="line">    k</span><br><span class="line">    l</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;i=&quot;</span>,i) <span class="comment">// 1 —— 1 &lt;&lt; 0</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;j=&quot;</span>,j) <span class="comment">// 6 —— 3 &lt;&lt; 1</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;k=&quot;</span>,k) <span class="comment">// 12 —— 3 &lt;&lt; 2</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;l=&quot;</span>,l) <span class="comment">// 24 —— 3 &lt;&lt; 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Go-语言运算符"><a href="#Go-语言运算符" class="headerlink" title="Go 语言运算符"></a>Go 语言运算符</h2><p>算数、关系、逻辑、位、赋值、其他</p><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p><code>+ - * / % ++ --</code> 完全一致，其中 <code>/</code> 对整数为整除</p><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p><code>== != &gt; &lt; &gt;= &lt;=</code></p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p><code>&amp;&amp; || !</code></p><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p><code>&amp;</code> 与 <code>|</code> 或 <code>^</code> 异或 <code>&lt;&lt;</code> 左移 <code>&gt;&gt;</code> 右移</p><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>略</p><h3 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h3><div class="table-container"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">&amp;</td><td style="text-align:left">返回变量存储地址</td><td style="text-align:left">&a; 将给出变量的实际地址。</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">指针变量。</td><td style="text-align:left">*a; 是一个指针变量</td></tr></tbody></table></div><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><div class="table-container"><table><thead><tr><th style="text-align:left">优先级</th><th style="text-align:left">运算符</th></tr></thead><tbody><tr><td style="text-align:left">5</td><td style="text-align:left">* / % &lt;&lt; &gt;&gt; &amp; &amp;^</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">+ - \</td><td>^</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">== != &lt; &lt;= &gt; &gt;=</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">&amp;&amp;</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">\</td><td>\</td></tr></tbody></table></div><h2 id="Go-语言条件语句"><a href="#Go-语言条件语句" class="headerlink" title="Go 语言条件语句"></a>Go 语言条件语句</h2><p><code>if ... else if ... else ...</code> 类似 <code>Python</code> 无需括号，但 <code>&#123;&#125;</code> 必须</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在条件语句中声明变量（仅在条件语句 <code>if ... else ...</code> 内部生效的局部变量）</p><h3 id="Switch-语句"><a href="#Switch-语句" class="headerlink" title="Switch 语句"></a>Switch 语句</h3><p>自上到下逐一测试直到匹配（默认在 <code>case</code> 最后自带 <code>break</code> ，若不希望终止可以使用 <code>fallthrough</code> ）支持多值 match</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> var1 &#123;</span><br><span class="line">    <span class="keyword">case</span> val1:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> val2, val3, val4:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>var1</code> 可以是任何类型，而 <code>val1</code> 和 <code>val2</code> 只需要是同类型值（或表达式）即可</p><h4 id="Type-Switch"><a href="#Type-Switch" class="headerlink" title="Type Switch"></a>Type Switch</h4><p><code>switch</code> 的用法之一，用于判断某个 <code>interface</code> 变量中实际存储的变量类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> x.(<span class="keyword">type</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">type</span>:</span><br><span class="line">    statement(s)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">type</span>:</span><br><span class="line">    statement(s)</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 可选 */</span></span><br><span class="line">    statement(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fallthrough"><a href="#fallthrough" class="headerlink" title="fallthrough"></a>fallthrough</h4><p>写在原来 <code>break</code> 的位置，当遇到时会无视下一条 <code>case</code> 的条件执行下一条</p><h3 id="Select-语句"><a href="#Select-语句" class="headerlink" title="Select 语句"></a>Select 语句</h3><p>类似于通信的 <code>switch</code> 语句，每个 <code>case</code> 必须是一个通信操作（发送或接收）</p><p><code>select</code> 随机执行一个可运行的 <code>case</code> ，如果没有 <code>case</code> 可运行，则会阻塞直到有。</p><p>一个默认的子句应该总是可运行的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> c1, c2, c3 <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">   <span class="keyword">var</span> i1, i2 <span class="type">int</span></span><br><span class="line">   <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> i1 = &lt;-c1:</span><br><span class="line">         fmt.Printf(<span class="string">&quot;received &quot;</span>, i1, <span class="string">&quot; from c1\n&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> c2 &lt;- i2:</span><br><span class="line">         fmt.Printf(<span class="string">&quot;sent &quot;</span>, i2, <span class="string">&quot; to c2\n&quot;</span>)</span><br><span class="line">      <span class="keyword">case</span> i3, ok := (&lt;-c3):  <span class="comment">// same as: i3, ok := &lt;-c3</span></span><br><span class="line">         <span class="keyword">if</span> ok &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;received &quot;</span>, i3, <span class="string">&quot; from c3\n&quot;</span>)</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;c3 is closed\n&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">         fmt.Printf(<span class="string">&quot;no communication\n&quot;</span>)</span><br><span class="line">   &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>select</code> 语句的语法如下：</p><ul><li><p>每个 case 都必须是一个通信</p></li><li><p>所有 channel 表达式都会被求值</p></li><li><p>所有被发送的表达式都会被求值</p></li><li><p>如果人以某个通信可以进行，它就执行，<strong>其他被忽略</strong></p></li><li><p>如果有多个 case 都可以运行，Select 会<strong>随机</strong>公平地选出一个执行。<strong>其他不会执行</strong>。</p><p>否则：</p><ol><li>如果有 default 子句，则执行该语句</li><li>如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值</li></ol></li></ul><h2 id="Go-语言循环语句"><a href="#Go-语言循环语句" class="headerlink" title="Go 语言循环语句"></a>Go 语言循环语句</h2><p><code>for</code> 循环 </p><ul><li><code>for init; condition; post &#123;&#125;</code> 可以省略其中的 <code>init</code> 和 <code>post</code> （但要有分号）</li><li><p><code>for condition &#123;&#125;</code> 类同 <code>while</code> </p></li><li><p>直接 <code>for &#123;&#125;</code> 类同 C 中的 <code>for (;;)</code> ，会直接无限循环</p></li></ul><h4 id="For-each-range-循环"><a href="#For-each-range-循环" class="headerlink" title="For-each range 循环"></a>For-each range 循环</h4><p>可以对字符串、数组、切片等进行迭代输出元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> oldMap &#123;</span><br><span class="line">    newMap[key] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h3><h4 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h4><ul><li>用于循环语句中跳出循环，并开始执行<strong>循环之后</strong>的语句</li><li>在 switch 语句中执行一条 case 后跳出语句</li><li>在多重循环中用标号 label 标出想 break 的循环</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不使用标记</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;---- break ----&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;i: %d\n&quot;</span>, i)</span><br><span class="line">                <span class="keyword">for</span> i2 := <span class="number">11</span>; i2 &lt;= <span class="number">13</span>; i2++ &#123;</span><br><span class="line">                        fmt.Printf(<span class="string">&quot;i2: %d\n&quot;</span>, i2)</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用标记</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;---- break label ----&quot;</span>)</span><br><span class="line">    re:</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;i: %d\n&quot;</span>, i)</span><br><span class="line">            <span class="keyword">for</span> i2 := <span class="number">11</span>; i2 &lt;= <span class="number">13</span>; i2++ &#123;</span><br><span class="line">                fmt.Printf(<span class="string">&quot;i2: %d\n&quot;</span>, i2)</span><br><span class="line">                <span class="keyword">break</span> re</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h4><p>可以使用 label ，其他无变化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不使用标记</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;---- continue ---- &quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;i: %d\n&quot;</span>, i)</span><br><span class="line">            <span class="keyword">for</span> i2 := <span class="number">11</span>; i2 &lt;= <span class="number">13</span>; i2++ &#123;</span><br><span class="line">                fmt.Printf(<span class="string">&quot;i2: %d\n&quot;</span>, i2)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用标记</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;---- continue label ----&quot;</span>)</span><br><span class="line">    re:</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;i: %d\n&quot;</span>, i)</span><br><span class="line">                <span class="keyword">for</span> i2 := <span class="number">11</span>; i2 &lt;= <span class="number">13</span>; i2++ &#123;</span><br><span class="line">                    fmt.Printf(<span class="string">&quot;i2: %d\n&quot;</span>, i2)</span><br><span class="line">                    <span class="keyword">continue</span> re</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="goto-语句"><a href="#goto-语句" class="headerlink" title="goto 语句"></a>goto 语句</h4><p>不推荐使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 循环 */</span></span><br><span class="line">   LOOP: <span class="keyword">for</span> a &lt; <span class="number">20</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> a == <span class="number">15</span> &#123;</span><br><span class="line">         <span class="comment">/* 跳过迭代 */</span></span><br><span class="line">         a = a + <span class="number">1</span></span><br><span class="line">         <span class="keyword">goto</span> LOOP</span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;a的值为 : %d\n&quot;</span>, a)</span><br><span class="line">      a++    </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Go-语言函数"><a href="#Go-语言函数" class="headerlink" title="Go 语言函数"></a>Go 语言函数</h2><p>最少有一个 main() 函数</p><p>函数声明告诉编译器 函数的名称，返回类型和参数</p><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">( [parameter list] )</span></span> [return_types] &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数定义解析：</p><ul><li>func ：函数由 func 开始声明</li><li>function_name ：函数名称，参数列表和返回值类型构成了函数签名</li><li>parameter list ：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的时参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数</li><li>return_types ：返回类型，函数返回一列值。return_types 时该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的</li><li>函数体：函数定义的代码集合</li></ul><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>可以前缀关键词实现不同形式的函数调用</p><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a><a href="http://blog.go-zh.org/defer-panic-and-recover">defer</a></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;world&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>defer 会将函数推迟到外层函数返回之后执行</p><p>推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用</p><p>推迟的函数调用会被压入一个栈中，最后按照后进先出顺序调用</p><h3 id="函数返回多个值"><a href="#函数返回多个值" class="headerlink" title="函数返回多个值"></a>函数返回多个值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">string</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a, b := swap(<span class="string">&quot;Google&quot;</span>, <span class="string">&quot;Runoob&quot;</span>)</span><br><span class="line">   fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>函数如果使用参数，该变量可称为函数的形参，形参就像定义在函数体内的局部变量</p><ul><li>值传递</li></ul><p>在调用函数时将实际参数复制一份传递到函数中，从而在函数中的修改不会影响到实际参数</p><p><strong>默认情况</strong>下，Go 语言使用的是值传递</p><ul><li>引用传递</li></ul><p>在调用函数时将实际参数的地址传递到函数中，从而在函数中对参数所进行的修改将影响到实际参数</p><p>操作上是将指针参数传递到函数内</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">100</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="type">int</span>= <span class="number">200</span></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换前，a 的值 : %d\n&quot;</span>, a )</span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换前，b 的值 : %d\n&quot;</span>, b )</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 调用 swap() 函数</span></span><br><span class="line"><span class="comment">   * &amp;a 指向 a 指针，a 变量的地址</span></span><br><span class="line"><span class="comment">   * &amp;b 指向 b 指针，b 变量的地址</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   swap(&amp;a, &amp;b)</span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换后，a 的值 : %d\n&quot;</span>, a )</span><br><span class="line">   fmt.Printf(<span class="string">&quot;交换后，b 的值 : %d\n&quot;</span>, b )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x *<span class="type">int</span>, y *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> temp <span class="type">int</span></span><br><span class="line">   temp = *x    <span class="comment">/* 保存 x 地址上的值 */</span></span><br><span class="line">   *x = *y      <span class="comment">/* 将 y 值赋给 x */</span></span><br><span class="line">   *y = temp    <span class="comment">/* 将 temp 值赋给 y */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数用法"><a href="#函数用法" class="headerlink" title="函数用法"></a>函数用法</h3><ul><li>传递给变量构成一个函数变量</li><li>闭包，借助匿名函数可直接使用函数内的变量而不必声明</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSequence</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">   i:=<span class="number">0</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">      i+=<span class="number">1</span></span><br><span class="line">     <span class="keyword">return</span> i  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">/* nextNumber 为一个函数，函数 i 为 0 */</span></span><br><span class="line">   nextNumber := getSequence()  </span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 调用 nextNumber 函数，i 变量自增 1 并返回 */</span></span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 创建新的函数 nextNumber1，并查看结果 */</span></span><br><span class="line">   nextNumber1 := getSequence()  </span><br><span class="line">   fmt.Println(nextNumber1())</span><br><span class="line">   fmt.Println(nextNumber1())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法，即一个包含了接受者的函数，接受者可以使命名类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集（类似面向对象）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(variable_name variable_data_type)</span></span> function_name() [return_type] &#123;</span><br><span class="line">    <span class="comment">/* 函数体 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义结构体 */</span></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">  radius <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> c1 Circle</span><br><span class="line">  c1.radius = <span class="number">10.00</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;圆的面积 = &quot;</span>, c1.getArea())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该 method 属于 Circle 类型对象中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span></span> getArea() <span class="type">float64</span> &#123;</span><br><span class="line">  <span class="comment">//c.radius 即为 Circle 类型对象中的属性</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">3.14</span> * c.radius * c.radius</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Go-语言变量作用域"><a href="#Go-语言变量作用域" class="headerlink" title="Go 语言变量作用域"></a>Go 语言变量作用域</h2><p>作用域为已声明标识符所表示的常量、类型、变量、函数或包在源代码中的作用范围</p><p>变量可以在三个地方声明：</p><ul><li>函数内定义的变量称为局部变量</li><li>函数外定义的变量称为全局变量</li><li>函数定义中的变量称为形式参数（相当于函数体内的局部变量）</li></ul><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>在函数体内声明，包括参数和返回值变量</p><p>可以与全局变量<strong>同名</strong>，在函数内会优先使用局部变量</p><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>在函数体外声明（<code>main</code> 函数外），可以在整个包甚至外部包（被导出后）使用</p><h2 id="Go-语言数组"><a href="#Go-语言数组" class="headerlink" title="Go 语言数组"></a>Go 语言数组</h2><p>数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，类型可以是任意的原始类型（整型、字符串等）或自定义类型</p><p>一个数组变量表示整个数组，在赋值或传递时会复制整个数组，如果希望避免复制则可以传递数组的<strong>指针</strong></p><h3 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h3><p>需要指定元素类型及元素个数</p><p><code>var variable_name [SIZE] variable_type</code> —— <code>var balance [10] float32</code></p><h3 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> balance = [<span class="number">5</span>]<span class="type">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br><span class="line">balance1 := [<span class="number">5</span>]<span class="type">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> balance2 = [...]<span class="type">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br><span class="line"><span class="comment">// 或（长度不确定时可以使用 ... 会在初始化时自行判断长度）</span></span><br><span class="line">balance3 := [...]<span class="type">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  将索引为 1 和 3 的元素初始化</span></span><br><span class="line">balance4 := [<span class="number">5</span>]<span class="type">float32</span>&#123;<span class="number">1</span>:<span class="number">2.0</span>,<span class="number">3</span>:<span class="number">7.0</span>&#125;</span><br></pre></td></tr></table></figure><p><code>&#123;&#125;</code> 中的元素个数不能大于 <code>[]</code></p><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>套几个 <code>[]</code> 来声明，<code>&#123;&#125;</code> 来初始化即可</p><h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><p>同其他语言</p><h2 id="Go-语言指针"><a href="#Go-语言指针" class="headerlink" title="Go 语言指针"></a>Go 语言指针</h2><p>取地址符 <code>&amp;</code></p><h3 id="什么是指针"><a href="#什么是指针" class="headerlink" title="什么是指针"></a>什么是指针</h3><p>一个指针变量指向了一个值的内存地址，声明格式如下：</p><p><code>var var_name *var-type</code> 例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ip *<span class="type">int</span> <span class="comment">/* 指向整型 */</span></span><br><span class="line"><span class="keyword">var</span> fp *<span class="type">float32</span> <span class="comment">/* 指向浮点型 */</span></span><br></pre></td></tr></table></figure><h3 id="如何使用指针"><a href="#如何使用指针" class="headerlink" title="如何使用指针"></a>如何使用指针</h3><p>流程：</p><ol><li>定义指针变量</li><li>为指针变量赋值</li><li>访问指针变量中指向地址的值（<strong>在指针类型前加上 <code>*</code> 来获取指针所指向的内容</strong>）</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="type">int</span> = <span class="number">20</span></span><br><span class="line">    <span class="keyword">var</span> ip *<span class="type">int</span></span><br><span class="line">    </span><br><span class="line">    ip = &amp;a</span><br><span class="line">    </span><br><span class="line">    fmt.Printf(<span class="string">&quot;a 变量的地址是：%x\n&quot;</span>, &amp;a)</span><br><span class="line">    </span><br><span class="line">    fmt.Printf(<span class="string">&quot;ip 变量储存的指针地址：%x\n&quot;</span>, ip)</span><br><span class="line">    </span><br><span class="line">    fmt.Printf(<span class="string">&quot;*ip 变量的值：%d\n&quot;</span>, *ip)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特殊指针"><a href="#特殊指针" class="headerlink" title="特殊指针"></a>特殊指针</h3><h4 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h4><p>当一个指针被定义后没有分配到任何变量时，它的值为 <code>nil</code>，也被称为空指针</p><h4 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h4><p><code>var ptr [Max]*int</code> 声明一个存储指针的数组后逐个给其赋值地址</p><p><code>ptr[i] = &amp;a[i]</code></p><h4 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h4><p><code>var ptr **int</code> 即已有一个指针，在获取其地址赋值给一个指针</p><h4 id="指针作为函数参数"><a href="#指针作为函数参数" class="headerlink" title="指针作为函数参数"></a>指针作为函数参数</h4><p>在函数定义时 <code>func swap(x *int, y *int) &#123;&#125;</code></p><p>在函数调用时 <code>swap(&amp;a, &amp;b)</code> （回想<strong>赋值格式</strong>即可）</p><h2 id="Go-语言结构体-Struct"><a href="#Go-语言结构体-Struct" class="headerlink" title="Go 语言结构体 Struct"></a>Go 语言结构体 Struct</h2><p>结构体是由一系列具有相同类型或不同类型的数据构成的数据集合</p><p>可同一般变量一样作为函数参数和指针（且仍用 <code>.</code> 访问成员）</p><h3 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> struct_variable_type <span class="keyword">struct</span> &#123;</span><br><span class="line">    member definition</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">variable_name := struct_variable_type &#123;value1, value2, ...&#125;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">variable_name := struct_variable_type &#123;key1: value1, key2: value2, ...&#125;</span><br></pre></td></tr></table></figure><h3 id="访问结构体成员"><a href="#访问结构体成员" class="headerlink" title="访问结构体成员"></a>访问结构体成员</h3><p><code>结构体.成员名</code> 可用于获取和赋值</p><h2 id="Go-语言切片-（Slice）"><a href="#Go-语言切片-（Slice）" class="headerlink" title="Go 语言切片 （Slice）"></a>Go 语言<a href="https://blog.go-zh.org/go-slices-usage-and-internals">切片</a> （Slice）</h2><p>切片是对数组的抽象，是一种“动态数组”，可追加元素</p><p>切片的零值是 <code>nil</code> ； <code>nil</code> 切片的长度和容量为 0 且没有底层数组</p><p>对切片的修改会作用到实际数组上</p><p><code>var identifier []type</code> 未指定大小的数组即为一个切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 []<span class="keyword">type</span> = <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br><span class="line"><span class="comment">// 也可以简写为</span></span><br><span class="line">slice1 := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br></pre></td></tr></table></figure><p>此处的 <code>make([]T, length, capacity)</code> 中 <strong>capacity</strong> 为可选参数 - 容量（最大长度）</p><p>具体切片操作同 <code>python</code> （貌似没有步长）</p><p>使用自带函数 <code>len()</code> 和 <code>cap()</code> 可获取长度和容量</p><p>切片在未初始化之前默认为 nil，长度为 0</p><p><code>copy(toSlice, fromSlice)</code> 进行切片内容拷贝；</p><p><code>Slice&lt;T&gt; = append(Slice&lt;T&gt;, Ts...)</code> 进行元素追加（不增加容量）</p><p><code>Slice&lt;T&gt; = AppendByte(Slice&lt;T&gt;, Ts...)</code> 自动扩容的追加（原长加上追加长后 * 2）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := []<span class="type">string</span>&#123;<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Paul&quot;</span>&#125;</span><br><span class="line">b := []<span class="type">string</span>&#123;<span class="string">&quot;George&quot;</span>, <span class="string">&quot;Ringo&quot;</span>, <span class="string">&quot;Pete&quot;</span>&#125;</span><br><span class="line">a = <span class="built_in">append</span>(a, b...) <span class="comment">// equivalent to &quot;append(a, b[0], b[1], b[2])&quot;</span></span><br><span class="line"><span class="comment">// 两个切片 append 时要扩展为 ...</span></span><br></pre></td></tr></table></figure><h2 id="Go-语言范围（Range）"><a href="#Go-语言范围（Range）" class="headerlink" title="Go 语言范围（Range）"></a>Go 语言范围（Range）</h2><p>range 关键字用于 for 循环中迭代数组（array）、切片、通道（channel）或集合（map）的元素，无需括号</p><p>在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key 对</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//这是我们使用range去求一个slice的和。使用数组跟这个很类似</span></span><br><span class="line">    nums := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        sum += num</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;sum:&quot;</span>, sum)</span><br><span class="line">    <span class="comment">//在数组上使用range将传入index和值两个变量。上面那个例子我们不需要使用该元素的序号，所以我们使用空白符&quot;_&quot;省略了。有时侯我们确实需要知道它的索引。</span></span><br><span class="line">    <span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">3</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;index:&quot;</span>, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//range也可以用在map的键值对上。</span></span><br><span class="line">    kvs := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;b&quot;</span>: <span class="string">&quot;banana&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> kvs &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s -&gt; %s\n&quot;</span>, k, v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//range也可以用来枚举Unicode字符串。第一个参数是字符的索引，第二个是字符（Unicode的值）本身。</span></span><br><span class="line">    <span class="keyword">for</span> i, c := <span class="keyword">range</span> <span class="string">&quot;go&quot;</span> &#123;</span><br><span class="line">        fmt.Println(i, c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Go-语言-Map-（集合）"><a href="#Go-语言-Map-（集合）" class="headerlink" title="Go 语言 Map （集合）"></a>Go 语言 Map （集合）</h2><p>Map 是一种无序的键值对集合，通过 key 来快速检索数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 声明变量，默认 map 是 nil ，此时不能直接进行插入修改，故一般用 make 函数初始化 */</span></span><br><span class="line"><span class="keyword">var</span> map_variable <span class="keyword">map</span>[key_data_type]value_data_type</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 make 函数 */</span></span><br><span class="line">map_variable := <span class="built_in">make</span>(<span class="keyword">map</span>[key_data_type]value_data_type)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过双赋值检测某个键是否存在 */</span></span><br><span class="line">elem, ok := m[key]</span><br><span class="line"><span class="comment">// 若存在则 ok 为 true</span></span><br></pre></td></tr></table></figure><p>如果不初始化 map，则会创建一个 nil map，其不能用来存放键值对；<strong>所以一定要 make 或者指向已存在的</strong></p><p><code>delete(mapVar, mapKey)</code> 用于删除指定 Map 的指定 Key</p><h2 id="Go-语言类型转换"><a href="#Go-语言类型转换" class="headerlink" title="Go 语言类型转换"></a>Go 语言类型转换</h2><p>用于将一种数据类型的变量转换为另外一种类型的变量</p><p><code>type_name(expression)</code></p><h2 id="Go-语言接口"><a href="#Go-语言接口" class="headerlink" title="Go 语言接口"></a>Go 语言接口</h2><p>是一种数据类型，把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">interface</span> &#123;</span><br><span class="line">    call()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> NokiaPhone <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nokiaPhone NokiaPhone)</span></span> call() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;I am Nokia, I can call you!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> IPhone <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(iPhone IPhone)</span></span> call() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;I am iPhone, I can call you!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> phone Phone</span><br><span class="line"></span><br><span class="line">    phone = <span class="built_in">new</span>(NokiaPhone)</span><br><span class="line">    phone.call()</span><br><span class="line"></span><br><span class="line">    phone = <span class="built_in">new</span>(IPhone)</span><br><span class="line">    phone.call()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Go-错误处理"><a href="#Go-错误处理" class="headerlink" title="Go 错误处理"></a>Go 错误处理</h2><p>通过 error 类型接口提供，其定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(f <span class="type">float64</span>)</span></span> (<span class="type">float64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;math: square root of negative number&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 <code>errors.New(str)</code> 返回一个错误信息</p><h2 id="Go-并发"><a href="#Go-并发" class="headerlink" title="Go 并发"></a>Go 并发</h2><p>只需要通过关键字来启动 goroutine 即可支持并发</p><p>goroutine 是轻量级线程，goroutine 的调度是由 Golang 运行时进行管理的</p><p><code>go 函数名（参数列表）</code> </p><p>以一个不同的、新创建的 goroutine 来执行一个函数</p><p>同一个程序中的所有 goroutine 共享同一个地址空间</p><h3 id="通道（channel）"><a href="#通道（channel）" class="headerlink" title="通道（channel）"></a>通道（channel）</h3><p>是用来传递数据的一个数据结构，可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯</p><p>操作符 <code>&lt;-</code> 用于指定通道的方向，发送或接收。若未指定方向则为双向通道</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>) <span class="comment">// 声明</span></span><br><span class="line"> </span><br><span class="line">ch &lt;- v    <span class="comment">// 把 v 发送到通道 ch</span></span><br><span class="line">v := &lt;-ch  <span class="comment">// 从 ch 接收数据</span></span><br><span class="line">           <span class="comment">// 并把值赋给 v</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(s []<span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        sum := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">                sum += v</span><br><span class="line">        &#125;</span><br><span class="line">        c &lt;- sum <span class="comment">// 把 sum 发送到通道 c</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        s := []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">        c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">        <span class="keyword">go</span> sum(s[:<span class="built_in">len</span>(s)/<span class="number">2</span>], c)</span><br><span class="line">        <span class="keyword">go</span> sum(s[<span class="built_in">len</span>(s)/<span class="number">2</span>:], c)</span><br><span class="line">        x, y := &lt;-c, &lt;-c <span class="comment">// 从通道 c 中接收</span></span><br><span class="line"></span><br><span class="line">        fmt.Println(x, y, x+y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通道缓冲区"><a href="#通道缓冲区" class="headerlink" title="通道缓冲区"></a>通道缓冲区</h4><p>默认没有缓冲区，可通过 <code>make</code> 的第二个参数指定缓冲区大小</p><p><code>ch := make(chan int, 100)</code></p><p>带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。</p><p>不过由于缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，否则缓冲区一满，数据发送端就无法再发送数据了。</p><p><strong>注意</strong>：如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。</p><h4 id="通道遍历与关闭通道"><a href="#通道遍历与关闭通道" class="headerlink" title="通道遍历与关闭通道"></a>通道遍历与关闭通道</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="type">int</span>, c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">                c &lt;- x</span><br><span class="line">                x, y = y, x+y</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line">        <span class="comment">// range 函数遍历每个从通道接收到的数据，因为 c 在发送完 10 个</span></span><br><span class="line">        <span class="comment">// 数据之后就关闭了通道，所以这里我们 range 函数在接收到 10 个数据</span></span><br><span class="line">        <span class="comment">// 之后就结束了。如果上面的 c 通道不关闭，那么 range 函数就不</span></span><br><span class="line">        <span class="comment">// 会结束，从而在接收第 11 个数据的时候就阻塞了。</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">                fmt.Println(i)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;yosoro&quot;&gt;&lt;a href=&quot;#yosoro&quot; class=&quot;headerlink&quot; title=&quot;yosoro~&quot;&gt;&lt;/a&gt;yosoro~&lt;/h1&gt;&lt;p&gt;编写一个简单的&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;</summary>
      
    
    
    
    <category term="Golang" scheme="http://remedios14.github.io/categories/Golang/"/>
    
    
    <category term="QuickStart" scheme="http://remedios14.github.io/tags/QuickStart/"/>
    
    <category term="菜鸟教程" scheme="http://remedios14.github.io/tags/%E8%8F%9C%E9%B8%9F%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Shader入门精要-常用编写</title>
    <link href="http://remedios14.github.io/2022/07/14/Games/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81-%E5%B8%B8%E7%94%A8%E7%BC%96%E5%86%99/"/>
    <id>http://remedios14.github.io/2022/07/14/Games/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81-%E5%B8%B8%E7%94%A8%E7%BC%96%E5%86%99/</id>
    <published>2022-07-14T15:19:10.000Z</published>
    <updated>2022-07-14T15:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Shader-常用编写"><a href="#Shader-常用编写" class="headerlink" title="Shader 常用编写"></a>Shader 常用编写</h2><h3 id="标准光照模型"><a href="#标准光照模型" class="headerlink" title="标准光照模型"></a>标准光照模型</h3><p><strong>逐像素光照</strong> 和 <strong>逐顶点光照</strong>；通常逐像素的效果略佳</p><ul><li>环境光部分 <code>fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;</code></li></ul><h4 id="Lambert-反射"><a href="#Lambert-反射" class="headerlink" title="Lambert 反射"></a>Lambert 反射</h4><p>考虑环境光和漫反射的着色模型，环境光视作常量，漫反射的光源视作平行光，反射光量由入射角度和法向的余弦值确定，即<strong>两个单位向量点积</strong></p><p>将计算过程置于 vertex 部分或 fragment 部分就是顶点着色和像素着色的区别，不过需要的信息都是一样的；对顶点较少的简单模型通常其像素着色效果更佳，而复杂模型则差不多</p><ul><li>Half Lambert 模型 ：初始的 Lambert 模型对负的余弦值直接取 0 做成纯黑，实际视觉效果不好；该方法即将 [-1,1] 的余弦值缩放平移到 [0,1] 来对负的值也进行着色</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);</span><br><span class="line">...</span><br><span class="line">fixed3 worldNormal = normalize(i.worldNormal);</span><br><span class="line">fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line">fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLightDir));</span><br></pre></td></tr></table></figure><h4 id="Specular-反射"><a href="#Specular-反射" class="headerlink" title="Specular 反射"></a>Specular 反射</h4><p>镜面反射，能计算出高光的出射角，当视线方向在出射角附近时能观察到高光，此附近判断通过计算角度代入一个<strong>指数函数的基</strong>得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);</span><br><span class="line">o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz; // 模型世界坐标</span><br><span class="line">...</span><br><span class="line">fixed3 reflectDir = normalize(reflect(-worldLightDir, worldNormal));</span><br><span class="line">fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);</span><br><span class="line">fixed3 specular = _LightColor0.rbg * _Specular.rgb * pow(saturate(dot(reflectDir, viewDir)), _Gloss);</span><br></pre></td></tr></table></figure><h4 id="Blinn-Phong-光照模型"><a href="#Blinn-Phong-光照模型" class="headerlink" title="Blinn-Phong 光照模型"></a>Blinn-Phong 光照模型</h4><p>简化反射角度的计算，使用光照和视线向量的和 v_sum，若视线接近出射角度则 v_sum 和法线比较接近，因此可以使用 v_sum 点积 normal 来代入上面的指数基</p><p><strong>感觉高光范围更大一点</strong></p><h3 id="纹理映射"><a href="#纹理映射" class="headerlink" title="纹理映射"></a>纹理映射</h3><p>一个模型的顶点通常都会定义 纹理坐标 texcoord 属性，描述该模型的平面展开图到一个 [0,1]^2 范围的映射，而在应用纹理时即通过这个值得到纹理细节分布；纹理 ST 通常为 (1,1,0,0) 表示无缩放无偏移</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_MainTex (&quot;Main tex&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">...</span><br><span class="line">sampler2D _MainTex;</span><br><span class="line">float4 _MainTex_ST;</span><br><span class="line">...</span><br><span class="line">o.uv = v.texcoord.xy * _MainTex_ST.xy * _MainTex_ST.zw;</span><br><span class="line">...</span><br><span class="line">fixed3 albedo = tex2D(_MainTex, i.uv).rgb * _Color.rgb;</span><br><span class="line">fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz * albedo;</span><br><span class="line">fixed3 diffuse = _LightColor0.rgb * albedo * max(0, dot(worldNormal, worldLightDir));</span><br><span class="line">fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss);</span><br></pre></td></tr></table></figure><p>环境光和漫反射部分受材质影响，但镜反射高光与材质颜色无关，为什么呢？</p><h4 id="凹凸纹理"><a href="#凹凸纹理" class="headerlink" title="凹凸纹理"></a>凹凸纹理</h4><p>o.uv 前两个值存 <code>_MainTex</code> 的纹理坐标，后两个存 <code>_BumpMap</code> 的（实际上通常使用同一组纹理坐标）；后续同样要 <code>tex2D(_BumpMap, i.uv.zw)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">_BumpMap (&quot;Normal Map&quot;, 2D) = &quot;bump&quot; &#123;&#125;</span><br><span class="line">_BumpScale (&quot;Bump Scale&quot;, Float) = 1.0</span><br><span class="line">...</span><br><span class="line">sampler2D _BumpMap;</span><br><span class="line">float4 _BumpMap_ST;</span><br><span class="line">float _BumpScale;</span><br><span class="line">...</span><br><span class="line">float4 tangent : TANGENT;</span><br><span class="line">...</span><br><span class="line">o.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</span><br><span class="line">o.uv.zw = v.texcoord.xy * _BumpMap_ST.xy + _BumpMap_ST.zw;</span><br><span class="line">// 计算副法线并建立模型空间到法线空间的变换（就是三个方向轴组合矩阵）</span><br><span class="line">float3 binormal = cross(normalize(v.normal), normalize(v.tangent.xyz)) * v.tangent.w;</span><br><span class="line">float3x3 rotation = float3x3(v.tangent.xyz, binormal, v.normal);</span><br><span class="line">o.lightDir = mul(rotation, ObjSpaceLightDir(v.vertex)).xyz;</span><br><span class="line">o.viewDir = mul(rotation, ObjeSpaceViewDir(v.vertex)).xyz;</span><br><span class="line">...</span><br><span class="line">// 切线空间的两个 dir 要先 normalize，这里略</span><br><span class="line">fixed4 packedNormal = tex2D(_BumpMap, i.uv.zw);</span><br><span class="line">fixed3 tangentNormal;</span><br><span class="line">tangentNormal.xy = (packedNormal.xy * 2 - 1) * _BumpScale;</span><br><span class="line">tangentNormal.z = sqrt(1.0 - saturate(dot(tangentNormal.xy, tangentNormal.xy)));</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="渐变纹理"><a href="#渐变纹理" class="headerlink" title="渐变纹理"></a>渐变纹理</h4><p>下面实现了渐变的漫反射颜色</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fixed halfLambert = 0.5 * dot(worldNormal, worldLightDir) + 0.5;</span><br><span class="line">fixed3 diffuseColor = tex2D(_RampTex, fixed2(halfLambert, halfLambert)).rgb * _Color.rgb;</span><br><span class="line">fixed3 diffuse = _LightColor0.rgb * diffuseColor;</span><br></pre></td></tr></table></figure><h4 id="遮罩纹理"><a href="#遮罩纹理" class="headerlink" title="遮罩纹理"></a>遮罩纹理</h4><p>实际使用中通常可以充分利用 mask_tex 的每个通道</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fixed specularMask = tex2D(_SpecularMask, i.uv).r * _SpecularScale;</span><br><span class="line">fixed3 specular = ... * specularMask;</span><br></pre></td></tr></table></figure><h3 id="透明效果"><a href="#透明效果" class="headerlink" title="透明效果"></a>透明效果</h3><p>必要声明</p><ul><li>透明度测试效果<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SubShader &#123;</span><br><span class="line">Tags &#123; &quot;Queue&quot;=&quot;AlphaTest&quot; &#125;</span><br><span class="line">Pass &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>透明度混合效果（ZWrite Off 也可以写在 SubShader 中）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SubShader &#123;</span><br><span class="line">Tags &#123; &quot;Queue&quot;=&quot;Transparent&quot; &#125;</span><br><span class="line">Pass &#123; </span><br><span class="line">ZWrite Off </span><br><span class="line">... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Alpha-Test"><a href="#Alpha-Test" class="headerlink" title="Alpha Test"></a>Alpha Test</h4><p>使用 CG 语言中的 clip，其可传入标量或向量，只要任一分量小于 0 就舍弃该片元；其他实现没啥差别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">clip(texColor.a - _Cutoff);</span><br><span class="line">// Equal to</span><br><span class="line">// if ((texColor.a - _Cutoff) &lt; 0.0) &#123;</span><br><span class="line">//     discard;</span><br><span class="line">// &#125;</span><br><span class="line">...</span><br><span class="line">Fallback &quot;Transparent/Cutout/VertexLit&quot;</span><br></pre></td></tr></table></figure><h4 id="Alpha-Blend"><a href="#Alpha-Blend" class="headerlink" title="Alpha Blend"></a>Alpha Blend</h4><p>Tags {“Queue”=”Transparent” “IgnoreProjector”=”True” “RenderType”=”Transparent”}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Pass &#123;</span><br><span class="line">Zwrite Off</span><br><span class="line">Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">...</span><br><span class="line">return fixed4(ambient+diffuse, texColor.a * _AlphaScale);</span><br><span class="line">...</span><br><span class="line">Fallback &quot;Transparent/VertexLit&quot;</span><br></pre></td></tr></table></figure><p>不需要 cutoff 部分，只要在 Pass 内声明，并在片元着色器中给透明度赋值即可由内部完成</p><h4 id="开启深度写入的-Alpha-Blending"><a href="#开启深度写入的-Alpha-Blending" class="headerlink" title="开启深度写入的 Alpha Blending"></a>开启深度写入的 Alpha Blending</h4><p>使用两个 Pass，在第一个 Pass 内仅声明 <code>ZWrite On</code> 和 <code>ColorMask 0</code> 来写入深度并且不输出颜色，第二个 Pass 和通常的 Alpha Blending 一致</p><ul><li>ColorMask 后接 RGBA 的任意组合或 0，设置颜色通道的写掩码(write mask)</li></ul><h4 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h4><p>感觉可以另起一篇，回去看第八章最后再写吧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Shader-常用编写&quot;&gt;&lt;a href=&quot;#Shader-常用编写&quot; class=&quot;headerlink&quot; title=&quot;Shader 常用编写&quot;&gt;&lt;/a&gt;Shader 常用编写&lt;/h2&gt;&lt;h3 id=&quot;标准光照模型&quot;&gt;&lt;a href=&quot;#标准光照模型&quot; cla</summary>
      
    
    
    
    <category term="Games-Graphics" scheme="http://remedios14.github.io/categories/Games-Graphics/"/>
    
    
    <category term="图形学应用" scheme="http://remedios14.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%BA%94%E7%94%A8/"/>
    
    <category term="着色器" scheme="http://remedios14.github.io/tags/%E7%9D%80%E8%89%B2%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Shader入门精要-概述</title>
    <link href="http://remedios14.github.io/2022/07/14/Games/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81-%E6%A6%82%E8%BF%B0/"/>
    <id>http://remedios14.github.io/2022/07/14/Games/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81-%E6%A6%82%E8%BF%B0/</id>
    <published>2022-07-14T15:16:45.000Z</published>
    <updated>2022-07-14T15:16:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介-HLSL-语法"><a href="#简介-HLSL-语法" class="headerlink" title="简介 HLSL 语法"></a>简介 HLSL 语法</h2><ul><li>数据类型：bool、int、float、double；half 表示 16位浮点数；fixed 通常使用 11 位，精度范围 -2.0~+2.0</li><li>向量 ：TypeN(2 &lt;= N &lt;= 4) 例如 float3<ul><li>初始化 ：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float2 fvec = float2(0.1f, 0.2f);</span><br><span class="line">float2 fvec1 = &#123;0.3f, 0.4f&#125;;</span><br><span class="line">float4 fvec4 = &#123;fvec, fvec2&#125;;</span><br></pre></td></tr></table></figure></li><li>访问 ：vec[i]; 或者字母语法 xyzw 或 rgba，可以同时用，例如 vec.xy 得到一个二维向量；甚至可以 vec.xxyy 得到四维</li></ul></li><li>矩阵 ：TypeAxB<ul><li>初始化 ：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float2x2 fmat = float2x2(1.0f, 2.0f, 3.0f, 4.0f);</span><br><span class="line">int2x2 imat = &#123;1, 2, 3, 4&#125;;</span><br></pre></td></tr></table></figure></li><li>访问 ：mat[i][j]; 或 mat._12; 或 mat._m12; 其中</li></ul></li><li>数组 ：例如 float arr[i][j]; 以及 int3 vecarr[3]</li><li>结构体 ：struct … 仅允许变量成员，直接下标访问</li><li>内置函数 ：<a href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-intrinsic-functions">官方文档</a></li><li>流程控制 ：基本和 C/C++ 一致，多一条 <code>discard</code> 放弃该像素输出</li><li>语义 ：描述着色器在渲染管线上的标准输入输出内容，通过语义变量传递；<a href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-semantics">官方文档</a></li></ul><h2 id="着色器-Shader"><a href="#着色器-Shader" class="headerlink" title="着色器 Shader"></a>着色器 Shader</h2><p>一般的着色流程是 ：顶点数据-&gt;顶点着色器-&gt;曲面细分着色器-&gt;几何着色器-&gt;裁剪（剔除视野外顶点转为可见点）-&gt;屏幕映射-&gt;三角形设置-&gt;三角形遍历-&gt;片元着色器-&gt;逐片元操作-&gt;屏幕图像</p><ul><li>顶点着色器 Vertex Shader ：主要执行顶点的坐标系变换来模拟不同的材质效果；一个毫无变化的变换即左乘 MVP 变换矩阵进行透视投影</li><li>裁剪 ：经过变换后部分顶点在标准 Cube 之外，也即当前 FOV 的视野外，通过裁剪将外部顶点剔除，或者转为 Cube 上的可见顶点</li><li>屏幕映射 ：直观地从 [-1.1] 映射到屏幕，DirectX 以左上角为 (0,0) 而 OpenGL 以左下角</li><li>片元着色器 Fragment Shader ：将三角形的覆盖关系综合（类似深度缓存等）得到片元的综合信息；纹理采样也在这一步完成</li></ul><p>模型空间 model space 指的是以模型自身定义轴朝向的空间<br>裁剪空间 clip space 指的是以远近平面执行透视投影的视锥范围</p><h3 id="Unity-Shader"><a href="#Unity-Shader" class="headerlink" title="Unity Shader"></a>Unity Shader</h3><p>集成了 Shader 的必要编写和其他渲染的设置开关</p><ul><li>最外部是 ShaderLab 语义块，定义了该 Shader 的名称和目录层级<ol><li>Proderties 语义块内可以定义一些通用属性，会在编辑器内可见<ul><li>格式写为<code>变量名(“说明”,类型)=(默认值)</code></li></ul></li><li>SubShader 语义块用于针对不同的系统定义不同的 Shader<ul><li>Pass 语义块，（必须）其内定义顶点、片元着色器，需要用 <code>CGPROGRAM</code> 和 <code>ENDCG</code> 在首尾行包围；一些特效可使用多个 pass 语句块；（可选）定义一些 Tags 例如光照模式</li></ul></li><li>FallBack 没有适配的 SubShader 时调用这个</li></ol></li></ul><p>一个普通的贴图着色器；其中需要在 Pass 内引入 Properties 定义的属性到变量，函数后接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Shader &quot;Unlit/NewUnlitShader&quot;</span><br><span class="line">&#123;</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        _Color(&quot;Total Rad Color!&quot;,Color) = (1,1,1,1)</span><br><span class="line">        _MainTexture(&quot;Main Texture&quot;,2D) = &quot;white&quot;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">        SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        Pass</span><br><span class="line">        &#123;</span><br><span class="line">Tags &#123; &quot;LightMode&quot;=&quot;ForwardBase&quot; &#125;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vertexFunction</span><br><span class="line">            #pragma fragment fragmentFunction</span><br><span class="line"></span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line"></span><br><span class="line">            float4 _Color;</span><br><span class="line">            sampler2D _MainTexture;</span><br><span class="line"></span><br><span class="line">            struct a2v &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0; // 0 表示第一组，后续编号</span><br><span class="line">float3 norm : NORMAL; // 法线</span><br><span class="line">float4 teng : TANGENT; // 切线</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f &#123;</span><br><span class="line">                float4 position:SV_POSITION;</span><br><span class="line">                float2 uv:TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            v2f vertexFunction(a2v v) &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">// 相当于左乘 MVP 变换矩阵</span><br><span class="line">                o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = v.uv;</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 fragmentFunction(v2f i) :SV_Target &#123;</span><br><span class="line">                return tex2D(_MainTexture,i.uv);</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基本语义"><a href="#基本语义" class="headerlink" title="基本语义"></a>基本语义</h4><ul><li>传入顶点着色器<ul><li>POSITION ：模型空间顶点位置，通常为 float4，要转为世界空间</li><li>NORMAL ：顶点法线，通常是 float3</li><li>TANGENT ：顶点切线，通常是 float4，因为有两个垂直的方向</li><li>TEXCOORDn ：顶点的纹理坐标，n 描述第几组，通常 float2 或 float4；前两个分量为 uv，后两个分量表示偏移量</li><li>COLOR ：顶点颜色，通常 fixed4 或 float4</li></ul></li><li>传入片元着色器<ul><li>SV_POSITION ：裁剪空间中的顶点坐标，传入的结构体中必须包含一个用该语义修饰的变量；float4</li><li>COLORn ：通常用于输出几组顶点颜色，但非必须</li><li>TEXCOORDn ：通常用于输出纹理坐标，但非必须</li></ul></li><li>片元着色器输出<ul><li>SV_Target ：输出值将存储到渲染目标中；fixed4</li></ul></li></ul><h4 id="八股"><a href="#八股" class="headerlink" title="八股"></a>八股</h4><ul><li>顶点着色器任务<ul><li>把顶点位置从模型空间转换到裁剪空间，即对 POSITION 的变量施加 MVP 变换传给 SV_POSITION；<code>UnityObjectToClipPos(v.vert)</code></li><li>（片元光照需要）把法向从模型空间转换到世界空间，因为 unity 存了 World2Object，所以反过来乘；<code>wNorm = mul(v.norm, (float3x3)unity_WorldToObject);</code>；当然用 unity_ObjectToWorld 也行</li></ul></li><li>片元着色器任务</li></ul><h2 id="一些常见-Shader-的原理"><a href="#一些常见-Shader-的原理" class="headerlink" title="一些常见 Shader 的原理"></a>一些常见 Shader 的原理</h2><h3 id="标准光照模型"><a href="#标准光照模型" class="headerlink" title="标准光照模型"></a>标准光照模型</h3><ul><li>自发光（emissive）部分：由材质直接决定，但此处不视作光源</li><li>高光反射（specular）部分：在镜面反射的出射方向周围能看到高光<ul><li>使用实际观察视角对比反射方向；或者半角向量对比法向</li><li>Gloss 参数反映高光的范围</li></ul></li><li>漫反射（diffuse）部分：遵从 Lambert 定律，均匀到所有出射方向</li><li>环境光（ambient）部分：此模型下假设为一个常量，实际应当考虑光线多次反射，即全局光照</li></ul><hr><p>一些常用变量，来自 Lighting.cginc</p><ul><li><code>UNITY_LIGHTMODEL_AMBIENT.xyz</code> 四维环境光向量</li><li><code>_WorldSpaceLightPos0.xyz</code> 世界坐标中光源的位置或方向向量；若 w 为 0 表示平行光（描述方向）；为 1 表示点光源或聚光灯（从而描述位置）</li><li><code>_LightColor0.rgb</code> 光照也有颜色，不过通常认为都是白光</li><li><code>_WorldSpaceCameraPos.xyz</code> 世界坐标中相机位置</li></ul><hr><p>一些常用函数</p><ul><li>pow(x, y) 计算以 x 为底 y 为指数的值</li><li>saturate(x) 相当于 max(0, x)</li></ul><h3 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h3><p>在 Shader.Properties 中提供 <code>_MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125;</code> 可以赋予纹理贴图，然后在 HLSL 代码片段中声明 <code>sampler2D _MainTex; float4 _MainTex_ST;</code> 其中后者要与前者变量名对应，并以 <code>_ST</code> （Scale、Translation）结尾，该四维向量描述了 xy 缩放值和 zw 偏移值；</p><p>因此实际的纹理 uv 要用 <code>o.uv = texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;</code> 然后再到纹理上采样 <code>tex2D(_MainTex, i.uv).rgb</code></p><h4 id="纹理类型"><a href="#纹理类型" class="headerlink" title="纹理类型"></a>纹理类型</h4><ul><li>Texture ：<ul><li>Alpha from Grayscale ：使用像素灰度值生成透明度通道</li><li>Wrap Mode ：平铺模式，有 Repeat 和 Clamp(截取)</li><li>Filter Mode ：拉伸时的滤波模式；其中 Trilinear 需要纹理使用 mipmap 才由于 Bilinear</li></ul></li><li>Normal map ：</li><li>Cubemap ：</li></ul><h4 id="法线纹理"><a href="#法线纹理" class="headerlink" title="法线纹理"></a>法线纹理</h4><ul><li>法线纹理 ：在每个顶点的切线空间中描述法线，则法线为 z 轴正向的单位向量；存储了法线经过映射后得到的像素值，将原本的 [-1,1] 区间映射到 [0,1] 区间，因此在从 BumpMap 采样后要反映射；<strong>虽然没太懂，反正用切线空间做法线贴图就对了，TA的工作</strong></li><li>高度纹理 ：存储强度值（intensity）描述局部海拔高度，模拟表面的顶点位移</li></ul><p>需要 <code>_BumpMap (&quot;Normal Map&quot;, 2D) = &quot;bump&quot; &#123;&#125;</code> 和 <code>_BumpScale (&quot;Bump Scale&quot;, Float) = 1.0</code> 引入</p><p>声明时 <code>sampler2D _BumpMap; float4 _BumpMap_ST;</code></p><h4 id="渐变纹理"><a href="#渐变纹理" class="headerlink" title="渐变纹理"></a>渐变纹理</h4><p>使用简单的 [0,1] 区间的渐变色映射达成非真实渲染效果，可以用于漫反射等部分</p><p>同样使用 <code>_RampTex</code> 引入，并声明 <code>sampler2D _RampTex; float4 _RampTex_ST;</code> （虽然好像没用到 ST）</p><h4 id="遮罩纹理"><a href="#遮罩纹理" class="headerlink" title="遮罩纹理"></a>遮罩纹理</h4><p>mask texture，通常用于保护某些区域不被修改，例如采样纹素后用某个通道的值乘上某个表面属性，控制纹素值为 0 即避免被修改变化；</p><p>同样引入 2D 的 Texture 不过也无需声明 ST（<strong>因为大多数时候无需缩放偏移，或者都使用同一套缩放偏移</strong>）</p><h3 id="透明效果"><a href="#透明效果" class="headerlink" title="透明效果"></a>透明效果</h3><p>透明通道，为 0 表示全透明，在 Unity 中通过<strong>透明度测试</strong>或者<strong>透明度混合</strong>实现；深度缓存足够解决非透明（opaque）物体的渲染</p><ul><li>Alpha Test：暴力二值化，透明度小于阈值就不光栅化，大于就视作不透明</li><li>Alpha Blending：使用透明度做片元的混合因子；需要关闭深度写入，但不关闭深度测试<ul><li>即构建一个只读的 depth buffer，尽可能把最近的不透明物写入深度</li></ul></li></ul><ol><li>先渲染所有不透明物体，并开启深度测试和深度写入</li><li>从远到近排序半透明物体，并此顺序渲染；开启深度测试但关闭深度写入<ul><li>然而物体还是可能循环遮罩，因此可能需要分割网格</li></ul></li></ol><h4 id="Unity-的解决方法"><a href="#Unity-的解决方法" class="headerlink" title="Unity 的解决方法"></a>Unity 的解决方法</h4><p>提供了 render queue，队列索引号越小越先进行渲染</p><div class="table-container"><table><thead><tr><th>名称</th><th>队列索引号</th><th>描述</th></tr></thead><tbody><tr><td>Background</td><td>1000</td><td>在任何其他队列之前，用于渲染背景上的物体</td></tr><tr><td>Geometry</td><td>2000</td><td>默认队列，大多数物体、不透明物体</td></tr><tr><td>AlphaTest</td><td>2450</td><td>需要透明度测试的物体使用</td></tr><tr><td>Transparent</td><td>3000</td><td>任何使用了 alpha blending 的物体都应该使用</td></tr><tr><td>Overlay</td><td>4000</td><td>用于实现叠加效果，最上层（UI等）</td></tr></tbody></table></div><p>透明度测试的额外工作比较少；而透明度混合需要使用 Unity 提供的混合命令</p><ul><li>Blend Off : 关闭混合</li><li>Blend SrcFactor DstFactor : 开启并设置混合因子，该片元颜色乘以 Src，缓存颜色乘以 Dst 相加后存入颜色缓存</li><li>Blend SrcFactor DstFactor, SrcFactorA DstFactorA : 针对 rgb 和 A 通道使用不同的混合因子</li><li>BlendOp BlendOperation : 非简单相加，而是指定其他 Operation</li></ul><p>开启混合模式(第二项)默认以 SrcAlpha 和 1 - SrcAlpha 为因子；当然可以自行指定</p><h3 id="特效类模型"><a href="#特效类模型" class="headerlink" title="特效类模型"></a>特效类模型</h3><p>操作上即使仅仅用把法向转为颜色来输出都能看到效果，因此 Shader 其实是个看重想法的工具</p><ol><li>锈蚀效果 ：另增添一个 tex2，采样点若在 tex2 上超过某个阈值则更改他（实际上也不是必要 tex2）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介-HLSL-语法&quot;&gt;&lt;a href=&quot;#简介-HLSL-语法&quot; class=&quot;headerlink&quot; title=&quot;简介 HLSL 语法&quot;&gt;&lt;/a&gt;简介 HLSL 语法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;数据类型：bool、int、float、double；half </summary>
      
    
    
    
    <category term="Games-Graphics" scheme="http://remedios14.github.io/categories/Games-Graphics/"/>
    
    
    <category term="图形学应用" scheme="http://remedios14.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%BA%94%E7%94%A8/"/>
    
    <category term="着色器" scheme="http://remedios14.github.io/tags/%E7%9D%80%E8%89%B2%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Games202-实时全局光照</title>
    <link href="http://remedios14.github.io/2022/07/02/Games/202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/Games202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/"/>
    <id>http://remedios14.github.io/2022/07/02/Games/202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/Games202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/</id>
    <published>2022-07-02T05:29:52.000Z</published>
    <updated>2022-07-02T05:42:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Real-Time-Global-Illumination"><a href="#Real-Time-Global-Illumination" class="headerlink" title="Real-Time Global Illumination"></a>Real-Time Global Illumination</h2><p>全局光照即描述光线多次反射照亮物体的效果，递进式地先考虑间接光照</p><h3 id="Reflective-Shadow-Maps-（RSM）"><a href="#Reflective-Shadow-Maps-（RSM）" class="headerlink" title="Reflective Shadow Maps （RSM）"></a>Reflective Shadow Maps （RSM）</h3><p>要计算间接光照首先要得到直接光照点，即光源首次照射到的物体，回顾 Shadow Map 显然就是需要的方法，光线穿过足量的网格落在场景点上</p><p>此时需要假设在每个直接光照点处，光线都发生漫反射，向所有方向均匀地反射光线</p><p><img src="/images/CG/Reflective-Shadow-Maps.png" alt="从面光源 q 向 p 点"></p><p>在考虑间接光照的时候已经顾不上去计算间接光的 visibility</p><h4 id="提速"><a href="#提速" class="headerlink" title="提速"></a>提速</h4><p>为了提升效率达到实时，使用了非常大胆的 trick ：只有足够近的点作为次级光源会照亮着色点</p><p>对于 RSM 上记录的着色点 p，需要同时记录其 深度、世界坐标、法向、flux 等，然后通过世界坐标确定其他足够近的着色点 rs，计算 rs 到 p 的间接光照最终完成着色</p><ul><li>针对手电筒类光源效果最好</li></ul><h3 id="Light-Propagation-Volumes-LPV"><a href="#Light-Propagation-Volumes-LPV" class="headerlink" title="Light Propagation Volumes (LPV)"></a>Light Propagation Volumes (LPV)</h3><p>基于光线在直线传播时能量不变的性质，考虑在三维上划分空间网格；算法大致流程如下</p><ol><li>Generation ：使用 RSM（足矣）或其他算法得到直接光源照亮的样本点，经过可选的采样得到虚拟光源</li><li>Injection ：基于预划分的网格逐个对其内部各朝向的 radiance 求和，然后投影到二阶（4个）球谐函数上</li><li>Propagation ：每个网格统计其六个面上接收的光照，向对应的相邻网格传播，持续多轮迭代直到光照在所有网格上稳定</li><li>Rendering ：对任意的着色点，确认其所在网格，根据网格内的各朝向 radiance 进行着色</li></ol><p>因为统计了方向，因此对 diffuse 和 glossy 都有效</p><p>问题 ：网格过大发生漏光，网格过小耗费内存和效率</p><h3 id="Voxel-Global-Illumination-VXGI"><a href="#Voxel-Global-Illumination-VXGI" class="headerlink" title="Voxel Global Illumination (VXGI)"></a>Voxel Global Illumination (VXGI)</h3><p>类似 RSM 是一种执行两步的算法，相较之下的主要区别是 ：</p><ol><li>将场景内的建模物体划分为网格，直接光照照射物体时描述具体到单个网格（体素 Voxel）</li><li>网格具有树状的层级关系，多个网格的集合构成上层节点</li></ol><ul><li>Pass 1 from the light ：从光源出发向场景采样式（RSM 等）发出光线，落到树结构上，在每个层级节点上记录入射光线和该层级反射面法线的分布</li><li>Pass 2 from the camera ：同样发出视线落到场景着色点上，反射出一条射线并构成锥体，该锥体再与第一步完成的树结构交互来统计对着色点有贡献的间接光源；针对 diffuse 则使用相邻的几个圆锥覆盖半球面</li></ul><h2 id="GI-in-Screen-Space"><a href="#GI-in-Screen-Space" class="headerlink" title="GI in Screen Space"></a>GI in Screen Space</h2><p>大致概括为从已知直接光照渲染结果的屏幕图出发，实现全局光照的渲染效果</p><h3 id="Screen-Space-Ambient-Occlusion-SSAO"><a href="#Screen-Space-Ambient-Occlusion-SSAO" class="headerlink" title="Screen Space Ambient Occlusion (SSAO)"></a>Screen Space Ambient Occlusion (SSAO)</h3><p>环境光遮蔽，即邻近物体间的阴影效果，使场景更具有立体感</p><p>假设：</p><ol><li>所有位置都会有来自各个方向的等量环境光（同 Blinn-Phong 模型思想）</li><li>不同的着色点不一定能对所有环境光可见，因此实现遮蔽</li></ol><p>因此环境光遮蔽效果实际上就是使用常量光去乘上着色点的平均 visibility 得到</p><h4 id="计算-visibility"><a href="#计算-visibility" class="headerlink" title="计算 visibility"></a>计算 visibility</h4><p>在模型空间上很容易理解可见性的计算，实际从着色点出发进行 Ray Tracing ，在一定距离内若未发生遮挡则认为该该方向可见</p><p><strong>在屏幕空间上</strong>，我们可以使用渲染时记录的深度图，对每个着色点进行球体范围内的采样，每个样本点映射到深度图上比较记录的深度，由此得到样本点是否位于物体内部，转化为是否能被着色点可见；由此近似着色点的 visibility</p><p>因为 AO 效果通常不会单独实现，因此不必要过多采样，而是用少量采样（约 16 个）得到有噪声的结果，然后模糊处理再叠加到渲染图上即可</p><h4 id="HBAO"><a href="#HBAO" class="headerlink" title="HBAO"></a>HBAO</h4><p>相交于 SSAO 进一步考虑着色点的法线方向，由此可以仅对半球采样，效果更好</p><h3 id="Screen-Space-Directional-Occlusion"><a href="#Screen-Space-Directional-Occlusion" class="headerlink" title="Screen Space Directional Occlusion"></a>Screen Space Directional Occlusion</h3><p>类似 AO 考虑着色点的可见性，但是 AO 认为近处的物体造成遮蔽效果，使得实际着色变暗；而 DO 认为近处遮挡物体造成间接光照，向着色点染上其他颜色，未被遮挡的光线为固定的环境光照</p><p><img src="/images/CG/SS-Directional-Occlusion.png" alt="类似使用深度，只是从camera出发"></p><p>同样考虑间接光照时，也像考虑遮挡性一样仅计算较近距离内的遮挡物</p><h3 id="Screen-Space-Reflection-SSR"><a href="#Screen-Space-Reflection-SSR" class="headerlink" title="Screen Space Reflection (SSR)"></a>Screen Space Reflection (SSR)</h3><p>在屏幕空间做光线追踪</p><p><img src="/images/CG/SSR-Process.png" alt=""></p><ol><li>先从视线处向反射表面射出 ray</li><li>根据 depth buffer 到达 ray 与反射面的交点，根据存储的法线、粗糙度信息得到反射 ray</li><li>分 step 追踪反射 ray 并比较深度，直到当前点大于深度，认为已经到达物体内部<ul><li>步长的确定显著影响效率和效果，使用 Hierarchical Tracing 算法，通过 minPooling 建立原始图像的 mipmap（从高到低细分），则光线与高层像素未相交时，显然与低层像素不会相交</li><li><pre><code class="lang-pesudo">mip = 0;while (level &gt; -1)  step through current cell;  if (above Z plane) ++level;  if (below Z plane) ++level;</code></pre></li></ul></li></ol><ul><li>屏幕空间只能看到二维深度记录的点，如果光线反射到外部都未发生交则认为没有反射（使用时根据反射光线的长度减弱反射效果）</li><li>屏幕空间上的遮挡点未记录深度，会有部分反射效果无法实现（不知道怎么解决）</li></ul><h4 id="Our-requirements"><a href="#Our-requirements" class="headerlink" title="Our requirements"></a>Our requirements</h4><ul><li>Sharp and blurry reflection</li><li>Contact hardening </li><li>Specular elongation 各向同性的反射面上，形成（雨天水面）拉长的效果</li><li>Per-pixel roughness and normal</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Real-Time-Global-Illumination&quot;&gt;&lt;a href=&quot;#Real-Time-Global-Illumination&quot; class=&quot;headerlink&quot; title=&quot;Real-Time Global Illumination&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Games-Graphics" scheme="http://remedios14.github.io/categories/Games-Graphics/"/>
    
    
    <category term="games" scheme="http://remedios14.github.io/tags/games/"/>
    
    <category term="计算机图形学" scheme="http://remedios14.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Games202-实时渲染阴影</title>
    <link href="http://remedios14.github.io/2022/06/20/Games/202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/Games202-%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E9%98%B4%E5%BD%B1/"/>
    <id>http://remedios14.github.io/2022/06/20/Games/202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/Games202-%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E9%98%B4%E5%BD%B1/</id>
    <published>2022-06-20T13:50:15.000Z</published>
    <updated>2022-06-27T01:15:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="内容概述"><a href="#内容概述" class="headerlink" title="内容概述"></a>内容概述</h3><p><strong>RTR dose not trust in Complexity</strong> 实时渲染不相信复杂度，只相信速度；2n 就是不如 n</p><p>Real-Time High Quality Rendering 高质量实时渲染</p><ul><li>Real-Time 实时性<ul><li>Speed ：高于 30 FPS 甚至更高</li><li>Interactivity ：实时交互性</li></ul></li><li>High Quality 保持较高质量<ul><li>Realism ：具有真实性</li><li>Dependability ：维持正确的渲染</li></ul></li></ul><p>涉及</p><ul><li>Shadow and Environment Mapping ：动态物体的实时多维阴影</li><li>Interactive Global Illumination Techniques ：实时的全局光照</li><li>Precomputed Radiance Transfer ：预计算</li><li>Real-Time Ray Tracing ：实时光追</li><li>Non-Photorealistic Rendering ：非真实感渲染（略述，另起专题）</li><li>Antialiasing and Supersampling ：反走样和上采样</li></ul><p><img src="/images/CG/Graphics-Pipeline.png" alt="渲染管线"></p><p>Glossy 是介于 Diffuse 和 Specular 之间的类似金属材质的反射</p><h3 id="作业框架"><a href="#作业框架" class="headerlink" title="作业框架"></a>作业框架</h3><p>分为 Vertex Shader 和 Fragment Shader</p><ul><li>Vertex Shader ：<ul><li>attribute 关键字声明顶点属性，仅在顶点着色器内使用</li><li>uniform 关键字表示从 CPU 直接拷贝入 GPU 的全局变量</li><li>varying 关键字描述要处理后交给片元着色器的变量</li><li>highp 表示高精度</li><li>变换后的顶点位置要赋值给 gl_Position 变量，一个 vec4</li></ul></li><li>Fragment Shader ：<ul><li>更多的全局变量，如折射率，光源位置等</li><li>声明 varying 的变量用于表示从顶点着色器中收到</li><li>输出的颜色要赋值给 gl_FragColor 变量，一个 vec4</li></ul></li></ul><p><img src="/images/CG/Real-Time-Rendering-Equation.png" alt="实时渲染下的方程"></p><h2 id="Shadows-阴影"><a href="#Shadows-阴影" class="headerlink" title="Shadows 阴影"></a>Shadows 阴影</h2><h3 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h3><ul><li>Shadow Mapping ：执行两次渲染，先从光源出发得到所有可照射点的深度，然后从相机出发将可视点对照其在前一次渲染中的深度来确定是否有阴影；有几个缺陷<ul><li>Self Occlusion 自遮挡 ：光源斜射向平面，由于没穿过一个像素射出的光线打到平面上都认为是常数的深度，分布在一个与该光线垂直的小方片上，此结果就可能遮挡在小方片后面的平面点，造成“不存在的阴影”；<strong>解决Trick</strong> ：当深度显著大于记录时才认为有阴影，即引入一个 threshold，可以根据角度变动；或者使用<strong>二次深度</strong>，但工业上没人用，增加时间</li><li>Aliasing 走样 ：跟光栅化时的走样原因一样</li></ul></li></ul><h3 id="数学近似"><a href="#数学近似" class="headerlink" title="数学近似"></a>数学近似</h3><p>在实时渲染中有一个贯穿始终的近似式，其在 g(x) 的支撑集较小或者取值较平滑时都能有很好的近似效果</p><script type="math/tex; mode=display">\int_{\Omega}f(x)g(x)dx\simeq \frac{\int_{\Omega}f(x)dx}{\int_{\Omega}dx}\cdot \int_{\Omega}g(x)dx</script><p>基于这个近似将 RTR 的渲染方程中 <strong>可见性</strong> 一项视作 f(x) ，处理点光源或平行光源照射到漫反射表面的模型时近似效果最佳</p><h3 id="Percentage-Closer-Soft-Shadows-PCSS"><a href="#Percentage-Closer-Soft-Shadows-PCSS" class="headerlink" title="Percentage Closer Soft Shadows PCSS"></a>Percentage Closer Soft Shadows PCSS</h3><p>软阴影描述了一种由面光源产生的具有一定渐变性的阴影效果</p><p>使用 PCF（Percentage Closer Filter） 实现的软阴影效果，其中前者本身用于抗锯齿</p><ul><li>PCF 原理 ：可以理解为基于原始的 Shadow map，采用一个卷积核 Filter 观察每个点在核视域内的可见点占比，以此比率作为该点的可见性，形成软阴影效果；公式如下</li></ul><script type="math/tex; mode=display">V(x)=\sum_{q\in \mathcal{N}(p)}w(p,q)\cdot \chi^+[D_{SM}(p)-D_{scene}(x)]</script><p>其中 x 表示着色点，p 为向光源中心射线后到 Shadow map 的交点，邻域由 Filter 大小确定，权重通常使用高斯核</p><p>使用时越小的 Filter 得到锐利的阴影，越大的则得到软阴影；为了更符合现实，通常使靠近遮挡物的阴影更锐利，远处则采用更大的卷积核做出软阴影</p><p><img src="/images/CG/PCSS-Filter-Selection.png" alt="左值越大越适用软阴影"></p><p><strong>完整流程</strong></p><ol><li>Blocker search ：从着色点向<strong>面光源中心</strong>射线，得到 shadow map 上的像素，然后使用可调的 Filter 获取区域内所有深度小于该点的平均深度，表示遮挡物的平均深度<ul><li>一个启发式的方法，不向光源中心而是向面光源顶点射线，由此得到 shadow map 上的区域</li></ul></li><li>Penumbra estimation ：使用平均深度来确定合适的 PCF 大小</li><li>PCF</li></ol><p><strong>注意</strong> ：非常遗憾，反复的卷积操作非常耗时，因此工业上还需要很多的 Tricks 才能应用</p><h3 id="Variance-Soft-Shadow-Mapping"><a href="#Variance-Soft-Shadow-Mapping" class="headerlink" title="Variance Soft Shadow Mapping"></a>Variance Soft Shadow Mapping</h3><p>PCSS 主要耗时在于第一步和第三步，比较直觉的优化是引入噪声采样而非全部遍历，但缺点也很明显</p><hr><p><strong>针对第三步</strong></p><p>由于 PCF 步骤需要根据卷积核内的更深像素数占比来确定阴影强度，相当于检查深度名次，因此近似看作高斯分布，确定 均值、方差、当前值 来快速确定该“名次”</p><p>为此需要快速查询区域的均值和方差方法：</p><ul><li>均值 ：使用 Hardware Mipmap 或者 Summed Area Tables （推荐）</li><li>方差 ：使用平方的期望减期望的平方计算方差，因此即使用两张 SM 来完成查询，正好查均值也要用；在生成 SM 时就可以完成</li></ul><p>然而根据高斯分布查表或求数值解还是不算快，因此又引入切比雪夫不等式用于近似（把不等号直接视作越等号，要求 t 值在均值右侧）</p><script type="math/tex; mode=display">P(x>t)\le \frac{\sigma^2}{\sigma^2+(t-\mu)^2}</script><hr><p><strong>针对第一步</strong></p><p>容易查询得知区域内的所有点深度均值 $Z<em>{avg}$，需要获知深度小于当前点的平均深度 $Z</em>{ooc}$，与之对应的非遮挡物平均深度为 $Z_{unooc}$</p><p>由此有个简单的公式 </p><script type="math/tex; mode=display">\frac{N_1}{N}Z_{unooc}+\frac{N_2}{N}Z_{ooc}=Z_{avg}</script><p>使用切比雪夫近似地估计 $\frac{N_1}{N}$ 并且将非遮挡点的深度视作和当前点深度一致为 t （纯纯的 Trick），由此即可计算出遮挡点的平均深度</p><h4 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h4><p>上面都说了查到均值后如何计算，这里则给出如何快速查询均值，即使用 MIPMAP 或 <strong>SAT</strong></p><ul><li>MIPMAP ：（仅能查询方形区域）根据目标点找到两个层级，然后插值完成</li></ul><p>Summed Area Tables ：即是用前后的前缀和做差得到范围内的和（一维），二维则使用矩形区域</p><pre><code>- 问题在于构建和存储 ：存储必定要和原图一样的大小，构建时先横向求和，再纵向求和；为了提升效率需要正确地并行</code></pre><h3 id="Moment-Shadow-Mapping"><a href="#Moment-Shadow-Mapping" class="headerlink" title="Moment Shadow Mapping"></a>Moment Shadow Mapping</h3><p>VSSM 在非均匀的深度分布下可能漏光，因为切比雪夫的近似仅使用到二阶矩</p><p>MSM 即使用高阶矩（通常 4 阶）来近似分布函数去计算比率</p><h3 id="Distance-Field-Soft-Shadows"><a href="#Distance-Field-Soft-Shadows" class="headerlink" title="Distance Field Soft Shadows"></a>Distance Field Soft Shadows</h3><p>Optimal Transport</p><p>在空间中定义一个物体的距离场，描述各个点到该物体表面的最近距离，（可以考虑带符号，内部为负）用于实现运动的插值；距离场函数用 SDF(p) 描述，表示点 p 到物体的最近距离</p><p>此时可知从点 p 出发向任意方向运动 SDF(p) 都不会撞上物体</p><p><img src="/images/CG/Distance-Field-Soft-Shadows.png" alt="逐步在光线方向上采样点，根据其 SDF 值判断必定非遮挡的角度"></p><p><strong>注意</strong> ：渲染上尽量避免复杂的运算，因此 arcsin 这类也要避免，转而使用下式近似描述角度，同时 k 可调整软硬程度，k 越大越锐利</p><script type="math/tex; mode=display">min{\frac{k\cdot SDF(p)}{p-o}, 1.0}</script><p>然而还要考虑生成 SDF 的时间，针对形变的物体都要重新生成</p><h2 id="Environment-Mapping"><a href="#Environment-Mapping" class="headerlink" title="Environment Mapping"></a>Environment Mapping</h2><p>描述环境光是指从当前点向任意方向看去所能捕获到的光照，有两种图像表现形式 ：Spherical、Cube ；其中球状的映射在南北极会有明显的拉伸变形</p><h3 id="Image-Based-Lighting-（IBL）"><a href="#Image-Based-Lighting-（IBL）" class="headerlink" title="Image-Based Lighting （IBL）"></a>Image-Based Lighting （IBL）</h3><p>已知环境光照的存储图像，还原任意物体的着色；通过 Rendering Equation 借助蒙特卡洛方法能实现，但其效率通常认为无法用在实时渲染上</p><p>回顾在 SM 中使用过的积分近似，针对 glossy 表面的 brdf 仅在较小的反射区域取值，而针对 smooth 表面则在半球面上保持平稳，正好符合要求</p><p><img src="/images/CG/Environment-Mapping-Approx.png" alt="渲染方程中的近似"></p><h4 id="The-Split-Sum"><a href="#The-Split-Sum" class="headerlink" title="The Split Sum"></a>The Split Sum</h4><p>针对近似的渲染方程，分两个部分考虑积分值：</p><ol><li>框选分式部分 ：基于高斯滤波对环境光照图像进行预处理（mipmap），然后按照 brdf 去单次采样特定方向的光照图；例如镜面反射方向（glossy）或法线方向（漫反射）</li><li>余下积分式部分 ：回顾 101（五） 中提及的 “微表面 BRDF”，将式子中的 f 拆分为分子中的三式；考虑菲涅尔项的 Schlick 近似，将 f 除以 F 再乘以近似式并展开，得到积分可写成仅与粗糙度和角度有关，足以做成 LookUpTable<br><img src="/images/CG/Divide-Fresnel-LUT.png" alt="简化参数表示"></li></ol><p>最终将所有的积分都转为小变量求和，即构成 Split Sum</p><h3 id="Shadow-from-Environment-Lighting"><a href="#Shadow-from-Environment-Lighting" class="headerlink" title="Shadow from Environment Lighting"></a>Shadow from Environment Lighting</h3><p>具体很难实现，工业上有一个做法是仅实现一个最强光源产生的阴影</p><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>频域图可以理解为以坐标为变化频率的点数统计，中心即代表变化频率 (0,0) ，因此表示低频信息</p><p><img src="/images/CG/Spherical-Harmonics-Functions.png" alt="球谐函数，三维空间上描述方向的二维基函数"></p><p>每一阶的球谐函数都构成一组基，对于任意角度函数 f(ω) ，其表示成相应基的线性组合时的系数可计算</p><script type="math/tex; mode=display">c_i = \int_{\Omega}f(\omega)B_i(\omega)d\omega</script><p>使用前三阶的球谐函数来近似漫反射的 BRDF 和入射光照（两者都是低频信号）足以取得很好的效果</p><h4 id="Precomputed-Radiance-Transfer-（PRT）"><a href="#Precomputed-Radiance-Transfer-（PRT）" class="headerlink" title="Precomputed Radiance Transfer （PRT）"></a>Precomputed Radiance Transfer （PRT）</h4><p><img src="/images/CG/Basic-Idea-of-PRT.png" alt="假定固定观察者视角 o，则仅有光照方向 i 发生变化"></p><ul><li>针对漫反射情况，将光照项分解成球谐函数的线性组合，提取出系数项并将基函数项保留在积分式中，预计算积分部分（也可以展开成基函数的线性组合）；最终与任何角度都无关<ul><li>代价就是，一旦场景中物体发生位置变化，就会影响可见性的部分，即需要重新预计算</li></ul></li></ul><p><img src="/images/CG/Diffuse-Case-PRT.png" alt=""></p><ul><li>针对 Glossy 情况，输出结果与观察方向有关，将出射方向 o 展开成基函数形式，最终针对一个着色点需要存储一个矩阵大小的信息</li></ul><p><img src="/images/CG/Glossy-Case-PRT.png" alt=""></p><h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><p>往后还有使用小波变换来代替球谐函数的研究</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;内容概述&quot;&gt;&lt;a href=&quot;#内容概述&quot; class=&quot;headerlink&quot; title=&quot;内容概述&quot;&gt;&lt;/a&gt;内容概述&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;RTR dose not trust in Complexity&lt;/strong&gt; 实时渲染不相信复杂度，只</summary>
      
    
    
    
    <category term="Games-Graphics" scheme="http://remedios14.github.io/categories/Games-Graphics/"/>
    
    
    <category term="games" scheme="http://remedios14.github.io/tags/games/"/>
    
    <category term="计算机图形学" scheme="http://remedios14.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Games104-游戏引擎中的渲染、动画、物理</title>
    <link href="http://remedios14.github.io/2022/06/12/Games/104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Games104-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E3%80%81%E5%8A%A8%E7%94%BB%E3%80%81%E7%89%A9%E7%90%86/"/>
    <id>http://remedios14.github.io/2022/06/12/Games/104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Games104-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E3%80%81%E5%8A%A8%E7%94%BB%E3%80%81%E7%89%A9%E7%90%86/</id>
    <published>2022-06-12T04:03:33.000Z</published>
    <updated>2022-06-12T12:00:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Basic-of-Game-Rendering"><a href="#Basic-of-Game-Rendering" class="headerlink" title="Basic of Game Rendering"></a><strong>Basic of Game Rendering</strong></h2><p>针对场景、材质等渲染和动画的渲染，可以花费时间代价来追求效果，而游戏中的渲染则更加注重实时性</p><ul><li>Challenges on Game Rendering<ul><li>实时性</li><li>针对不同硬件平台的统一性</li><li>帧率的稳定性</li><li>算力限制，不能在渲染上花费太多资源，要分给其他部分</li></ul></li></ul><p><strong>非真实感渲染</strong></p><p><strong>渲染问题总是非常耗时，为了实现好的渲染效果，一个很基本的思想即是预计算转化为少量参数，成像时仅需要采样即可</strong></p><p>投影和光栅化；补充上反走样的处理</p><ul><li>Hardware architecture<ul><li>SIMT (Single Instruction Multiple Threads) 现代显卡的理念</li></ul></li><li>Render data organization<ul><li>将网格、材质等描述的 Game Object 组织起来进行渲染</li><li>网格顶点的数据实际存储，而构成的面则可以仅存储顶点的索引</li><li>材质数据主要由纹理来描述</li><li>经过 Renderer 完成具体效果的渲染</li><li><strong>架构问题</strong> ：一个完整网格物体通常由很多部分不同材质构成，以 submesh 区分；很多对象通常有一致的模型，因此在渲染一种材质后构成一个 pool，通过对应检索即可略过大量重复计算</li></ul></li><li>Visibility：<ul><li>仅需要渲染当前视野内可见范围的对象，即一个从相机出发的四棱锥；引入一些树划分方法（如 BVH）来快速地确定可见区域内地对象</li><li>Potential Visibility Set ：一种早期想法，以房间划分则仅有门窗可透视，此时仅需要渲染有门窗相连地场景</li></ul></li></ul><h3 id="贴图压缩-Texture-Compression"><a href="#贴图压缩-Texture-Compression" class="headerlink" title="贴图压缩 Texture Compression"></a>贴图压缩 Texture Compression</h3><p>为了节约存储同时又保证随机访问的效率，通常采用 Block 压缩，将贴图每四个方形像素分块，保存少量信息实现压缩</p><h3 id="Cluster-Based-Mesh-Pipeline"><a href="#Cluster-Based-Mesh-Pipeline" class="headerlink" title="Cluster-Based Mesh Pipeline"></a>Cluster-Based Mesh Pipeline</h3><p>现代化的新发展方向、Nanite</p><h3 id="Materials-Shaders-and-Lighting"><a href="#Materials-Shaders-and-Lighting" class="headerlink" title="Materials, Shaders and Lighting"></a>Materials, Shaders and Lighting</h3><p>渲染方程（见 <a href="../../../../5/31/Games-Graphics/Games101-计算机图形学（四）/#渲染方程">Games101</a>）</p><ul><li>三大难点：1.如何计算各个方向的入射 irradiance；2. 如何精确地在半球面上积分；3. 如何考虑光线的多次反射</li></ul><p>考虑散射光、Blinn Phong、Shadow Mapping，实现的效果以及差不多够看了</p><ul><li>球谐函数 Spherical Harmonics —— 一组三维空间中使用两个角度 θ 和 φ 描述的基函数，因为是基函数，可用于近似任意的三维函数，只要提升阶数就能降低偏差</li></ul><p><a href="https://zhuanlan.zhihu.com/p/359856625">使用球谐函数简化光照</a></p><ul><li>PBR(SG, MR) Physics-Based Rendering</li><li>Shader permutation</li><li>Lighting</li></ul><h3 id="Special-Rendering"><a href="#Special-Rendering" class="headerlink" title="Special Rendering"></a>Special Rendering</h3><p>地形、大气、云层；以及后处理</p><p>渲染上的实现通常控制屏幕中的像素量保持不变，原始的大地模型都采用比较大的网格，根据相机位置将近处的网格细分，保证在同样的 FOV 下观察到的网格总量尽可能一致；一些射击游戏中的倍镜通过缩小视角实现，此时在保持网格数不变的情况下，对远处图像的表示精度就提升了</p><ul><li>Terrain：通常借助等高线 HeightField；<ul><li>QuadTree 四叉树，将大面积的地形切割存储 —— 切割时总会有一个边界上两侧的切割数不一致，解决方法是将更细分得到的顶点吸附到粗分的顶点，称为 stiching</li><li>Mesh Shader</li><li>Real-Time Deformable Terrian ：外部 GO 交互影响材质，形成类似“雪痕”效果</li><li><strong>Camera-Raletive</strong> Rendering —— 制作大地形时，对远处的网格渲染很容易发生浮点数精度误差而抖动；一种 trick 就是挪动相机后使用相对相机的位置</li></ul></li><li>数目、装饰物（如草丛等）的渲染：近处实现精细渲染，远处简化为柱体等</li><li>Sky / Fog ：都通过介质描述，光路在通过介质时会发生 散射、通透；其中通透部分经过积分削弱即完成<ul><li>Rayleigh Scattering、Mie Scattering<br><img src="/images/Engine/Analytic-Atmosphere-Appearance-Modeling.png" alt="基础的地面视角解析"></li></ul></li><li>Clouds ：使用 Volumetric Modeling（体积度量的模型），引入噪声实现不同的形状，模拟分形效果</li></ul><h3 id="Pipline"><a href="#Pipline" class="headerlink" title="Pipline"></a>Pipline</h3><p>Ambient Occlusion ：环境光遮蔽，描述一种表面凹陷形成黑暗区域的视觉效果</p><pre><code>- Screen Space AO ：视线穿过像素点落在表面上，计算视线落点在球空间的可见性，用采样点计算比例表示- SSAO+ ：上述方法采样整个球，但通常半个球在表面内侧，必然不可见；该 plus 方法即根据落点法向采样半球- HBAO（Horizon-based AO）：同样半球面，不过根据角度确定多少范围内的光被遮挡- GTAO（Ground Truth-based AO）：</code></pre><p>雾效 Fog Everything</p><pre><code>- Depth Fog ：描述不同深度的雾效，选择 线性、指数、指数平方 等关系- Height Fog ：- Voxel-based Volumetric Fog</code></pre><p>反走样 Anti-aliasing ：由于输出以像素为单位，总是存在走样问题</p><pre><code>- Super-sample AA ：上采样，直接将单个像素均分为四个然后着色取之后的比例作为最终结果- MASS ：针对网格仅对边界上采样，效率没啥优化；对精细模型没啥提升- FXAA ：比较当前像素与上下左右像素的色差大致确定轮廓- TAA（Temporal AA）：时序上的 blending</code></pre><p>后处理 Post-process</p><pre><code>- Bloom 光晕 ：    1. 先对图像二值化得到高亮度区域    2. 逐层下次采样并保留，达到指定水平    3. 通过高斯滤波逐层还原，并与下采样时同层的叠加    4. 得到原始分辨率的成果图，与原图叠加实现效果- Tone Mapping 曝光 ：做法通常是根据图像中总体光强度通过一个曲线改变其分布；ACES- Color Gradient 颜色梯度 ：即给出始末两个颜色水平，均匀采样后进行插值，得到原始颜色空间到颜色梯度空间的 Lookup Table；低耗高效    - 通常使用 256 \* 16 的尺寸存储 LUT，分为 16 块，每块固定一个 blue 通道值向右递增，块内部横向 red 通道递增，纵向 green 通道递增</code></pre><ul><li>Real pipeline with mixed effects</li><li>Ring buffer and V-Sync</li><li>Tiled-based rendering</li></ul><h2 id="Basic-of-Animation-Technology"><a href="#Basic-of-Animation-Technology" class="headerlink" title="Basic of Animation Technology"></a>Basic of Animation Technology</h2><p>基于视觉残留</p><ul><li>游戏动画的挑战 ：<ol><li>交互性和动态变化</li><li>实时需求，和所有的功能模块竞争单帧算力</li><li>动画的真实性，包括整体动作和微观细节，如表情</li></ol></li></ul><h3 id="2D-动画"><a href="#2D-动画" class="headerlink" title="2D 动画"></a>2D 动画</h3><p>Sprite Animation —— 使用大量的连续帧构成动画；早期节约资源的方法</p><p><strong>Live2D</strong> —— 将各种需要分别设计动作的部分（眼睛、眉毛、嘴巴等）分为图元，调节深度可控制显式，加入控制点实现局部形变来模拟动作</p><h3 id="3D-动画"><a href="#3D-动画" class="headerlink" title="3D 动画"></a>3D 动画</h3><p>DoF (Degrees of Freedom) —— 对刚体运动的表达，例如三个轴向的平移加上绕三个轴的旋转即达到 6DoF；再加上三个方向的 Scale 达到 9DoF</p><p>几种动画方法：</p><ul><li>Per-vertex Animation —— 记录每个顶点的位置离线模拟，顶点变化影响法向，从而影响材质的表现</li><li>Morph Target Animation —— 由顶点动画发展来，通过关键帧顶点位置插值完成动画</li><li><strong>3D Skinned Animation</strong> —— 使用骨骼结构穿插到模型内，模拟动作；使用最广泛的一种，2D 也有</li><li>Physics-based Animation —— 布娃娃系统，使用纯物理来模拟骨架；IK (Inverse Kinematic)</li></ul><h4 id="Skined-动画如何实现"><a href="#Skined-动画如何实现" class="headerlink" title="Skined 动画如何实现"></a>Skined 动画如何实现</h4><p>先建立骨骼然后在外部套上网格，基本固定网格相对骨骼位置，控制骨骼运动</p><p>几个重要的设计点：</p><ol><li>先确立骨骼的局部坐标系，以此为基准确定外部网格，然后转为世界坐标系进行渲染；其中转化的矩阵运算需要确保无误</li><li>不同动物体的骨骼都有所不同，都需要符合现实分别设计</li><li>实际上骨骼的运动是通过关节运动实现的，正向运动学已知关节变化角度来确定位置，但不方便设计；逆向动力学已知位置逆推关节角度</li><li>需要初期设计好一个<strong>标准模型</strong>的骨骼架构，而针对一些复杂模型如带大服饰、物件的模型再追加设计</li><li>在椎骨末端增加一个尾骨连接到两足中间，不影响模型位置，同时方便实现跳跃、下蹲等动作的高度调整</li><li>两个或多个骨骼模型的绑定实现，当绑定后将有部分形变保持一致</li></ol><h4 id="Math-of-3D-Rotation"><a href="#Math-of-3D-Rotation" class="headerlink" title="Math of 3D Rotation"></a>Math of 3D Rotation</h4><p><img src="/images/Engine/Roll-Pitch-Yaw.png" alt="三维物体角度描述"></p><p>欧拉角度的几个问题：</p><ol><li>Gimbal Lock ：一定角度下会失去一个 DoF（查一下）</li><li>难以插值，线性插值结果不正确</li><li>无法进行旋转组合，仅方便描述单物体单次旋转</li><li>难以给定向量绕其旋转</li></ol><p><strong>Quaternion</strong> <a href="https://zhuanlan.zhihu.com/p/97186723">四元数，神中神</a> （定时22/10/01自己整理一篇）</p><p><img src="/images/Engine/Skinning-Matrix.png" alt="运算"></p><p>将等式同时左乘关节的 pose 矩阵，可以理解为在绑定时刻仅知道绑定关节的空间位姿和本节点的坐标，以此算出本节点相对绑定关节的局部空间坐标</p><p>以此局部空间坐标，在任意时刻左乘绑定关节的空间位姿，即得到本节点在该时刻的模型空间坐标</p><ul><li>Skin 的网格坐标通常取几个关节点的 model space 坐标加权后插值得到<ul><li>插值前做一个点积运算判断往那边是更近的插值</li><li>插值方法 ：NLerp 首尾点连线上插值，然后伸长到弧上（不均匀）、SLerp 反三角函数运算，根据角度插值</li><li>通常角度较小时 NLerp 节约时间；较大时 SLerp 保持自然</li></ul></li></ul><h3 id="动画压缩-Animation-Compression"><a href="#动画压缩-Animation-Compression" class="headerlink" title="动画压缩 Animation Compression"></a>动画压缩 Animation Compression</h3><p>大致思路是分为 Rotation、Transparent、Scale 三个维度，逐帧检查是否需要插入关键帧，若以某处为关键帧向前插值会造成较大误差，则取前面发生该误差的时间点作为关键帧，然后继续向后搜索</p><hr><h2 id="Advanced-of-Animation"><a href="#Advanced-of-Animation" class="headerlink" title="Advanced of Animation"></a><strong>Advanced of Animation</strong></h2><h3 id="动画混合-Blending"><a href="#动画混合-Blending" class="headerlink" title="动画混合 Blending"></a>动画混合 Blending</h3><ul><li>线性 Blending</li></ul><p>实现连贯的动画效果转换，以人物的行走到跑动的转变为例 ：</p><ol><li>行走和跑动都有一组循环的动画，并且分别有一个速度水平</li><li>根据实际动画中的速度水平线性插值计算出当前速度下的两者权重</li><li>将行走和跑动的动画都根据<strong>时长归一化</strong>，然后对应每一个点都是用上面算出的权重插值得到中间的动画</li></ol><p>更进一步的有更多方向的运动，但要进行插值都至少要有几组确定好的循环动画；关于多方向运动的插值有 Delaunay Triangulation 进行二维空间划分然后使用三角形重心坐标插值</p><ul><li>Skeleton Mask Blending ：遮罩混合（不翻译更好），类比图像的 mask，即一部分骨骼不应用动画；例如坐着摆手</li><li>Additive Blending ：仅保存动画的变化量，例如点头动画，可以任意加上旋转；但也要适度，否则会有 joint 异常</li></ul><h3 id="动作状态机-Animation-State-Machine"><a href="#动作状态机-Animation-State-Machine" class="headerlink" title="动作状态机 Animation State Machine"></a>动作状态机 Animation State Machine</h3><p>就是状态机，按照一定的规则切换动画；<strong>具体的状态机仅判断输入和前一刻状态完成状态更新，具体动画通过读取当前状态以及是否发生更新来选择输出</strong></p><ul><li>Cross Fade ：切换过程中采用一定时长及曲线来渐变转换，有很多种 Fade Curves</li><li>Layer ASM ：分层状态机（鬼泣5），查查看</li></ul><h3 id="动画树-Animation-Blend-Tree"><a href="#动画树-Animation-Blend-Tree" class="headerlink" title="动画树 Animation Blend Tree"></a>动画树 Animation Blend Tree</h3><p>学习虚幻引擎</p><h3 id="IK-技术"><a href="#IK-技术" class="headerlink" title="IK 技术"></a>IK 技术</h3><ul><li>Two Bone IK ：以脚踩凸出地块为例，确定大腿根部和凸出地块坐标，分别以大小腿骨骼长度做出两个球，则球表面相交环都可以作为中间关节的位置；然后考虑运动方向，只取通向侧的最外点即得到结果</li></ul><hr><p>稍微长一点的骨骼结构就很难，一些启发式算法（都不能确保达到终点，需要给出一个接受水平来停止迭代）：</p><ul><li>CCD (Cyclic Coordinate Decent) ：几乎纯 hack 的方法，从叶子关节往上迭代，每次都调整当前关节使末关节靠近目标点（达到一定范围后进入下一次），迭代到根关节时再重开</li><li>FABRIK (Forward And Backward Reaching IK) ：循环执行向前和向后步骤直到一定水平<ul><li>向前步骤，强制移动叶关节到目标位置，向前一个关节连线，保留骨骼长度得到前几段的终点，然后递归；完成一步后通常根关节会变化位置</li><li>向后步骤，即把初始的根关节位置作为目标点，反向执行上面描述的步骤</li></ul></li></ul><h3 id="动画重定向"><a href="#动画重定向" class="headerlink" title="动画重定向"></a>动画重定向</h3><p>相同的一组动画效果应用到不同的骨骼结构上</p><hr><h2 id="Physics-System"><a href="#Physics-System" class="headerlink" title="Physics System"></a>Physics System</h2><h3 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h3><p>通常把游戏实现分为逻辑层和渲染层，物理效果大部分在逻辑层实现</p><p>一个物理系统的参与者称为 actor，可分为四类：Static、Dynamic、Trigger、Kinematic（运动学规则约束，违背物理）</p><p>基础的几何形体（方便求交）：球体、胶囊体（通常用在人物上）、Box、Convex Mesh（石块类）、Triangle Mesh、Height Field（地形等）</p><p>形体属性：质量、密度、质心、物理材质 Material（摩擦力 Friction、弹性 Restitution）</p><h4 id="力与运动"><a href="#力与运动" class="headerlink" title="力与运动"></a>力与运动</h4><ul><li>常规持续的作用力，如重力，拖拽力，摩擦力</li><li>瞬时触发力<strong>冲量</strong> impulse</li></ul><p>运动的实现 ：见<a href="../../../04/Games-Graphics/Games101-计算机图形学（六）/#粒子运动的求解">简述粒子运动</a></p><p>动量 = 质量 × 速度</p><h4 id="刚体动力学"><a href="#刚体动力学" class="headerlink" title="刚体动力学"></a>刚体动力学</h4><ul><li>朝向 Orientation $\mathbf{R}$（矩阵或四元数表达）</li><li>角速度 Angular velocity $\vec{\omega}$</li><li>角加速度 Angular acceleration $\vec{\alpha}$</li><li>惯性张量 Inertia tensor $\mathbf{I}$</li><li>角动量 Angular momentum $\vec{L}=\mathbf{I}\vec{\omega}$</li><li>Torque $\vec{\tau}=\frac{d\vec{L}}{dt}$</li></ul><h4 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h4><p>一般通过粗细两次筛选</p><p>粗筛中可用 BVH、Sort and Sweep —— 分轴向排序盒子边界来判断是否相交</p><p>细筛中有三种方法：</p><ul><li>形状相交检测 ：基于简单形状判断，球、胶囊类</li><li>Minkowski Difference-based Methods<ul><li>Minkowski 和，描述两个集合内各取任意一（向量）点的和的集合；同理定义差</li><li>平面上的两个凸包点集有交 iff 两者的 Minkowski 差包含原点</li><li>后续引入 GJK 算法对有交的情况快速找交点</li></ul></li><li>Separation Axis Theorem<ul><li>不相交的两个形状一定能找到分离轴；三维上即分离面</li></ul></li></ul><h3 id="Applications"><a href="#Applications" class="headerlink" title="Applications"></a>Applications</h3><p>暂略</p><p>PBD、XPBD</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Basic-of-Game-Rendering&quot;&gt;&lt;a href=&quot;#Basic-of-Game-Rendering&quot; class=&quot;headerlink&quot; title=&quot;Basic of Game Rendering&quot;&gt;&lt;/a&gt;&lt;strong&gt;Basic of </summary>
      
    
    
    
    <category term="Game-Engine" scheme="http://remedios14.github.io/categories/Game-Engine/"/>
    
    
    <category term="games" scheme="http://remedios14.github.io/tags/games/"/>
    
    <category term="现代游戏引擎" scheme="http://remedios14.github.io/tags/%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>Python-游戏脚本</title>
    <link href="http://remedios14.github.io/2022/06/08/OpenCV/Python-%E6%B8%B8%E6%88%8F%E8%84%9A%E6%9C%AC/"/>
    <id>http://remedios14.github.io/2022/06/08/OpenCV/Python-%E6%B8%B8%E6%88%8F%E8%84%9A%E6%9C%AC/</id>
    <published>2022-06-08T11:51:41.000Z</published>
    <updated>2022-07-07T00:41:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>基于 opencv、pillow、pywin 来捕获图像并模拟按键操作</p><h2 id="星露谷物语钓鱼脚本"><a href="#星露谷物语钓鱼脚本" class="headerlink" title="星露谷物语钓鱼脚本"></a>星露谷物语钓鱼脚本</h2><p>设计工作流程：（确保预先调整好钓鱼位置并切换到钓竿）</p><ol><li>获取窗体并正常显示后置于最前</li><li>执行单次钓鱼流程<ol><li>模拟鼠标左击并等到蓄力满时模拟释放左键</li><li>等待画面，人物头顶出现感叹号时模拟左击，鱼上钩</li><li>追踪钓鱼条直到完成捕获</li></ol></li><li>循环执行钓鱼流程，等待终止命令</li></ol><h3 id="细节完成"><a href="#细节完成" class="headerlink" title="细节完成"></a>细节完成</h3><p>模拟蓄力目前使用 <code>time.sleep(1.03)</code> 来完成了，实际中偶尔出现卡顿而发生偏差。<del>但不蓄满力不影响钓上鱼，暂且先不管了</del></p><hr><p>捕获感叹号：目前截取屏幕中央的矩形区域，采样后发现叹号出现约 0.6+ 秒，考虑刚出现叹号的帧，用较小区域内的像素变化来捕获</p><p>当场景背景深色时前后截图的差较小，场景背景亮色时前后截图的差较大，暂且凭感觉根据负相关性给出一个阈值了</p><ul><li>TODOs：<ul><li>部分钓鱼点由于处在游戏区域边缘，人物模型不在屏幕中央，改进矩形捕获位置 —— 可以试试轮廓检测能否捕获到人物位置所在矩形，然后以此确定叹号位置</li></ul></li></ul><hr><p>捕获鱼条位置：</p><ul><li>由于鱼条的绿色不纯正，还经常变成浅色，与背景框混淆，目前采用通道 g - r 同时将鱼条和鱼都捕获，然后根据尺寸区分</li><li>鱼块比较容易确定，定位后比较位置来判断执行左键按下或抬起</li></ul><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> win32api</span><br><span class="line"><span class="keyword">import</span> win32con</span><br><span class="line"><span class="keyword">import</span> win32gui</span><br><span class="line"><span class="keyword">import</span> win32print</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageGrab</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">intLerp</span>(<span class="params">a, b, t</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>((<span class="number">1</span>-t)*a+t*b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">varCompare</span>(<span class="params">pre, cur, l = <span class="number">0</span></span>):</span><br><span class="line">    hist1 = cv2.calcHist([pre], [l], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">    hist2 = cv2.calcHist([cur], [l], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">    </span><br><span class="line">    h1 = hist1[:, <span class="number">0</span>]</span><br><span class="line">    h2 = hist2[:, <span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 这里理论上不应该用前一帧该通道的均值，而用其值与黄色在该通道下的值的差值更好，但是我也就说说</span></span><br><span class="line">    res = (h2 - h1).var() / <span class="number">256</span></span><br><span class="line">    res = res / pre[:, :, l].mean()</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FishBar</span>():</span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> 捕鱼的操作可以再优化一下；如果能检测出鱼框上下边界，考虑进碰撞的反弹，那可以试试强化学习    </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.cur_speed = <span class="number">0.0</span></span><br><span class="line">        self.last_top = <span class="number">420</span></span><br><span class="line">        self.vert_mid = <span class="number">0</span></span><br><span class="line">        self.inited = <span class="literal">False</span></span><br><span class="line">        self.mouse_down = <span class="literal">False</span></span><br><span class="line">    <span class="comment"># 控制钓鱼条，可以优化</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, brect, frect, dt</span>):</span><br><span class="line">        bar2f = brect[<span class="number">1</span>] - (frect[<span class="number">1</span>] + frect[<span class="number">3</span>])</span><br><span class="line">        fish2b = frect[<span class="number">1</span>] - (brect[<span class="number">1</span>] + brect[<span class="number">3</span>])</span><br><span class="line">        self.cur_speed = (self.last_top - brect[<span class="number">1</span>]) / dt</span><br><span class="line">        self.last_top = brect[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> bar2f &gt; <span class="number">0</span>:</span><br><span class="line">            win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">elif</span> fish2b &gt; <span class="number">0</span>:</span><br><span class="line">            win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> self.cur_speed &lt; <span class="number">0</span> <span class="keyword">or</span> \</span><br><span class="line">                (frect[<span class="number">1</span>] + frect[<span class="number">3</span>] / <span class="number">2</span>) &lt; (brect[<span class="number">1</span>] + brect[<span class="number">3</span>] / <span class="number">4</span>):</span><br><span class="line">                win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">clear</span>(<span class="params">self</span>):</span><br><span class="line">        win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FishingScript</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.whandle = <span class="literal">None</span></span><br><span class="line">        self.left_top = (<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        self.h_width = <span class="number">0</span></span><br><span class="line">        self.h_height = <span class="number">0</span></span><br><span class="line">        self.wind_prop = <span class="number">1.0</span></span><br><span class="line">        <span class="comment"># 识别叹号的阈值，越大越不容易误识别，可视输出调整</span></span><br><span class="line">        self.marker_thresh = <span class="number">0.3</span></span><br><span class="line">        self.shot_t = <span class="number">0.1</span></span><br><span class="line">        <span class="comment"># <span class="doctag">TODO:</span> 有机会再追加函数确定人物所在位置</span></span><br><span class="line">        self.cha_hmid = <span class="number">0</span></span><br><span class="line">        self.cha_vmid = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 激活窗口并放置鼠标</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">activateWnd</span>(<span class="params">self, hsv</span>):</span><br><span class="line">        l, t, r, b = win32gui.GetWindowRect(hsv)</span><br><span class="line">        <span class="comment"># 若处于缩略窗口就先切换正常显示</span></span><br><span class="line">        <span class="keyword">if</span> r &lt; <span class="number">0</span>:</span><br><span class="line">            win32gui.ShowWindow(hsv, win32con.SW_SHOWNORMAL)</span><br><span class="line">        win32gui.SetForegroundWindow(hsv)</span><br><span class="line">        l, t, r, b = win32gui.GetWindowRect(hsv)</span><br><span class="line">        proportion = <span class="built_in">round</span>(win32print.GetDeviceCaps(win32gui.GetDC(<span class="number">0</span>), win32con.DESKTOPHORZRES)/win32api.GetSystemMetrics(<span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">        self.setWindowProp((l, t, r, b), proportion)</span><br><span class="line">        win32api.SetCursorPos((intLerp(l, r, <span class="number">0.5</span>), intLerp(t, b, <span class="number">0.5</span>)))</span><br><span class="line">        win32gui.SetForegroundWindow(self.whandle)</span><br><span class="line">        cv2.waitKey(<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 截屏整个游戏窗口</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">grabFullImg</span>(<span class="params">self</span>):</span><br><span class="line">        l, t, r, b = win32gui.GetWindowRect(self.whandle)</span><br><span class="line">        l = <span class="built_in">int</span>(l * self.wind_prop)</span><br><span class="line">        t = <span class="built_in">int</span>(t * self.wind_prop)</span><br><span class="line">        r = <span class="built_in">int</span>(r * self.wind_prop)</span><br><span class="line">        b = <span class="built_in">int</span>(b * self.wind_prop)</span><br><span class="line">        bbox = (l, t, r, b)</span><br><span class="line">        img = ImageGrab.grab(bbox)</span><br><span class="line">        img_cv = cv2.cvtColor(np.asarray(img), cv2.COLOR_RGB2BGR)</span><br><span class="line">        <span class="keyword">return</span> img_cv</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 定时甩杆</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">FisherOut</span>(<span class="params">self, svtime = <span class="number">1.03</span></span>):</span><br><span class="line">        win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        time.sleep(svtime) <span class="comment"># 1.02 和 1.03 都能 max；不知道是否和钓鱼等级有关</span></span><br><span class="line">        win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 赋值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setWindowProp</span>(<span class="params">self, bbox, prop</span>):</span><br><span class="line">        self.left_top = (bbox[<span class="number">0</span>], bbox[<span class="number">1</span>])</span><br><span class="line">        self.h_width = bbox[<span class="number">2</span>] - bbox[<span class="number">0</span>]</span><br><span class="line">        self.h_height = bbox[<span class="number">3</span>] - bbox[<span class="number">1</span>]</span><br><span class="line">        self.wind_prop = prop</span><br><span class="line">        self.cha_hmid = self.left_top[<span class="number">0</span>] + self.h_width // <span class="number">2</span></span><br><span class="line">        self.cha_vmid = self.left_top[<span class="number">1</span>] + self.h_height // <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 截屏部分窗口</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">grabRangeImg</span>(<span class="params">self, bbox</span>):</span><br><span class="line">        img = ImageGrab.grab(bbox)</span><br><span class="line">        img_cv = cv2.cvtColor(np.asarray(img), cv2.COLOR_RGB2BGR)</span><br><span class="line">        <span class="keyword">return</span> img_cv</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 前期测试时截屏采样用</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">debugShot</span>(<span class="params">self, bbox, shape, nums = <span class="number">20</span></span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nums):</span><br><span class="line">            time.sleep(self.shot_t)</span><br><span class="line">            img = self.grabRangeImg(bbox)</span><br><span class="line">            <span class="keyword">if</span> shape[<span class="number">0</span>] != <span class="number">0</span>:</span><br><span class="line">                img = cv2.resize(img, dsize = shape)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;image write &quot;</span>, i)</span><br><span class="line">            cv2.imwrite(<span class="string">&quot;tmp/no&#123;&#125;.png&quot;</span>.<span class="built_in">format</span>(i), img)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 等待🐟上钩，即叹号出现</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">waitMarker</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># <span class="doctag">TODO:</span> 目前仅考虑人物位于屏幕中央，条件允许后续加上检测，如识别人物的轮廓转换为矩形区域来确定叹号区域</span></span><br><span class="line">        width = self.h_width / <span class="number">80</span></span><br><span class="line">        height = self.h_height / <span class="number">16</span></span><br><span class="line">        h_mid = self.left_top[<span class="number">0</span>] + self.h_width / <span class="number">2</span></span><br><span class="line">        v_mid = self.left_top[<span class="number">1</span>] + self.h_height / <span class="number">2</span></span><br><span class="line">        val_list = [self.cha_hmid, self.cha_vmid - height * <span class="number">2</span>, self.cha_hmid + width, self.cha_vmid - height]</span><br><span class="line">        bbox = <span class="built_in">tuple</span>(<span class="built_in">int</span>(x * self.wind_prop) <span class="keyword">for</span> x <span class="keyword">in</span> val_list)</span><br><span class="line">        <span class="comment"># self.debugShot(bbox,(60, 180))</span></span><br><span class="line">        pre = cv2.resize(self.grabRangeImg(bbox), dsize=(<span class="number">60</span>, <span class="number">180</span>))</span><br><span class="line">        timer = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            time.sleep(self.shot_t)</span><br><span class="line">            timer += self.shot_t</span><br><span class="line">            cur = cv2.resize(self.grabRangeImg(bbox), dsize=(<span class="number">60</span>, <span class="number">180</span>))</span><br><span class="line">            vared = self.imgCompare(pre, cur)</span><br><span class="line">            pre = cur</span><br><span class="line">            <span class="keyword">if</span> vared:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;fish caught!&quot;</span>)</span><br><span class="line">                time.sleep(<span class="number">0.2</span>) </span><br><span class="line">                <span class="comment"># 捕获到感叹号有时没法正确发送左击指令，可能是 python 非严格串行的原因，多执行几次得到解决</span></span><br><span class="line">                win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, <span class="built_in">int</span>(h_mid), <span class="built_in">int</span>(v_mid))</span><br><span class="line">                win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, <span class="number">0</span>, <span class="number">0</span>) </span><br><span class="line">                win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, <span class="built_in">int</span>(h_mid), <span class="built_in">int</span>(v_mid))</span><br><span class="line">                win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, <span class="built_in">int</span>(h_mid), <span class="built_in">int</span>(v_mid))</span><br><span class="line">                <span class="comment"># win32gui.SendMessage(self.whandle, win32con.WM_LBUTTONDOWN,win32con.MK_LBUTTON,win32api.MAKELONG(8,30))</span></span><br><span class="line">                time.sleep(<span class="number">0.1</span>)</span><br><span class="line">                win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">                <span class="comment"># win32gui.SendMessage(self.whandle,win32con.WM_LBUTTONUP,win32con.MK_LBUTTON,win32api.MAKELONG(8,30))</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> timer &gt; <span class="number">7.0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Wait for too long, might too large threshold&quot;</span>)</span><br><span class="line">                self.marker_thresh -= <span class="number">0.05</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> timer &lt; <span class="number">0.2</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Too fast, might occured misdetection&quot;</span>)</span><br><span class="line">            self.marker_thresh += <span class="number">0.05</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">    <span class="comment"># 用于判断是否出现叹号</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">imgCompare</span>(<span class="params">self, pre, cur</span>):</span><br><span class="line">        jv1 = varCompare(pre, cur)</span><br><span class="line">        jv2 = varCompare(pre, cur, <span class="number">1</span>)</span><br><span class="line">        jv3 = varCompare(pre, cur, <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(jv1, jv2, jv3)</span><br><span class="line">        blue = jv1 &gt; self.marker_thresh</span><br><span class="line">        green = jv2 &gt; self.marker_thresh</span><br><span class="line">        red = jv3 &gt; self.marker_thresh</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">int</span>(blue) + <span class="built_in">int</span>(green) + <span class="built_in">int</span>(red) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 追踪鱼条执行鼠标动作</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">traceBar</span>(<span class="params">self</span>):</span><br><span class="line">        fb = FishBar()</span><br><span class="line">        width = self.h_width / <span class="number">8</span></span><br><span class="line">        height = self.h_height / <span class="number">20</span></span><br><span class="line">        val_list = [self.cha_hmid - width, self.cha_vmid - <span class="number">7</span> * height, self.cha_hmid + width, self.cha_vmid + <span class="number">5</span>*height]</span><br><span class="line">        bbox = <span class="built_in">tuple</span>(<span class="built_in">int</span>(x * self.wind_prop) <span class="keyword">for</span> x <span class="keyword">in</span> val_list)</span><br><span class="line">        box_w = <span class="number">320</span></span><br><span class="line">        box_h = <span class="number">460</span></span><br><span class="line">        </span><br><span class="line">        round_ticker = <span class="number">0</span> <span class="comment"># 连续三次未捕获到符合的目标则退出该函数</span></span><br><span class="line">        smknl = cv2.getStructuringElement(cv2.MORPH_RECT, (<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">        lgknl = cv2.getStructuringElement(cv2.MORPH_RECT, (<span class="number">15</span>, <span class="number">15</span>))</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            time.sleep(self.shot_t)</span><br><span class="line">            round_ticker += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> round_ticker &gt; <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 先确定鱼</span></span><br><span class="line">            cur = cv2.resize(self.grabRangeImg(bbox),dsize=(box_w, box_h))</span><br><span class="line">            b, g, r = cv2.split(cur)</span><br><span class="line">            fish = cv2.subtract(cv2.subtract(b, r), cv2.subtract(b, g))</span><br><span class="line">            fish = cv2.threshold(fish, <span class="number">100</span>, <span class="number">255</span>, cv2.THRESH_BINARY)[<span class="number">1</span>]</span><br><span class="line">            fish = cv2.morphologyEx(fish, cv2.MORPH_OPEN, smknl)</span><br><span class="line">            fish = cv2.dilate(fish, lgknl)</span><br><span class="line">            fcons, _ = cv2.findContours(fish, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(fcons) &lt; <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Fish miss detected, need further check&quot;</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            frect = cv2.boundingRect(fcons[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> fb.inited:</span><br><span class="line">                fb.vert_mid = frect[<span class="number">0</span>] + frect[<span class="number">2</span>] // <span class="number">2</span></span><br><span class="line">                fb.inited = <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 再对比确定浮标</span></span><br><span class="line">            bina = cv2.threshold(cv2.subtract(g, r), <span class="number">50</span>, <span class="number">255</span>, cv2.THRESH_BINARY)[<span class="number">1</span>]</span><br><span class="line">            erd = cv2.erode(bina, smknl)</span><br><span class="line">            adjed = cv2.morphologyEx(erd, cv2.MORPH_CLOSE, lgknl)</span><br><span class="line">            cons, _ = cv2.findContours(adjed, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">            rect_list = []</span><br><span class="line">            <span class="keyword">for</span> (i, c) <span class="keyword">in</span> <span class="built_in">enumerate</span>(cons):</span><br><span class="line">                rect = cv2.boundingRect(c)</span><br><span class="line">                <span class="comment"># 根据位置、形状筛选</span></span><br><span class="line">                <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                if rect[2] &gt; 32 or rect[3] &gt; 200:</span></span><br><span class="line"><span class="string">                    continue</span></span><br><span class="line"><span class="string">                if (rect[0] &gt; 80 and rect[0] &lt; 240):</span></span><br><span class="line"><span class="string">                    continue</span></span><br><span class="line"><span class="string">                if rect[0] &lt; 20 or rect[0] &gt; 280:</span></span><br><span class="line"><span class="string">                    continue</span></span><br><span class="line"><span class="string">                if rect[3] &lt; rect[2] / 2 or rect[3] &lt; 32:</span></span><br><span class="line"><span class="string">                    continue</span></span><br><span class="line"><span class="string">                &quot;&quot;&quot;</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(rect[<span class="number">0</span>] - fb.vert_mid) &gt; frect[<span class="number">2</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(rect_list) == <span class="number">0</span>:</span><br><span class="line">                    rect_list.append(rect)</span><br><span class="line">                <span class="keyword">elif</span> rect_list[-<span class="number">1</span>][<span class="number">3</span>] &lt; rect[<span class="number">3</span>]:</span><br><span class="line">                    rect_list.append(rect)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(rect_list) &lt; <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;Bar miss detected, need further check&quot;</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            fb.update(rect_list[-<span class="number">1</span>], frect, self.shot_t * round_ticker)</span><br><span class="line">            round_ticker = <span class="number">0</span> <span class="comment"># 顺利更新，归 0</span></span><br><span class="line">        fb.clear()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 确定抓到🐟就左击一下收进背包，否则不用左击</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fishComfirm</span>(<span class="params">self</span>):</span><br><span class="line">        box_w = self.h_width / <span class="number">10</span></span><br><span class="line">        box_h = self.h_height / <span class="number">12</span></span><br><span class="line">        val_list = [self.cha_hmid - box_w, self.cha_vmid - <span class="number">3.5</span> * box_h, self.cha_hmid + box_w, self.cha_vmid - box_h]</span><br><span class="line">        bbox = <span class="built_in">tuple</span>(<span class="built_in">int</span>(x * self.wind_prop) <span class="keyword">for</span> x <span class="keyword">in</span> val_list)</span><br><span class="line">        img = self.grabRangeImg(bbox)</span><br><span class="line">        knl = cv2.getStructuringElement(cv2.MORPH_RECT, (<span class="number">15</span>, <span class="number">15</span>))</span><br><span class="line">        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">        bing = cv2.threshold(gray, <span class="number">230</span>, <span class="number">255</span>, cv2.THRESH_BINARY)[<span class="number">1</span>]</span><br><span class="line">        res = cv2.dilate(bing, knl)</span><br><span class="line">        cons, _ = cv2.findContours(res, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(cons) &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        rects = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> cons:</span><br><span class="line">            rect = cv2.boundingRect(c)</span><br><span class="line">            sur = rect[<span class="number">2</span>] * rect[<span class="number">3</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(rects) &lt; <span class="number">1</span>:</span><br><span class="line">                rects.append(rect)</span><br><span class="line">            <span class="keyword">elif</span> rects[-<span class="number">1</span>][<span class="number">2</span>] * rects[-<span class="number">1</span>][<span class="number">3</span>] &lt; sur:</span><br><span class="line">                rects.append(rect)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> rects[-<span class="number">1</span>][<span class="number">2</span>] * rects[-<span class="number">1</span>][<span class="number">3</span>] * <span class="number">2</span> &gt; img.shape[<span class="number">0</span>] * img.shape[<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">loop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Start one loop&quot;</span>)</span><br><span class="line">            self.FisherOut()</span><br><span class="line">            time.sleep(<span class="number">1.5</span>) <span class="comment"># 完成下杆</span></span><br><span class="line">            caught = self.waitMarker()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> caught:</span><br><span class="line">                self.FisherOut(<span class="number">0.01</span>)</span><br><span class="line">                time.sleep(<span class="number">1.5</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            time.sleep(<span class="number">1.2</span>) <span class="comment"># 进入浮标控制</span></span><br><span class="line">            self.traceBar()</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            confirmed = self.fishComfirm()</span><br><span class="line">            <span class="keyword">if</span> confirmed:</span><br><span class="line">                <span class="comment"># 这个函数只是定时左击，所以写在这里代替了</span></span><br><span class="line">                self.FisherOut(<span class="number">0.01</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Finish one loop&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">work</span>(<span class="params">self</span>):</span><br><span class="line">        hsv = win32gui.FindWindow(<span class="string">&quot;SDL_app&quot;</span>, <span class="string">&quot;Stardew Valley&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> hsv == <span class="number">0</span>:</span><br><span class="line">            win32api.MessageBeep()</span><br><span class="line">            ret = win32api.MessageBox(<span class="number">0</span>, <span class="string">&quot;未找到运行中的窗口，请打开游戏再运行此脚本&quot;</span>, <span class="string">&quot;注意&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> ret == <span class="number">1</span>:</span><br><span class="line">                sys.exit(<span class="number">0</span>)</span><br><span class="line">        self.whandle = hsv</span><br><span class="line">        self.activateWnd(hsv)</span><br><span class="line">        <span class="comment"># <span class="doctag">TODO:</span> 可以加上按键终止、启动循环</span></span><br><span class="line">        self.loop()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    fs = FishingScript()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Object created&quot;</span>)</span><br><span class="line">    fs.work()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">other</span>():</span><br><span class="line">    imglist = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">        imglist.append(cv2.imread(<span class="string">&quot;tmp/no&#123;&#125;.png&quot;</span>.<span class="built_in">format</span>(j)))</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="死亡细胞自动格挡脚本"><a href="#死亡细胞自动格挡脚本" class="headerlink" title="死亡细胞自动格挡脚本"></a>死亡细胞自动格挡脚本</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;基于 opencv、pillow、pywin 来捕获图像并模拟按键操作&lt;/p&gt;
&lt;h2 id=&quot;星露谷物语钓鱼脚本&quot;&gt;&lt;a href=&quot;#星露谷物语钓鱼脚本&quot; class=&quot;headerlink&quot; title=&quot;星露谷物语钓鱼脚本&quot;&gt;&lt;/a&gt;星露谷物语钓鱼脚本&lt;/h2&gt;&lt;p</summary>
      
    
    
    
    <category term="Python" scheme="http://remedios14.github.io/categories/Python/"/>
    
    
    <category term="game-script" scheme="http://remedios14.github.io/tags/game-script/"/>
    
  </entry>
  
  <entry>
    <title>Cpp环境配置及编译流程</title>
    <link href="http://remedios14.github.io/2022/06/04/C++/Cpp%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/"/>
    <id>http://remedios14.github.io/2022/06/04/C++/Cpp%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/</id>
    <published>2022-06-04T13:03:07.000Z</published>
    <updated>2022-06-07T13:13:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><del>虽然个人目前未接触过很多 c++ 工程，不懂多少编译手段，但是先在此记录能起步使用程度的知识，并祈祷今后会不断增加</del></p><h2 id="Windows-环境"><a href="#Windows-环境" class="headerlink" title="Windows 环境"></a>Windows 环境</h2><ul><li>编辑器随意选择，使用习惯的即可，或者 VSCode 比较优秀</li><li>编译器通常使用 mingw 完成单文件编译，配合 cmake 完成多文件编译，具体安装教程很多</li></ul><p><a href="https://zhuanlan.zhihu.com/p/401188789">编辑环境配置及三方库安装</a></p><p>一般安装第三方库时先使用 MSYS 的命令检索 <code>pacman -Ss keywords</code> 找到之后根据操作系统对应的编译器来选择安装，Windows 下为 mingw64，在其子环境下安装 cmake 使用 <code>pacman -S mingw-w64-x86_64-cmake</code></p><p><strong>补充</strong> ：使用 msys 安装的外部库在 VSC 中不能立刻看到代码提示，此时需要 ctrl+shift+p 搜索 “edit configuration” 编辑 C/C++ 的配置，在其 <code>includePath</code> 条目下追加上 <code>**/msys64/mingw64/include</code> 具体目录视自身情况修改，大致是这个位置</p><h3 id="g-编译"><a href="#g-编译" class="headerlink" title="g++ 编译"></a>g++ 编译</h3><p>mingw64 内置 g++ / gcc 等，通常编译 c++ 程序使用 g++ 即可；其中 <code>-g</code> 参数会后续生成调试信息，进行调试前需要编辑 launch.json 和 tasks.json，若无调试需求可以不加这个参数</p><ul><li>编译单文件，生成带调试信息的可执行文件、并调试</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -g main.cpp -o my_single_swap</span><br></pre></td></tr></table></figure><ul><li>编译多文件，生成带调试信息的可执行文件、并调试；（不推荐，需要把所有文件都加入）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -g main.cpp swap.cpp -o my_multi_swap</span><br></pre></td></tr></table></figure><h3 id="cmake-编译"><a href="#cmake-编译" class="headerlink" title="cmake 编译"></a>cmake 编译</h3><p>ctrl + shift + P 输入 cmake 来指定 GCC 编译器，可以基于工作区文件生成 CMakeLists.txt（或者自行先编写好）</p><ol><li><p>编写 CMakeLists.txt 写入必要信息</p></li><li><p>工程项目下执行指令将完成 cmake 编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -G &quot;MinGW Makefiles&quot; ..</span><br><span class="line">mingw32-make.exe</span><br></pre></td></tr></table></figure></li></ol><h4 id="cmakelists-文件编写"><a href="#cmakelists-文件编写" class="headerlink" title="cmakelists 文件编写"></a>cmakelists 文件编写</h4><p><a href="https://www.jianshu.com/p/2bdcd7d7b164">参考文档</a></p><p>通常子目录都可以编写 cmakelists 生成一个 lib 然后在父目录内添加</p><ul><li>一般的例子：<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.2)</span><br></pre></td></tr></table></figure></li></ul><h3 id="调试工作的配置"><a href="#调试工作的配置" class="headerlink" title="调试工作的配置"></a>调试工作的配置</h3><p>调试工作是由 VSCode 读取调试信息和调试配置完成的，其中调试信息由编译器在编译中处理并储存，我们则需要需改调试配置</p><p>VSCode 上可以直接找到调试栏 “创建 launch.json 文件” 来快捷完成</p><p>关键点要将 “program” 属性定位到编译完成的 <code>*.exe</code> 文件</p><ul><li>tasks.json 用于指定在 debug 前的 build 工作，如果子集完成编译和调试信息则无需该文件</li></ul><h2 id="Visual-Studio-的项目配置"><a href="#Visual-Studio-的项目配置" class="headerlink" title="Visual Studio 的项目配置"></a>Visual Studio 的项目配置</h2><p>以 SDL2 为例，<a href="https://blog.csdn.net/m0_37872216/article/details/124545623">参考博客</a></p><ol><li>修改工程的 VC++-&gt;包含目录和库目录；</li><li>修改 链接器-&gt;输入-&gt;附加依赖项-&gt;追加 <code>.lib</code></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;del&gt;虽然个人目前未接触过很多 c++ 工程，不懂多少编译手段，但是先在此记录能起步使用程度的知识，并祈祷今后会不断增加&lt;/del&gt;&lt;/p&gt;
&lt;h2 id=&quot;Windows-环境&quot;&gt;&lt;a href=&quot;#Windows-环境&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="Cpp" scheme="http://remedios14.github.io/categories/Cpp/"/>
    
    
    <category term="cpp" scheme="http://remedios14.github.io/tags/cpp/"/>
    
    <category term="pre-tasks" scheme="http://remedios14.github.io/tags/pre-tasks/"/>
    
  </entry>
  
  <entry>
    <title>Games101-计算机图形学（六）</title>
    <link href="http://remedios14.github.io/2022/06/04/Games/101%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <id>http://remedios14.github.io/2022/06/04/Games/101%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E5%85%AD%EF%BC%89/</id>
    <published>2022-06-04T02:50:20.000Z</published>
    <updated>2022-06-26T15:19:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://www.bilibili.com/video/BV1X7411F744?p=1&amp;spm_id_from=pageDriver">博客图片及学习路径来源 Gamse 101课程，在此记录以方便个人查阅为主，强烈建议自行观看学习</a></strong></p><h2 id="Animation-Simulation"><a href="#Animation-Simulation" class="headerlink" title="Animation / Simulation"></a>Animation / Simulation</h2><p>历史；关键帧动画；物理仿真；运动学 Kinematics；Rigging</p><ul><li>fps ：frames per second；通常电影 24 就足够，一般的视频 30；往上游戏、虚拟现实等要求才高起来</li><li>关键帧动画 Keyframe Animation：连续动作的“转折点”，关键帧之间的内容可以<strong>使用插值</strong>填充过程，当然不是简单的线性插值<ul><li>为了符合平滑的运动，至少要加上 连续性、样条 等约束</li></ul></li><li>物理仿真 Physical Simulation ：即通过模拟力在每个点上的作用和碰撞检测来仿真现实物理效果<ul><li>质点弹簧系统 Mass Spring System ：见下段落</li><li>有限元分析 Finite Element Method (FEM) ：可以代替弹簧系统实现模拟</li></ul></li><li>粒子系统 Particle Systems ：用众多粒子建模并模拟粒子受到的力和粒子间的相互力；也算物理仿真的一部分，要考虑的力有：<ul><li>关联力：引力、斥力、电磁力、弹性力等；Damping 力：摩擦力、空气阻力等；碰撞作用力：与场景或其他粒子<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">For each frame in animation</span><br><span class="line">[if needed] Create new particles</span><br><span class="line">Calculate forces on each particle</span><br><span class="line">Update each particle&#x27;s position and velocity</span><br><span class="line">[if needed] Remove dead particles</span><br><span class="line">Render particles</span><br></pre></td></tr></table></figure></li></ul></li><li>Rigging ：相当于在网格模型上设立关键的操控点，以及执行相应控制后对其它部位的影响和约束；例如完成提线木偶的控制、人物表情的变化、细微动作的实现<ul><li>动作捕捉 Motion Capture ：基于前者的逆向想法，真人携带控制点来执行动作，反馈给虚拟模型完成模拟；现有更广泛使用的方法还是 光学动作捕捉</li></ul></li></ul><h3 id="运动学-Kinematics"><a href="#运动学-Kinematics" class="headerlink" title="运动学 Kinematics"></a>运动学 Kinematics</h3><p>类比一个基础的骨架结构，运动学模型需要进行几个基本定义：</p><ol><li>拓扑结构 ；即各个组件（组件有长度并附带关节）之间的连接关系</li><li>关节处的几何关系 ：例如三维中用两个角度描述，其坐标系基于关节的父组件</li><li>树状结构 ：组件之间的层级构成树结构，避免成环</li></ol><ul><li>正向运动学 Forward Kinematics ：即通过每个关节的运动情况描述整体模型的运动<ul><li>优点 ：关节的描述很容易，且计算渐变</li><li>缺点 ：使用数值输入而非视觉确定，不方便设计</li></ul></li><li>逆向运动学 Inverse Kinematics ：可理解为主观控制组件的端点位置，求解各个组件的适当位置<ul><li>存在多解或误解情况，无直接求解方法，采用优化方法来调整</li></ul></li></ul><h3 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h3><h4 id="质点弹簧系统"><a href="#质点弹簧系统" class="headerlink" title="质点弹簧系统"></a>质点弹簧系统</h4><ul><li><strong>单个弹簧</strong></li></ul><p>考虑一个简单的 a,b 端点弹簧，具有自然长度 l 称为 rest length，其拉伸作用力</p><script type="math/tex; mode=display">f_{a\rightarrow b} = k_s\frac{b-a}{||b-a||}(||b-a||-l)</script><p>然而弹簧显然是不会“永动”的，因此要引入能量损耗，也即摩擦力</p><p><img src="/images/CG/Internal-Damping-for-Spring.png" alt="弹簧内部作用力"></p><p>其中 $\dot{b}$ 表示 位置 b 点的导数，也即 b 端点的速度</p><ul><li><strong>弹簧网格</strong></li></ul><p>仅完成单个弹簧的力显然不足以模拟物理效果，甚至连一块平面布都模拟不了：</p><ol><li>考虑屏幕上的方形弹簧网格，则其无法抵抗对角线上同时向外的切边力，也无法模拟沿对角线翻折的旋转力 —— 每个小方格都连接两个对角线</li><li>到上一步仍无法沿模拟水平、竖直方向的翻折，在此基础上增加横竖方向上端点的单步跳跃连接 “skip connection” —— 至此的弹簧系统能不错地模拟布匹的效果了</li></ol><h3 id="动画生产流程"><a href="#动画生产流程" class="headerlink" title="动画生产流程"></a>动画生产流程</h3><p><img src="/images/CG/The-Production-Pipline.png" alt="蛮有趣的"></p><p>但是实时渲染太牛啦，直接统括了很多流程</p><h2 id="求解方法"><a href="#求解方法" class="headerlink" title="求解方法"></a>求解方法</h2><h3 id="粒子运动的求解"><a href="#粒子运动的求解" class="headerlink" title="粒子运动的求解"></a>粒子运动的求解</h3><p>先考虑单个粒子在一个速度场内的运动，速度场可以由 v(x, t) 表述，因此建立了一个常微分方程 Ordinary Differential Equation</p><script type="math/tex; mode=display">\frac{dx}{dt}=\dot{x}=v(x, t)</script><ul><li>欧拉方法 Euler Method ：引入一个很小的 Δt 的微分来计算下一时刻的位置，有不稳定等诸多问题，且对很多场景没有正确的解</li><li>中点法 Midpoint Method ：基于欧拉法略微优化，实践有更好的效果<ol><li>在 Δt 下计算出单步的下一个点 a ，取到 a 的中点 b</li><li>以速度场在中点的速度作为当前点速度计算 Δt 后的位置</li><li>公式 $x(t+\Delta t=x(t)+\Delta t \cdot v(x_{mid}, t$</li></ol><ul><li>Adaptive Step Size 自适应步长 ：比较当前步长 Δt 下欧拉法结果和执行两次 Δt/2 的欧拉法结果的差异，若足够小就采用中点法，否则步长折半</li></ul></li><li>隐式欧拉法 Implicit Euler Method ：见下段落</li><li>龙格库塔法 Runge-Kutta Methods ：使用典型的四阶方法求解</li></ul><p>欧拉法会能量自增，隐式欧拉法会能量衰减；综合后有<strong>半隐式欧拉</strong></p><h4 id="隐式欧拉法"><a href="#隐式欧拉法" class="headerlink" title="隐式欧拉法"></a>隐式欧拉法</h4><p>相比于显式欧拉法用 t 时刻的微分推导 t+Δt 时刻，隐式欧拉法采用向后差商</p><script type="math/tex; mode=display">\dot{x}(t+\Delta t) = \frac{x(t+\Delta t) - x(t)}{\Delta t}</script><p>代入微分方程导数项得到 </p><script type="math/tex; mode=display">x(t+\Delta t) = x(t) + \Delta t v(x(t + \Delta t), t + \Delta t)</script><p>然后解方程得到下一步结果</p><ul><li>隐式欧拉法还有一个改进方法，其使用近似的积分形式来建立下一时刻的值方程</li></ul><h4 id="龙格库塔法"><a href="#龙格库塔法" class="headerlink" title="龙格库塔法"></a>龙格库塔法</h4><p>同样已知初值 $\dot{x} = v(x, t), \space x(t_0)=x_0$</p><p>经典四阶方法 RK4 由如下方程给出</p><script type="math/tex; mode=display">x_{t+dt} = x_t + \frac{dt}{6}(k_1 + 2k_2 +2k_3 +k_4)</script><p>描述了下一步的值由当前值、间隔 dt 和一个估算的斜率确定；其中</p><ul><li>$k_1 = v(x_t, t)$ 是片段起始的斜率</li><li>$k_2=v(x_t+\frac{dt}{2}k_1, t+\frac{dt}{2})$ 是片段中点的斜率，通过欧拉法采用 k1 来确定</li><li>$k_3=v(x_t+\frac{dt}{2}k_2, t+\frac{dt}{2})$ 也是中点斜率，但是通过欧拉法采用 k2 来确定</li><li>$k_4=v(x_t+dt \dot k_3, t + dt)$ 是片段终点的斜率，用 k3 确定</li></ul><p>该方法是四阶的，单步误差 O(dt^2) ，总误差 O(dt)</p><hr><ul><li>Position-Based / Verlet Integration ：给出一些约束来限制属性，会直接违背物理系统，但是用于保持稳定</li></ul><h3 id="刚体模拟-Rigid-Body-Simulation"><a href="#刚体模拟-Rigid-Body-Simulation" class="headerlink" title="刚体模拟 Rigid Body Simulation"></a>刚体模拟 Rigid Body Simulation</h3><p>刚体即视为内部点相对位置绝对不变的 “大粒子”，相对于粒子运动，其多考虑两个维度，即朝向角和角速度（旋转相关）</p><p><img src="/images/CG/Rigid-Body-Simulation.png" alt="刚体模拟"></p><h3 id="流体模拟-Fluid-Simulation"><a href="#流体模拟-Fluid-Simulation" class="headerlink" title="流体模拟 Fluid Simulation"></a>流体模拟 Fluid Simulation</h3><ul><li>核心想法：<ul><li>假定流体是由很多刚体小球构成的</li><li>假定流体在任何位置都是不可压缩的</li></ul></li></ul><p>此时为了模拟流体的运动，即引入 Verlet Integration，通过给出密度的约束，检测空间各位置上小球的密度，总是执行运动使其保持常数水平</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>作业框架没搞定，实现几个弹簧作用力很简单，有机会再补充</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1X7411F744?p=1&amp;amp;spm_id_from=pageDriver&quot;&gt;博客图片及学习路径来源 Gamse 101课程，在此记录以方便个人查阅为主，强烈建议自行</summary>
      
    
    
    
    <category term="Games-Graphics" scheme="http://remedios14.github.io/categories/Games-Graphics/"/>
    
    
    <category term="games" scheme="http://remedios14.github.io/tags/games/"/>
    
    <category term="计算机图形学" scheme="http://remedios14.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Games101-计算机图形学（五）</title>
    <link href="http://remedios14.github.io/2022/06/02/Games/101%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://remedios14.github.io/2022/06/02/Games/101%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E4%BA%94%EF%BC%89/</id>
    <published>2022-06-02T11:42:48.000Z</published>
    <updated>2022-06-26T15:19:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://www.bilibili.com/video/BV1X7411F744?p=1&amp;spm_id_from=pageDriver">博客图片及学习路径来源 Gamse 101课程，在此记录以方便个人查阅为主，强烈建议自行观看学习</a></strong></p><h2 id="Materials-and-Apperances-材质与外观"><a href="#Materials-and-Apperances-材质与外观" class="headerlink" title="Materials and Apperances 材质与外观"></a>Materials and Apperances 材质与外观</h2><p>对于一个材质，到现在已经接触过的与其关联的属性有</p><ul><li>渲染方程中的 BRDF，即已知 “入射、出射、法向” 的条件下计算出反射量的系数（镜面反射略，仅需考虑角度计算和吸收率即可实现）；<ul><li>考虑完全的漫反射，则对任一角度的入射光线，其都会向半球面均匀地反射，反过来即是说，对任一出射角度，其输出都是由半球面上的入射光线均匀地反射贡献的；将 f_r 视作常数提出积分式</li><li>考虑能量守恒，出射的总 irradiance 不会大于入射的，仅在完全反射（如白色表面）时相等；因此变换积分式如下<br><img src="/images/CG/Diffuse-Lambertian-Material.png" alt="漫反射材质"></li><li>结论即 f_r 在 [0, 1/Π] 中取值</li></ul></li><li>材质表面发生的光线折射，需要定义出入介质的折射率 η，$\eta_i sin\theta_i=\eta_t sin\theta_t$，使用时通常计算 $cos\theta_t$，存在一些情况下无解，即全反射情形</li><li>菲涅尔项 Fresnel Term ：描述不同的入射角度下不同材质对光线的反射水平，已经有完整的计算公式，以及 Schlick 近似<br><img src="/images/CG/Fresnel-Term-Formula.png" alt="F菲涅尔项公式及其近似"></li></ul><h3 id="微表面理论-Microfacet-Theory"><a href="#微表面理论-Microfacet-Theory" class="headerlink" title="微表面理论 Microfacet Theory"></a>微表面理论 Microfacet Theory</h3><p>认为根据视角远近观察一个表面有不同的效果：</p><ul><li>远处观察：表面可视作一个平面，具有粗糙不均匀的材质；表面的每个微元上进行完全的镜面反射</li><li>近处观察：可以看到表面上完整的几何形状，即构成曲面</li></ul><p>微表面理论将凹凸不平的表面近似成平面，该平面的法向视作所有凹凸镜面的法向的综合，即在一定范围内变动（变动范围视具体表面的凹凸水平），在此基础上构建材质的 BRDF，其中中间项 G 描述了凹凸块互相遮挡的情况，在入射光较水平时作用显著<br><img src="/images/CG/Microfacet-BRDF.png" alt="微表面 BRDF"></p><h3 id="各向异性-BRDF"><a href="#各向异性-BRDF" class="headerlink" title="各向异性 BRDF"></a>各向异性 BRDF</h3><p>回顾空间中的极坐标表示，其有两个角度 φ 和 θ 分别表示与 x 正向和 y 正向的夹角；</p><p>当一个材质的 BRDF 随 φ 的变化而不同时，称为<strong>各向异性</strong> —— 现实例子有各种金属表面形成辐射状的高光</p><p>在渲染实现上：</p><ul><li>各向同性通常构成有聚散的高光</li><li>各向异性通常构成条状分布的高光</li></ul><h3 id="BRDF-的性质"><a href="#BRDF-的性质" class="headerlink" title="BRDF 的性质"></a>BRDF 的性质</h3><ol><li>非负性</li><li>线性性：可随材质线性组合？</li><li>可逆性：入射和出射方向对换时保持值不变</li><li>能量守恒：文首给出的取值范围</li></ol><h3 id="测量-BRDF"><a href="#测量-BRDF" class="headerlink" title="测量 BRDF"></a>测量 BRDF</h3><p>使用固定光入射，从不同角度观察采集，然后通过角度关系来生成所有角度下的值情况；</p><p>现有可调库使用</p><h2 id="Advanced-Topics-in-Rendering"><a href="#Advanced-Topics-in-Rendering" class="headerlink" title="Advanced Topics in Rendering"></a>Advanced Topics in Rendering</h2><p>介绍为主</p><h3 id="Advanced-Light-Transport"><a href="#Advanced-Light-Transport" class="headerlink" title="Advanced Light Transport"></a>Advanced Light Transport</h3><h4 id="无偏的光线传播方法"><a href="#无偏的光线传播方法" class="headerlink" title="无偏的光线传播方法"></a>无偏的光线传播方法</h4><ul><li>双向路径追踪 Bidirectional Path Tracing (BDPT) ：思想即从光源和相机都打出 ray ，相连时渲染成像<ul><li>已经是非常牛的算法了，只要能够实现，就足以自制渲染器</li></ul></li><li>Metropolis Light Transport (MLT) ：已知一条正确光路后使用随机扰动来生成其他光路；在困难的渲染任务中效果尤佳</li></ul><h4 id="有偏的方法"><a href="#有偏的方法" class="headerlink" title="有偏的方法"></a>有偏的方法</h4><ul><li>Photon Mapping ：能很好地实现 caustics 效果，做法大致是从光源发射光子，正确地经过折射和镜面反射，直到漫反射表面上，然后在该表面上进行密度估计来着色<ul><li>密度估计：现有做法是固定一个光子数 N ，在着色点周围找面积 A 内含该数量的光子，以此估计密度，结果是<strong>有偏的，但一致的</strong>；若固定面积记光子数，则结果不是一致的</li></ul></li><li>Vertex Connection and Merging (VCM) ：结合 BDPT 和 Photon Mapping 的方法，即双向路径中部分没有连接上但是落到相近位置的子路径，将其视作光子来密度估计，最终完成着色</li></ul><h4 id="实时辐射度算法-Instant-Radiosity"><a href="#实时辐射度算法-Instant-Radiosity" class="headerlink" title="实时辐射度算法 Instant Radiosity"></a>实时辐射度算法 Instant Radiosity</h4><p>整体思路是将直接光源照射到的点视作虚拟的光源 Virtual Point Light ，后续有很多研究</p><h3 id="Advanced-Appearance-Modeling"><a href="#Advanced-Appearance-Modeling" class="headerlink" title="Advanced Appearance Modeling"></a>Advanced Appearance Modeling</h3><h4 id="Non-surface-Models"><a href="#Non-surface-Models" class="headerlink" title="Non-surface Models"></a>Non-surface Models</h4><ul><li>Participating media ：散射介质<ul><li>光线在介质传播过程中，被吸收或者散射，其中吸收部分使用系数即可</li><li>散射部分在介质内进行多次得到一条路径上多个着色点，然后都与光源连接并综合即得到单条路径在屏幕上的成像</li><li>例子如 烟雾效果，浓烟即吸收的多，散射的少；大多数物体都能作为散射介质，如各种流体</li></ul></li><li>Hair / fur / fiber (BCSDF) ：非常遗憾的，这几种材质的光作用效果并不完全相同<ul><li>头发通常视作玻璃柱体，接收到光线 部分反射，部分折射进入内壁再反射出来 … Marschner model 现有的已经取得很好头发渲染效果的模型，贴合现实</li><li>动物毛发相比人类头发有更大的髓质，因此相当于双层玻璃管，针对此构建了 Double Cylinder Model，反过来也能用到头发上；模型中带 s 表示穿过髓质发生散射的部分<br><img src="/images/CG/Double-Cylinder-Model.png" alt="双圆柱模型"></li></ul></li><li>Granular material ：粒状堆积的材料</li></ul><h4 id="Surface-Models"><a href="#Surface-Models" class="headerlink" title="Surface Models"></a>Surface Models</h4><ul><li>Translucent material (BSSRDF) 如玉石等接近半透明的材质，光线从某个点进入材质，在内部发生大量散射，最终离开材质 —— 称为 <strong>次表面散射</strong> BSSRDF<ul><li>Dipole Approximation，实际上没搞定这种效果，用材质表面的内外两个点光源近似实现的观察效果</li></ul></li><li>Cloth 由一系列缠绕形成的 Fibers -&gt; Plys -&gt; Yarn -&gt; Cloth ；暴力的将某个层级的单位视作玻璃主题进行渲染，使用越原始层级则越复杂</li><li>Detailed material (non-statistical BRDF) ：即微表面上的凹凸效果渲染，神了</li><li>Wave Optics 波动光学，更细微到将光线细分到波 …</li></ul><h4 id="Procedural-Appearance"><a href="#Procedural-Appearance" class="headerlink" title="Procedural Appearance"></a>Procedural Appearance</h4><p>使用噪声来对空间中任意的坐标点定义纹理，完成视觉效果</p><h2 id="Cameras-Lenses-and-Light-Fields"><a href="#Cameras-Lenses-and-Light-Fields" class="headerlink" title="Cameras, Lenses and Light Fields"></a>Cameras, Lenses and Light Fields</h2><p>相机、透镜和光场</p><h3 id="摄像机原理"><a href="#摄像机原理" class="headerlink" title="摄像机原理"></a>摄像机原理</h3><p>之前介绍的图形学上成像方法都是合成方法，光栅化和光线追踪都是将虚拟的由 坐标、关系、属性 定义的空间物体经过物理模拟算法变换到成像平面上的结果</p><p>这里大致介绍一下现实中的摄像机原理，以助理解</p><h4 id="Field-of-View"><a href="#Field-of-View" class="headerlink" title="Field of View"></a>Field of View</h4><p>相比于光栅化中提及的，摄像机的外物和成像平面在透镜两侧，先穿过透镜完成倒立的画面</p><h4 id="Exposure-曝光"><a href="#Exposure-曝光" class="headerlink" title="Exposure 曝光"></a>Exposure 曝光</h4><p>Exposure = time × irradiance</p><p>相机上有 快门 等来从时间上控制曝光量</p><h4 id="透镜和焦点"><a href="#透镜和焦点" class="headerlink" title="透镜和焦点"></a>透镜和焦点</h4><p>高中物理知识；平行光过焦点、过焦点光会平行</p><h4 id="Light-Field-Lumigraph"><a href="#Light-Field-Lumigraph" class="headerlink" title="Light Field / Lumigraph"></a>Light Field / Lumigraph</h4><p>在一个三维极坐标系下记录每一个角度 (θ, φ) 下看到的光即得到个体的视觉世界，在此基础上增加时间维度形成动画，后续也可以追加其他可视点作为视角位置进行拓展，由此构成了 <strong>全光函数</strong> ：$P(\theta, \phi, V_x, V_y, V_z)$</p><p>光场 ：描述了在任意一个位置向任意一个方向的光强度，是全光函数的一部分；光场即一个四维函数，方便表述观察某个点的光效果</p><p>对于这个四维函数，可以由两个前后平行平面上的两个点确定，因此也可以理解客观世界在平面 2 后方，观测者在平面 1 前方，透过 1 观察 2 的效果</p><p>昆虫复眼的成像原理就像光场一样，每一个复眼的单位视作平面 2 和 1 的组合，将观察外部得到的光线方向记录下来</p><h2 id="Color-and-Perception"><a href="#Color-and-Perception" class="headerlink" title="Color and Perception"></a>Color and Perception</h2><ul><li>Spectrum 光谱：是复色光经过色散系统（如棱镜、光栅）分光后，被色散开的单色光按波长（或频率）大小而依次排列的图案，全称为光学频谱</li><li>Spectral Power Distribution 谱功率密度 (SPD) ：描述光在单位波长的分布情况，具有线性叠加的性质</li></ul><p>颜色源自于人的感知，而非光的一般性质：</p><ol><li>光线的光谱进入人眼到达视网膜<ul><li>光谱视作与波长有关的函数</li></ul></li><li>视网膜上三种细胞感受到光谱<ul><li>每种细胞对光谱的接受度不一样，同样是与波长有关的函数，根据其分布分为 S、M、L 分别对 短、中、长 波长强接受</li></ul></li><li>三种细胞综合处理将结果传给大脑 （处理可以理解为积分运算）</li></ol><h3 id="Metamerism-同色异谱"><a href="#Metamerism-同色异谱" class="headerlink" title="Metamerism 同色异谱"></a>Metamerism 同色异谱</h3><p>使用不同的光谱调配出相同的颜色结果</p><p>认为地定义三个分布函数去模拟上述地 S、M、L 细胞的组合，可以自行构建颜色空间</p><h3 id="颜色空间"><a href="#颜色空间" class="headerlink" title="颜色空间"></a>颜色空间</h3><p>加色系统</p><ul><li>HSV (Hue-Saturation-Value) ：色调、饱和度、值 的三维组合</li><li>CIELAB 空间：使用 亮度加上两队互补色</li></ul><p>减色系统</p><ul><li>CMYK</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1X7411F744?p=1&amp;amp;spm_id_from=pageDriver&quot;&gt;博客图片及学习路径来源 Gamse 101课程，在此记录以方便个人查阅为主，强烈建议自行</summary>
      
    
    
    
    <category term="Games-Graphics" scheme="http://remedios14.github.io/categories/Games-Graphics/"/>
    
    
    <category term="games" scheme="http://remedios14.github.io/tags/games/"/>
    
    <category term="计算机图形学" scheme="http://remedios14.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Games101-计算机图形学（四）</title>
    <link href="http://remedios14.github.io/2022/05/31/Games/101%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://remedios14.github.io/2022/05/31/Games/101%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E5%9B%9B%EF%BC%89/</id>
    <published>2022-05-31T05:52:31.000Z</published>
    <updated>2022-06-26T15:19:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://www.bilibili.com/video/BV1X7411F744?p=1&amp;spm_id_from=pageDriver">博客图片及学习路径来源 Gamse 101课程，在此记录以方便个人查阅为主，强烈建议自行观看学习</a></strong></p><p>光线追踪是类比光栅化的另一种成像方式，主要为了解决光栅化的问题：软阴影、光线的多次反射效果；其实现效果比光栅化更佳，但相应的效率更低</p><p>在图形学中几个关于光线的假设（非现实物理）：</p><ol><li>光线仅直线运动</li><li>光线交叉时不会互相影响</li><li>光线从光源处运动到视野点（光路可逆）</li></ol><p>回顾光栅化模型中的阴影生成方法 —— 由点光源确定可见点的深度，然后对相机可见点逆投射去检查是否有阴影 —— 光线追踪则从视野点穿过成像平面得到可见点，然后去检查该点对光源的可见性，以此来确定着色</p><h2 id="Whitted-Style-Ray-Tracing"><a href="#Whitted-Style-Ray-Tracing" class="headerlink" title="Whitted-Style Ray Tracing"></a>Whitted-Style Ray Tracing</h2><p>一个现代使用的递归式光线追踪方法，视线穿过物体时若可以折射则执行之，最终将所有同一条视线的可见点的着色效果累加得到成像平面上的像素点效果</p><p><img src="/images/CG/Whitted-Style-Ray-Tracing.png" alt=""></p><p>在此模型下有几个关键的技术问题要解决</p><h3 id="光线与物体的交点"><a href="#光线与物体的交点" class="headerlink" title="光线与物体的交点"></a>光线与物体的交点</h3><p>数学上认为光线是一条射线，从光源处出发，因此其表达式写为</p><script type="math/tex; mode=display">\mathbf{r} (t)=\mathbf{o} + t\mathbf{d} , \space 0 \leq t \lt \infty</script><p>考虑光线与不同的物体交点的计算：</p><ul><li>球面：即到达某个点 c 的距离为 R，将光线上点的表达式代入即可得到方程来求解 t；根据解的个数判断光线与球的相交模式<script type="math/tex; mode=display">\mathbf{d} \cdot \mathbf{d} *t^2 + 2(\mathbf{o}-\mathbf{c})\cdot \mathbf{d}*t + (\mathbf{o}-\mathbf{c})\cdot(\mathbf{o}-\mathbf{c})-\mathbf{R}^2=0</script><ul><li>一般性的隐式表面都可以通过表达式求解来得到交点的 t</li></ul></li><li>显式表面，转为判断光线和三角形求交，进而先转为光线对平面求交，然后判断是否在三角形内，而一个显式平面可以由一个法向量 N 和平面上任意一个点 p’ 确定，最终相应的表达式及求解的方程为<script type="math/tex; mode=display">\begin{align} \mathbf{p}:(\mathbf{p}-\mathbf{p}')\cdot\mathbf{N}=0 \\(\mathbf{o}+t\mathbf{d}-\mathbf{p}')  \cdot\mathbf{N}=0\end{align}</script></li><li><strong>Moller-Trumbore</strong> 算法 ：而针对三角形求交还有一个更快的方法，借助重心坐标表示来求出重心坐标的三个系数，只要三个系数均为正则交点在三角形内</li></ul><p><img src="/images/CG/Moller-Trumbore-Algorithm.png" alt=""></p><p>然而实际操作中，模型表面有巨量的三角形，更何况场景中有很多物体，且成像平面也有众多像素点，若逐一运算判断交点效率太低，因此需要加速方法</p><h3 id="Acceleration-Ray-Surface-Intersection"><a href="#Acceleration-Ray-Surface-Intersection" class="headerlink" title="Acceleration Ray-Surface Intersection"></a>Acceleration Ray-Surface Intersection</h3><p>考虑一个三角形的包围盒，通常取用轴对齐的长方体来包围，当光线不与长方体相交时，显然不会与三角形相交</p><ul><li>轴对齐包围盒 ：Axis-Aligned Bounding Box 即每个边都和一个轴共线构成的长方体包围盒</li></ul><p>为了判断光线是否进入包围盒，先将包围盒视为三组对立平行平面，则每一组平面都可以很容易计算出进入和离开的 t （直觉上可以看作时间），当最大的进入时间小于最小的离开时间即可知光线进入包围盒，当离开时间有负值则不可能进入包围盒</p><h4 id="空间划分"><a href="#空间划分" class="headerlink" title="空间划分"></a>空间划分</h4><p>既然使用 AABB 能很方便地判断光线是否进入，那很自然地会想到用更多的包围盒来跟随一条光线，只需要处理光线经过的包围盒，判断其内部是否有光物相交；基于此想法先产生了对空间均等划分的思想，为了平衡效率在三维上经验性地取 <code>物体数\*27</code> 的均等划分</p><ul><li>KD-Tree ：均等化分又有一个问题，即比较多的包围盒与物体完全不相交，因此后续引入了 KD-树 来划分（三维即三个轴平面轮流循环划分）</li></ul><p><img src="/images/CG/Spatial-Partitioning-Examples.png" alt=""></p><p>完成划分后，一条光线即沿着树的根节点开始搜索，只要在某个节点处判断光线进入包围盒，就需要检查该节点的子节点，直到到达叶子节点</p><p><strong>注意</strong>：由于 KD-Tree 仍有较多问题，如一个物体可能出现在多个节点处、建树方法并不容易等，因此现代已基本不再使用其来划分</p><ul><li><p>Bounding Volume Hierarchy (BVH) 层级式地分割物体为两组创建新一级的包围盒</p><ol><li>全部物体划分进一个包围盒，相当于根节点</li><li>递归地将物体集分割成两个子集</li><li>重新计算创建子集的包围盒（可以有重叠）</li><li>必要时停止，通常是每个子集包含的物体个数小于阈值时</li><li>将所有物体储存在树结构的叶子节点</li></ol><ul><li>启发式的分割算法：总是选择最长的轴来进行分割；每次分割尽可能等分<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Intersect(Ray ray, BVH node) &#123;</span><br><span class="line">if (ray misses node.bbox) return;</span><br><span class="line">if (node is a leaf node) &#123;</span><br><span class="line">text intersection with all objs;</span><br><span class="line">return closest intersection;</span><br><span class="line">&#125;</span><br><span class="line">hit1 = Intersect(ray, node.child1);</span><br><span class="line">hit2 = Intersect(ray, node.child2);</span><br><span class="line">return the closer of hit1, hit2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Surface Area Heuristic (SAH) 一个同样非常不错的提升效率算法，自行搜索补充</p></li></ul><h2 id="辐射度量学-Basic-Radiometry"><a href="#辐射度量学-Basic-Radiometry" class="headerlink" title="辐射度量学 Basic Radiometry"></a>辐射度量学 Basic Radiometry</h2><p>相当于为光照建立了一个完整的度量体系和单位，有以下几个新增术语</p><p>Radiant flux，intensity，irradiance，radiance</p><p>并给出一个物理上合理的计算逻辑</p><h3 id="度量概念"><a href="#度量概念" class="headerlink" title="度量概念"></a>度量概念</h3><ul><li>Radiant Energy and Flux ：辐射的能量以 <strong>焦耳 Joule</strong> 为单位，flux 可以理解为<strong>通量</strong>或功率，表示单位时间内产生、反射、传输或接收的能量，其度量和单位如下 ‘瓦特或流明 luminous’<script type="math/tex; mode=display">\Phi \equiv \frac{dQ}{dt}\space[W=Watt][lm=lumen]^*</script></li><li>Intensity ：衡量单位立体角范围内发散出的功率，由于空间中光源向所有方向都均匀发射，规定了一个立体角 solid angle 作为角度单位，公式如下 <script type="math/tex; mode=display">I(\omega )\equiv \frac{d\Phi}{d\omega} \space[\frac{W}{sr}][\frac{lm}{sr}=cd=candela]</script><ul><li>立体角类比二维中弧度的确定，其定义式表达式为 $\Omega=\frac{A}{r^2}$ ，即球面上的区域面积除以半径的平方；一个完全发散的立体角大小为 4π steradians</li><li>考虑球面坐标系，使用两个角度 θ 和 φ 分别表示和 y 轴正向及 z 轴正向的夹角，由此计算出单位立体角 $d\omega=sin\theta \space d\theta \space d\phi$</li><li>Intensity 最终即为总功率 Φ 除以 4π<br><img src="/images/CG/Differential-Solid-Angles.png" alt="微分立体角"></li></ul></li><li>Irradiance ：衡量光落到单位面积的表面上的功率，其中功率的具体大小根据方向需要转换成与表面垂直的分量（回顾 Lambert’s cosine law），面积取平方米为单位，得到公式如下<script type="math/tex; mode=display">E(\mathbf{x})\equiv \frac{d\Phi(\mathbf{x})}{dA}\space [\frac{W}{m^2}][\frac{lm}{m^2}=lux]</script><ul><li>回顾着色模型，实际上随距离衰减的是单位面积的 irradiance</li></ul></li><li>Radiance ：衡量光沿着一条射线运动的强度；the power emitted … by a surface, per unit solid angle, per projected unit area；大致理解为通过单位面积表面的光线向单位立体角放出的功率<br><img src="/images/CG/Radiance-Defination-Formula.png" alt="Radiance 表达式"></li></ul><p>理解上可以参考下图，即将 Radiance 理解为 Irradiance 在半球体上各个单位立体角上的分解；或者反之理解为积分</p><p><img src="/images/CG/IrradianceVsRadiance.png" alt=""></p><h4 id="双向反射分布函数"><a href="#双向反射分布函数" class="headerlink" title="双向反射分布函数"></a>双向反射分布函数</h4><p>Bidirectional Reflectance Distribution Function；规定了从某个方向 $\omega_i$ 入射的 radiance 经过物体表面反射到某个方向 $\omega_r$ 得到的 radiance 的运算函数，相当于描述了一个材质用于实现着色效果</p><script type="math/tex; mode=display">f_r(\omega_i \rightarrow \omega_r) = \frac{dL_r(\omega_r)}{dE_i(\omega_i)}=\frac{dL_r(\omega_r)}{L_i(\omega_i)cos\theta_i d\omega_i} \space [\frac{1}{sr}]</script><p>将所有半球方向的入射光线经过 <strong>BRDF</strong> 反射到摄像机方向即得到总体反射的效果</p><p><img src="/images/CG/Ray-Reflection-Equation.png" alt="光追中的光线反射"></p><p>在此基础上，再考虑环境中其他物体反射到该点的光就会更复杂</p><h4 id="渲染方程-The-Rendering-Equation"><a href="#渲染方程-The-Rendering-Equation" class="headerlink" title="渲染方程 The Rendering Equation"></a>渲染方程 The Rendering Equation</h4><p>在反射的基础上加上物体自身可能辐射的值得到渲染方程，式中的 p 表示着色点（其中为了计算方便几个出入向量 ω 都取向外）：</p><script type="math/tex; mode=display">L_o(p, \omega_o)=L_e(p,\omega_o)+\int_{\Omega^+} L_i(p,\omega_i)f_r(p,\omega_i,\omega_o)(n\cdot \omega_i)d\omega_i</script><p>当递归地考虑所有物体表面的反射时，将上方等式的积分部分近似地写成算子形式，经过数学上移项以及后续的展开得到<strong>全局光照</strong>的表达式</p><p><img src="/images/CG/Global-Light-Equation.png" alt="全局光照效果和光栅化部分"></p><p>表达式将光照的视觉效果按照光线的反射次数分成了无穷项，当考虑所有项时即为全局光照效果，仅直接光照和单次弹射即为光栅化的原理</p><h4 id="蒙特卡洛积分-Monte-Carlo-Integral"><a href="#蒙特卡洛积分-Monte-Carlo-Integral" class="headerlink" title="蒙特卡洛积分 Monte Carlo Integral"></a>蒙特卡洛积分 Monte Carlo Integral</h4><p>实现渲染方程的展开和求解的方法</p><p>首先简单介绍<strong>蒙特卡洛积分</strong>：</p><ol><li>对于一个要求积分的函数 f(x) 及片段 [a, b]</li><li>引入积分域上的独立同分布随机变量 $X_i \sim p(x)$</li><li>近似的蒙特卡洛估计 $\int f(x)dx = F<em>N = \frac{1}{N}\sum^N</em>{i=1}\frac{f(X_i)}{p(X_i)}$</li></ol><h3 id="路径追踪-Path-Tracing"><a href="#路径追踪-Path-Tracing" class="headerlink" title="路径追踪 Path Tracing"></a>路径追踪 Path Tracing</h3><p>回顾 Whitted-Style 光线追踪，其没有实现光线在多个表面的重复漫反射效果，很多实现结果不符合现实，而渲染方程则能符合实际物理，其求解有两个关键点：1. 在半球面上积分；2. 递归地执行；为此借助蒙特卡洛积分方法</p><p>考虑 “反射等式” 部分，其为半球面上的积分，引入蒙特卡洛积分方法，选取半球面上的均匀分布 $F(\omega_i)=\frac{1}{2\pi}$，则将积分式转为求和式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">shade(p, wo)</span><br><span class="line">Randomly choose one directions wi-pdf</span><br><span class="line">Trace a ray r(p, wi)</span><br><span class="line">if ray r hit the light</span><br><span class="line">Return L_i * f_r * cosine / pdf(wi)</span><br><span class="line"># 递归部分，若 wi 角度指向其他物体则考虑其反射光</span><br><span class="line">Else if ray r hit an object at q</span><br><span class="line">Return shade(q, -wi) * f_r * cosine / pdf(wi)</span><br></pre></td></tr></table></figure><p>上述伪代码会轻易地因 N 次采样而指数爆炸，因此取 <strong>N=1</strong> 并在条件判断后直接 return 相应计算结果；仅执行一次采样即变成了对单条光线的<strong>路径追踪</strong></p><p>上述伪代码的递归仍然有两个问题：1. 单次采样方差较大；2. 递归没有重点； 各自的解决方法如下</p><ul><li><strong>像素点上采样</strong>：然而对积分的单次采样计算显然是不太理想的，会产生较大的方差；因此多次采样的工作转到像素点上 —— 因为最终在像素点上成像，我们在像素点上采样 N 个点并以相机到样本点的路径追踪光线，将追踪结果综合起来得到该像素点的成像结果</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ray_generation(camPos, pixel)</span><br><span class="line">Uniformly choose N sample positions within the pixel</span><br><span class="line">pixel_radiance = 0.0</span><br><span class="line">For each sample in the pixel</span><br><span class="line">Shoot a ray r(camPos, cam_to_sample)</span><br><span class="line">if ray r hit the scene at p</span><br><span class="line">pixel_radiance += 1 / N * shade(p, sample_to_cam)</span><br><span class="line">Return pixel_radiance</span><br></pre></td></tr></table></figure><ul><li><strong>引入生存概率</strong>：引入一个伯努利分布服从参数 P_RR，在每一步递归中，都从 [0, 1] 中取随机数 ksi，若该值大于 P_RR 则认为光线“消亡”而终止递归，否则将原本的返回值除以 P_RR，此方法具体的返回值期望为 $E(Lo) = P \times Lo / P + (1 - P) \times 0.0 = Lo$ 与原值无差异</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Manually specify a probability P_RR</span><br><span class="line">shade(p, wo)</span><br><span class="line">Randomly select ksi in a uniform dist. in [0, 1]</span><br><span class="line">if (ksi &gt; P_RR) return 0.0;</span><br><span class="line"></span><br><span class="line">Randomly choose One direction wi-pdf(w)</span><br><span class="line">Trace a ray r(p, wi)</span><br><span class="line">If ray r hit the light</span><br><span class="line">Return L_i * f_r * cosine / pdf(wi) / P_RR</span><br><span class="line">Else if ray r hit an object at q</span><br><span class="line">Return shade(q, -wi) * f_r * cosine / pdf(wi) / P_RR</span><br></pre></td></tr></table></figure><p>至此得到了正确的路径追踪算法</p><h4 id="Sampling-the-Light-效率提升"><a href="#Sampling-the-Light-效率提升" class="headerlink" title="Sampling the Light 效率提升"></a>Sampling the Light 效率提升</h4><p>上述路径追踪的实现效果受到单个像素点的采样量（samples per pixel）影响，因为每个像素点上的采样对应的 ray 到达着色点时，仅执行后续一次采样，这个单次采样不容易指向光源，造成其着色效果不佳；下述的方法主要针对 shade 部分</p><p>在 PT 中通常考虑面光源（点光源始终是难点，课程推荐是视作非常小的面光源），当考虑着色时的直接光照，原先的方法是在半球面上采样立体角，问题即不容易指向光源；更有效的方法是采样光源上的面积，转换成立体角的微分即可代入原本的计算式</p><p><img src="/images/CG/Sampling-the-Light.png" alt="对光源面采样"></p><p>观察上面的积分公式中的积分变换，显然 A 仅针对光源面，对其积分表示了直接光照的部分，因此还需要考虑非光源物体的反射光；最终实现的时候再追加一步，在计算直接光照时判断是否有其他物体遮挡，完成总的代码流程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">shade(p, wo)</span><br><span class="line"># Contribution from the light source.</span><br><span class="line">Uniformly sample the light at x&#x27; (pdf_light = 1 / A)</span><br><span class="line">Shoot a ray from p to x&#x27;</span><br><span class="line">If the ray is not blocked in the middle</span><br><span class="line">L_dir = L_i * f_r * cos θ * cos θ&#x27; / |x&#x27; - p|^2 / pdf_light</span><br><span class="line"></span><br><span class="line"># Contribution from other reflections.</span><br><span class="line">L_indir = 0.0</span><br><span class="line">Test Russian Roulette with probability P_RR</span><br><span class="line">Uniformly sample the hemisphere toward wi (pdf_hemi = 1 / 2pi)</span><br><span class="line">Trace a ray r(p, wi)</span><br><span class="line">If ray r hit a non-emitting object at q</span><br><span class="line">L_indir = shade(q, -wi) * f_r * cos θ / pdf_hemi / P_RR</span><br><span class="line"></span><br><span class="line">Return L_dir + L_indir</span><br></pre></td></tr></table></figure><h3 id="Further-Learning"><a href="#Further-Learning" class="headerlink" title="Further Learning"></a>Further Learning</h3><p>Path Tracing 是当前工业界实际使用的且已经证实过其重现真实感的方法，只要能正确实现就已经能取得相当好的效果；而凡是上面提到的采样积分，都可以引入 <strong>重要性采样</strong> 来取得更好的效果</p><p>学术界上还有更深入的研究</p><ul><li>The general solution of light transport, including<ul><li>Unidirectional &amp; bidirectional path tracing</li><li>Photon mapping</li><li>Metropolis light transport</li><li>VCM / UPBP…</li></ul></li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>回顾整体流程，可以独立实现的部分有：</p><ol><li>空间划分 + 射线与面相交判断</li><li>物体表面着色 + 像素点采样成像</li></ol><h3 id="射线与-AABB-相交判断"><a href="#射线与-AABB-相交判断" class="headerlink" title="射线与 AABB 相交判断"></a>射线与 AABB 相交判断</h3><p>分三个轴向计算进入和离开时间，根据逻辑判断即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Bounds3::IntersectP</span><span class="params">(<span class="type">const</span> Ray&amp; ray, <span class="type">const</span> Vector3f&amp; invDir, <span class="type">const</span> std::array&lt;<span class="type">int</span>, <span class="number">3</span>&gt;&amp; dirIsNeg)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// invDir: ray direction(x,y,z), invDir=(1.0/x,1.0/y,1.0/z), use this because Multiply is faster that Division</span></span><br><span class="line">    <span class="comment">// dirIsNeg: ray direction(x,y,z), dirIsNeg=[int(x&gt;0),int(y&gt;0),int(z&gt;0)], use this to simplify your logic</span></span><br><span class="line">    <span class="type">float</span> tEnter = - std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">infinity</span>();</span><br><span class="line">    <span class="type">float</span> tExit = std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">infinity</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="type">in_t</span> = (pMin[i] - ray.origin[i]) * invDir[i];</span><br><span class="line">        <span class="type">float</span> <span class="type">out_t</span> = (pMax[i] - ray.origin[i]) * invDir[i];</span><br><span class="line">        <span class="keyword">if</span> (!dirIsNeg[i]) &#123;</span><br><span class="line">            std::<span class="built_in">swap</span>(<span class="type">in_t</span>, <span class="type">out_t</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        tEnter = std::<span class="built_in">max</span>(tEnter, <span class="type">in_t</span>);</span><br><span class="line">        tExit = std::<span class="built_in">min</span>(tExit, <span class="type">out_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tEnter &lt; tExit &amp;&amp; tExit &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归的路径追踪函数"><a href="#递归的路径追踪函数" class="headerlink" title="递归的路径追踪函数"></a>递归的路径追踪函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector3f <span class="title">Scene::castRay</span><span class="params">(<span class="type">const</span> Ray &amp;ray, <span class="type">int</span> depth)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TO DO Implement Path Tracing Algorithm here</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先确定与场景交点</span></span><br><span class="line">    Intersection obj_inter = Scene::<span class="built_in">intersect</span>(ray);</span><br><span class="line">    <span class="keyword">if</span> (!obj_inter.happened) <span class="keyword">return</span> <span class="built_in">Vector3f</span>(<span class="number">0.0</span>);</span><br><span class="line">    <span class="comment">// 若直接看到光源就取其光照</span></span><br><span class="line">    <span class="keyword">if</span> (obj_inter.m-&gt;<span class="built_in">hasEmission</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> obj_inter.m-&gt;<span class="built_in">getEmission</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 深度 &gt; 0 说明为反射 ray，已经在计算直接光照时纳入</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Vector3f</span>(<span class="number">0.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 采样光源</span></span><br><span class="line">    Intersection inter;</span><br><span class="line">    <span class="type">float</span> pdf_light;</span><br><span class="line">    Scene::<span class="built_in">sampleLight</span>(inter, pdf_light);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义第一次反射计算的各个值</span></span><br><span class="line">    Vector3f wi = ray.direction, wo = <span class="built_in">normalize</span>(inter.coords - obj_inter.coords);</span><br><span class="line">    Vector3f &amp;NN = inter.normal, &amp;N = obj_inter.normal;</span><br><span class="line">    Material *m = obj_inter.m;</span><br><span class="line">    <span class="function">Ray <span class="title">out_ray</span><span class="params">(obj_inter.coords, wo)</span></span>;</span><br><span class="line">    Intersection obj2L = Scene::<span class="built_in">intersect</span>(out_ray);</span><br><span class="line"></span><br><span class="line">    <span class="function">Vector3f <span class="title">L_dir</span><span class="params">(<span class="number">0.0</span>)</span>, <span class="title">L_indir</span><span class="params">(<span class="number">0.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断反射击中光源，需要有 intersection 并且到光源距离足够近</span></span><br><span class="line">    <span class="keyword">if</span> (obj2L.happened &amp;&amp; (obj2L.coords - inter.coords).<span class="built_in">norm</span>() &lt; <span class="number">1e-2</span>) &#123;</span><br><span class="line">        L_dir = inter.emit * m-&gt;<span class="built_in">eval</span>(wi, wo, N) * <span class="built_in">dotProduct</span>(wo, N) * <span class="built_in">dotProduct</span>(-wo, NN)</span><br><span class="line">         / <span class="built_in">powf</span>((inter.coords - obj_inter.coords).<span class="built_in">norm</span>(), <span class="number">2.0</span>) / pdf_light;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 概率消亡</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">get_random_float</span>() &gt; RussianRoulette) &#123;</span><br><span class="line">        <span class="keyword">return</span> L_dir + L_indir;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector3f wd = <span class="built_in">normalize</span>(m-&gt;<span class="built_in">sample</span>(wi, N));</span><br><span class="line">    <span class="function">Ray <span class="title">dif_ray</span><span class="params">(obj_inter.coords, wd)</span></span>;</span><br><span class="line">    Intersection dif_inter = Scene::<span class="built_in">intersect</span>(dif_ray);</span><br><span class="line">    <span class="comment">// 仅考虑反射后非光源</span></span><br><span class="line">    <span class="keyword">if</span> (dif_inter.happened &amp;&amp; !dif_inter.m-&gt;<span class="built_in">hasEmission</span>()) &#123;</span><br><span class="line">        L_indir = Scene::<span class="built_in">castRay</span>(dif_ray, depth + <span class="number">1</span>) * m-&gt;<span class="built_in">eval</span>(wi, wd, N) * <span class="built_in">dotProduct</span>(wd, N) / m-&gt;<span class="built_in">pdf</span>(wi, wd, N) / RussianRoulette;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L_dir + L_indir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作业中犯的错误"><a href="#作业中犯的错误" class="headerlink" title="作业中犯的错误"></a>作业中犯的错误</h3><ol><li>借用算法判断射线是否相交三角形时，叉乘写成了点乘</li><li>BVH 到有相交的叶子节点忘记写 return</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1X7411F744?p=1&amp;amp;spm_id_from=pageDriver&quot;&gt;博客图片及学习路径来源 Gamse 101课程，在此记录以方便个人查阅为主，强烈建议自行</summary>
      
    
    
    
    <category term="Games-Graphics" scheme="http://remedios14.github.io/categories/Games-Graphics/"/>
    
    
    <category term="games" scheme="http://remedios14.github.io/tags/games/"/>
    
    <category term="计算机图形学" scheme="http://remedios14.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Games101-计算机图形学（三）</title>
    <link href="http://remedios14.github.io/2022/05/29/Games/101%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://remedios14.github.io/2022/05/29/Games/101%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2022-05-29T04:24:06.000Z</published>
    <updated>2022-06-26T15:19:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://www.bilibili.com/video/BV1X7411F744?p=1&amp;spm_id_from=pageDriver">博客图片及学习路径来源 Gamse 101课程，在此记录以方便个人查阅为主，强烈建议自行观看学习</a></strong></p><h2 id="Geometry-几何"><a href="#Geometry-几何" class="headerlink" title="Geometry 几何"></a>Geometry 几何</h2><p>包括各种几何形体（曲线、曲面等）的实现以及存储、渲染问题（远视图的简化存储）；课程概括了两种几何形体</p><ul><li>Implicit 可以由满足指定关系的点所表述的几何，简单如平面、球面等，能很容易判断一个点是否在表面上<ul><li>algebraic surface</li><li>level sets 水平集，给出空间网格（或方格）及格内的值，使用双线性插值求出类似等高线的结果</li><li>$(x^2+\frac{9y^2}{4}+z^2-1)^3=x^2z^3+\frac{9y^2z^3}{80}$</li><li>Constructive Solid Geometry 由基础几何执行交并差等运算</li><li>Blending Distance Function 给出空间中点到几何体的距离函数（内部为负）确定几何体；可以用于模拟补完运动的中间效果</li><li>Fractals 分形</li></ul></li><li>Explicit 直接给出所有的点或者给出参数映射关系（2D -&gt; 3D），较难判断点相对面的位置<ul><li>point cloud</li><li>polygon mesh 存储顶点、多边形的信息，有例如 Wavefront Object File 存储格式得到 .obj 文件，实际上是存储了 顶点、法线、坐标和连接关系等</li><li>subdivision，NURBS</li><li>…</li></ul></li></ul><h3 id="曲线和曲面-Curves-and-Surfaces"><a href="#曲线和曲面-Curves-and-Surfaces" class="headerlink" title="曲线和曲面 Curves and Surfaces"></a>曲线和曲面 Curves and Surfaces</h3><h4 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h4><p>必定经过首尾两点，由中间的控制点来调整弯曲程度；de Casteljau 算法用于在确定空间中不少于三个点（含首尾）点时绘制曲线</p><ul><li>算法原理：已知一列点 $b_0, b_1, … ,b_n$ 包含首尾点，则有 n 个线段，假设最终曲线上的点由 [0, 1] 的比例 t 表示，对每个线段都找到其 t 分位点，以此作为递归后的一组点，类似归纳法得到最终单个点为曲线上的 t 分位点；例如下</li></ul><p><img src="/images/CG/Cubic-de-Casteljau.png" alt=""></p><p>相当于不断进行线性插值，由此可以写出公式</p><script type="math/tex; mode=display">\begin{align} b^n(t)=\sum^n_{j=0}b_jB^n_j(t), \\B^n_i(t)=\mathsf{C}^i_n t^i(1-t)^{n-i}\end{align}</script><p><strong>优良性质</strong>：贝塞尔曲线对仿射变换保持不变，即先变换控制点再绘制和直接变换曲线上的点结果一致（投影不保持）</p><ul><li>Piecewise 贝塞尔曲线：当控制点增多时，每个点对曲线的控制程度会很弱，因此通常以四个点为一组确定一个贝塞尔曲线，并尽可能保持组之间连接处的连续性<ul><li>连续性：该点处的左右导数相等 —— 共线且等长</li></ul></li></ul><h4 id="样条-Spline"><a href="#样条-Spline" class="headerlink" title="样条 Spline"></a>样条 Spline</h4><p>常用的如 B-Spline 和 NURBS，可以更方便地控制局部性质</p><h4 id="贝塞尔曲面"><a href="#贝塞尔曲面" class="headerlink" title="贝塞尔曲面"></a>贝塞尔曲面</h4><p>首先通过四个控制点确定一个贝塞尔曲线，同时每个点都有完整的运动轨迹，在轨迹上不断地确定曲线最终形成曲面</p><p>因此贝塞尔曲面上单个点需要两个 [0,1] 范围内的值 (u, v) 来确定</p><p><img src="/images/CG/Bezier-Surface-Construction.png" alt=""></p><p>不妨用 u 表示轨迹的分位数，用 v 表示确定四个控制点后的曲线分位数</p><h3 id="网格操作"><a href="#网格操作" class="headerlink" title="网格操作"></a>网格操作</h3><h4 id="细分-Subdivision"><a href="#细分-Subdivision" class="headerlink" title="细分 Subdivision"></a>细分 Subdivision</h4><p>细分不仅是将原有平面分割，还需要考虑分割后产生一定程度的空间变化；三角形的分割很容易确定，因此主要考虑分割后的形变</p><ul><li>Loop Subdivision ：针对三角形的细分，先将三角形的每个边等分得到三个新顶点，然后针对新顶点和旧顶点分别处理<ul><li>新顶点：假设其所处边有两个旧顶点 A、B，共享该边的两个三角形各有另一个旧顶点 C、D，经过加权平均最终确定该新顶点坐标为 $\frac{3}{8}(A+B)+\frac{1}{8}(C+D)$</li><li>旧顶点：定义一个度 n 描述以该点为顶点的三角形个数，然后所有相邻三角形的其他顶点等价地赋权 u ，当 n = 3 时 u = 3/16；否则 u = 3 / (8n)；更新旧顶点坐标 (1 - n*u) * origin_position + u * neighbour_position_sum</li></ul></li><li>Catmull-Clark Subdivision ：处理一般网格（以四边形为主），每一个面都取一个中心点，将该中心点与其边上的中点都相连进行细分；称相连边数不为 4 的顶点为奇异点，则此细分仅在第一次细分时增加奇异点；后续点的更新规则如下</li></ul><p><img src="/images/CG/Catmull-Clark-Vertex-Update.png" alt=""></p><h4 id="简化-Simplification"><a href="#简化-Simplification" class="headerlink" title="简化 Simplification"></a>简化 Simplification</h4><p>一个不错的方法 —— Edge Collapse —— 选择一个边将其简化成一个顶点</p><p>具体的操作是贪心的启发式算法，分为两个步骤考虑：</p><ol><li>坍缩后的单个顶点位置：最小化二次度量误差（Quadric Error Distance），即在坍缩前的空间中任取一点，可以计算该点到所有原有平面的距离平方和，最小化该平方和来确定坍缩后的目标点</li><li>怎样选择边：基于前一步的计算，每一条边都能计算出最优坍缩下的二次度量误差，使用优先队列存储这些信息，选择最优的边执行坍缩，并动态更新会受到影响的边的信息</li></ol><h4 id="正规化-Regularization"><a href="#正规化-Regularization" class="headerlink" title="正规化 Regularization"></a>正规化 Regularization</h4><p>暂略，看书后补充</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1X7411F744?p=1&amp;amp;spm_id_from=pageDriver&quot;&gt;博客图片及学习路径来源 Gamse 101课程，在此记录以方便个人查阅为主，强烈建议自行</summary>
      
    
    
    
    <category term="Games-Graphics" scheme="http://remedios14.github.io/categories/Games-Graphics/"/>
    
    
    <category term="games" scheme="http://remedios14.github.io/tags/games/"/>
    
    <category term="计算机图形学" scheme="http://remedios14.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Games101-计算机图形学（二）</title>
    <link href="http://remedios14.github.io/2022/05/28/Games/101%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://remedios14.github.io/2022/05/28/Games/101%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2022-05-28T02:22:48.000Z</published>
    <updated>2022-06-18T07:06:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><a href="https://www.bilibili.com/video/BV1X7411F744?p=1&amp;spm_id_from=pageDriver">博客图片及学习路径来源 Gamse 101课程，在此记录以方便个人查阅为主，强烈建议自行观看学习</a></strong></p><h2 id="Shading-着色"><a href="#Shading-着色" class="headerlink" title="Shading 着色"></a>Shading 着色</h2><p>游戏引擎中一个关键要素 —— 光源， 以及后续物体材质在光源下的观察效果，明暗变化等；在图形学中的着色可以概括为将一个由几何描述的场景呈现到二维屏幕上的过程</p><h3 id="基本模型结构"><a href="#基本模型结构" class="headerlink" title="基本模型结构"></a>基本模型结构</h3><p>着色问题的一个基本问题结构即为：</p><ul><li>已知一个物体位置并以其表面的点为观察对象 shading point，基于此点已知了光源位置从而确定光线方向，已知了相机位置从而确定了视线方向，点上有一个物体表面法向，最后还有材质相关的各种参数会影响着色效果（以下向量都取单位向量，为了表示方便，将光线方向取反修改为从 shading point 出发的向量）</li></ul><p><img src="/images/CG/Shading-Model.png" alt=""></p><h4 id="漫反射着色-Diffuse-Shading"><a href="#漫反射着色-Diffuse-Shading" class="headerlink" title="漫反射着色 Diffuse Shading"></a>漫反射着色 Diffuse Shading</h4><p>现实的物理表面大多数都发生漫反射，因此在图形学上也考虑模拟漫反射行为，此时表面点在视觉上的效果即需要考虑该点漫反射向视线向量的光强度，该强度可以分为几个部分考虑：</p><ol><li>基于 Lambert’s cosine law ，一个单位大小的表面，其接收到的光线通量与 <strong>法向量 n 和光线向量 l 的夹角</strong> 有关<br><img src="/images/CG/Lambert&#39;s-Cosine-Law.png" alt=""></li><li>考虑光线的分散，假设某一时刻从点光源中发散出的总光能为 I，该光能会始终均匀分布在以光源为圆心的球形表面上，因此当球壳的半径增大时，分布在单位圆弧上的光能就会较少，考虑球壳表面积公式即可计算得到 $I / r^2$</li><li>根据物体材质、颜色不同，反射的光能也不同，此项给出一个系数来计算（例如黑色将光线全吸收不反射，系数为 0），具体的系数视情况变化，可以分 rgb 通道各自给出计算</li></ol><p>综上得到完整的计算公式<br><img src="/images/CG/Lambertian-Diffuse-Shading.png" alt=""></p><p><strong>补充</strong>：漫反射光的观察强度与观察视线向量无关，因为漫反射从反射点出发向任意方向反射出相同强度的光线</p><h4 id="镜面反射-Specular-Term"><a href="#镜面反射-Specular-Term" class="headerlink" title="镜面反射 Specular Term"></a>镜面反射 Specular Term</h4><p>除开漫反射之外也有表面的镜反射，即入射角度和出射角度相等，在此角度上（或比较接近）的区域观察会形成<strong>高光效果</strong>；为了衡量这种高光效果的具体强度，引入 Blinn-Phong 模型</p><p><img src="/images/CG/Blinn-Phong-Specular.png" alt=""></p><p>即借助（反向）入射 l 和出射 v 的中间向量 h 与法向量 n 的偏移程度来评估此反射接近镜面反射的程度</p><p>其中指数 p 在于作用到 $\cos \alpha$ 上将高光区域限定到较小范围</p><h4 id="环境光照-Ambient-Term"><a href="#环境光照-Ambient-Term" class="headerlink" title="环境光照 Ambient Term"></a>环境光照 Ambient Term</h4><p>在理解上应当与光源、视线等无关，因此图形学上近似的用常数代替</p><script type="math/tex; mode=display">L = k_{a}I_{a}</script><h4 id="综合的-Blinn-Phong-反射模型"><a href="#综合的-Blinn-Phong-反射模型" class="headerlink" title="综合的 Blinn-Phong 反射模型"></a>综合的 Blinn-Phong 反射模型</h4><p>将三种情况下的光照效果复合起来即得到</p><p><img src="/images/CG/Blinn-Phong-Reflection.png" alt=""></p><script type="math/tex; mode=display">L = L_{a} + L_{d} + L_{s} = k_{a}I_{a} + k_{d}(I/r^2)\max(0,n \cdot l) + k_{s}(I/r^2)\max(0, n \cdot h)^p</script><h3 id="着色频率-Shading-Frequencies"><a href="#着色频率-Shading-Frequencies" class="headerlink" title="着色频率 Shading Frequencies"></a>着色频率 Shading Frequencies</h3><p>也是一个效率和效果的取舍问题：着色整个三角形平面 Flat shading -&gt; 着色每个三角形顶点再插值填充 Gouraud shading -&gt; 着色每个像素点 Phong shading</p><p>其中平面的法线容易确定，后续顶点的法线由其所有相接平面的法线（根据面积加权）平均得到</p><h3 id="图形管线-Graphics-Pipeline"><a href="#图形管线-Graphics-Pipeline" class="headerlink" title="图形管线 Graphics Pipeline"></a>图形管线 Graphics Pipeline</h3><p>描述了完整的图形生成的流程</p><p><img src="/images/CG/Graphics-Pipeline.png" alt="Graphics-Pipeline"></p><h3 id="Shadow-Mapping-阴影映射"><a href="#Shadow-Mapping-阴影映射" class="headerlink" title="Shadow Mapping 阴影映射"></a>Shadow Mapping 阴影映射</h3><p>模拟光源下的物体阴影效果，核心是<strong>使用光栅化的思想</strong>，大致分为两个步骤实现：</p><ol><li>模拟一个光源视角来确定光源可以到达的点，在一个像素平面上记录所有可见点的深度；</li><li>对于实际相机观察到的点，重新映射到前一步的光源像素平面上，比较平面上记录的深度是否小于观察点实际深度，若（显著）小于说明被遮挡，应该看到阴影</li></ol><p>一些难以解决的问题：</p><ol><li>只能实现硬阴影 —— 点是否在阴影中；针对点光源执行的过程，视觉效果即仅能看到锐利的边缘；相对的软阴影采用有体积的球形光源，可以部分观察到来渐变地实现阴影</li><li>上方步骤一中的像素平面也有具体的精度问题，需要考虑效果和效率的平衡 trade-off</li><li>浮点数精度问题以及衍生的计算误差问题不可避免，因此实现效果上也存在瑕疵</li></ol><h3 id="纹理映射-Texture-Mapping"><a href="#纹理映射-Texture-Mapping" class="headerlink" title="纹理映射 Texture Mapping"></a>纹理映射 Texture Mapping</h3><p>纹理可以大致地理解为不同位置具有不同的反射参数的 2D 图片，将这种图片映射到 3D 模型上来实现多样化的着色效果</p><p>为了实现纹理的效果，需要考虑两方面的难点：</p><ol><li>将 2D 图形上的点映射到 3D 模型各个三角形平面的顶点上</li><li>基于三角形顶点的信息（颜色、材质、法向量等）插值填充平面</li></ol><p>首先是插值方法，需要用到 重心坐标 Barycentric coordinates</p><h4 id="三角形插值-Interpolation-Across-Triangles"><a href="#三角形插值-Interpolation-Across-Triangles" class="headerlink" title="三角形插值 Interpolation Across Triangles"></a>三角形插值 Interpolation Across Triangles</h4><ul><li>重心坐标系：已知三角形三个顶点的坐标，给出归一系数 $\alpha + \beta + \gamma = 1$，则顶点坐标在此系数下的线性组合一定在三角形所在平面上；更进一步地，若各系数非负，则线性组合一定在三角形内部（非外部）；三个系数相等时表示的点即为三角形的重心</li></ul><p>实际插值时，即先根据空间坐标计算得到重心坐标系的表达式，然后采用其系数对各顶点的属性进行线性组合完成插值</p><p><strong>注意</strong>：重心坐标表示法不具有投影不变性，因此要明确具体在哪个空间中求重心坐标进行插值</p><h4 id="透视矫正插值"><a href="#透视矫正插值" class="headerlink" title="透视矫正插值"></a>透视矫正插值</h4><p>在作业框架中执行光栅化时，具体传入了投影后的三角形用于确定需要着色的像素点，同时传入了已经完成变换但未透视投影的顶点坐标，用于处理插值得到三个系数，然后经过 <strong>透视矫正插值</strong> 转化为透视投影后的值</p><p><img src="/images/CG/Perspective-Adjusted-Interpolation.png" alt=""></p><p>其中的推导过程略过，给出最终 z 轴向的插值运算</p><script type="math/tex; mode=display">\frac{1}{z_0} = \alpha \frac{1}{z_1} + \beta \frac{1}{z_2} + \gamma \frac{1}{z_3}</script><p>而对于顶点具有的其他属性，下以 b 符号记来给出插值运算</p><script type="math/tex; mode=display">\frac{b_0}{z_0} = \alpha \frac{b_1}{z_1} + \beta \frac{b_2}{z_2} + \gamma \frac{b_3}{z_3}</script><h3 id="应用纹理-Applying-Texture"><a href="#应用纹理-Applying-Texture" class="headerlink" title="应用纹理 Applying Texture"></a>应用纹理 Applying Texture</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for each rasterized screen sample(x, y):</span><br><span class="line">(u, v) = evaluate texture coordinate at (x, y);</span><br><span class="line">texcolor = texture.sample(u, v);</span><br><span class="line">set sample&#x27;s color to texcolor;</span><br></pre></td></tr></table></figure><p>其中 (x, y) 通常取像素中心点，即 .5 坐标；基于光栅化后屏幕上的坐标计算重心坐标，插值得到 (u, v)，然后在文理图上查询该 (u, v) 得到该样本点对应的纹理颜色</p><p>由于经过透视投影会产生近大远小的视觉效果，因此实际使用中有几个难以避免的问题：（为了区分纹理和屏幕，称纹理上的像素为 texel 纹素）</p><ol><li>纹理相对于目标区域太小，像素太低，此时就会对纹理执行放大操作，造成一个 texel 内有多个像素，此时如果直接取最近的 texel 值回传则效果不佳，引入插值方法<ul><li>双线性插值 Bilinear interpolation ：取相邻四个纹素点的值进行两次横向一次纵向的线性插值得到当前点的值</li><li>Bicubic（代补充）</li></ul></li><li>Texture Magnification —— 相对远处的目标，纹理图过大，像素太高，此时单个像素会覆盖多个 texel，产生的效果类似走样，采用反走样方法追加采样点去计算 texel 的平均值，增加大量运算但能优化效果，也有更好的方法（另起一小节）</li></ol><h4 id="Texture-Magnification"><a href="#Texture-Magnification" class="headerlink" title="Texture Magnification"></a>Texture Magnification</h4><ol><li>Mipmap ：即 CV 中的图像金字塔，先对纹理进行处理来存储额外的信息，得到多个层，高层直接存储了多个 texel 的平均信息，而总的额外空间并不多</li></ol><p>使用 Mipmap 时，原像素经过计算得到 0 层纹理上的点 P ，理想情况即找到目标层 D 来确保 P 对应该层上的点为单像素，取用该值即得到查询结果，而确定该层 D 的方法有</p><p><img src="/images/CG/Computing-Mipmap-Level-D.png" alt="Computing-Mipmap-Level-D"></p><p>上方的 dx、dy 为像素点的差，du、dv 为纹素点的差</p><p>借助映射前后的距离差异来确定需要折半的次数，即目标层数</p><p>实际计算得到的层数 D 是一个浮点数，如果直接向上取整则结果不太连贯，因此可以继续引入插值形成 Trilinear Interpolation，对 D 相邻的层都进行插值得到结果，然后对结果参照 D 插值得到最终值</p><ol><li>各向异性过滤 Anisotropic Filtering ：一定程度上弥补 Mipmap的不足，同样是对纹理进行预先处理存储，将纹理横纵向分别收缩，此时当像素点投射到收缩后的图上时，其还原结果即为矩形状，较符合远处的视觉效果</li></ol><p><img src="/images/CG/Anisotropic-Filtering-Preprocess.png" alt="游戏中有选项 xN 即向横纵进行 N 次压缩预存用于查询，仅影响显存空间大小"></p><p>各向异性过滤对横纵向的压缩能有较好的效果</p><p><img src="/images/CG/Irregular-Pixel-Footprint-in-Texture.png" alt="不规则的映射结果"></p><p>为了进一步弥补倾斜方向的压缩缺陷，后续也有 <strong>EWA filtering</strong> 方法，采用圆心来进行层级划分查询，只是开销更大</p><h4 id="环境映射-Environmental-Map"><a href="#环境映射-Environmental-Map" class="headerlink" title="环境映射 Environmental Map"></a>环境映射 Environmental Map</h4><p>将环境光信息记录在类似镜面球的表面上，其映射原理分为两种：</p><ul><li>Spherical EM ：直接经过几何运算记录到球体表面上，但在球的不同位置不均匀，球的极点处发生严重扭曲（因为球体是不可展平面）</li><li>Cube Map ：将球体表面分割来得到正方体表面的映射，可以保证均匀分布，需要额外的计算来确定对应关系</li></ul><p><img src="/images/CG/Cube-Map-Illust.png" alt=""></p><h4 id="特殊属性纹理"><a href="#特殊属性纹理" class="headerlink" title="特殊属性纹理"></a>特殊属性纹理</h4><p>一个纹理贴图不止可以存储颜色信息，也可以存储虚拟的高度信息，用于在每一个位置重新计算法向进行插值</p><ul><li>Bump / Normal Mapping 凹凸/法线贴图 ：在一个确定的表面上定义不同位置的高度，在每一个点处可以通过近似的微分求导确定该点的法线，以此法线属性作为采样的值；不改变模型原始的形状，只是通过法线的着色效果产生凹凸不平的视觉效果；其中法线的计算是先建立局部的坐标系，然后通过 <strong>TBN 矩阵</strong>重新映射到世界坐标</li><li>Displacement Mapping 位移贴图 ：相比于凹凸贴图，位移贴图实际移动了每一个三角形顶点的位置，因此需要模型较为细致，包含许多三角形（具体多少不确定，因此有<strong>曲面细分</strong>方法，在使用中视具体效果分割曲面得到更精细的模型）</li></ul><p><img src="/images/CG/B-D-Mapping.png" alt=""></p><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><p><strong>前注</strong> ：矩阵的逐元乘法调用 <code>cwiseProduct</code></p><h3 id="插值计算三角形内点属性"><a href="#插值计算三角形内点属性" class="headerlink" title="插值计算三角形内点属性"></a>插值计算三角形内点属性</h3><p>其中两个插值函数只是将三个向量按参数加权相加然后除以权重 weight</p><p>传入的 vp —— view_pos 为空间中的点在执行投射变换前一步的坐标组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> rst::rasterizer::<span class="built_in">rasterize_triangle</span>(<span class="type">const</span> Triangle&amp; t, <span class="type">const</span> std::array&lt;Eigen::Vector3f, <span class="number">3</span>&gt;&amp; vp) &#123;</span><br><span class="line">    <span class="keyword">auto</span> v = t.<span class="built_in">toVector4</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bounding box, 确定投射后的屏幕上矩形区域</span></span><br><span class="line">    <span class="type">float</span> min_x = std::<span class="built_in">min</span>(v[<span class="number">0</span>][<span class="number">0</span>], std::<span class="built_in">min</span>(v[<span class="number">1</span>][<span class="number">0</span>], v[<span class="number">2</span>][<span class="number">0</span>]));</span><br><span class="line">    <span class="type">float</span> max_x = std::<span class="built_in">max</span>(v[<span class="number">0</span>][<span class="number">0</span>], std::<span class="built_in">max</span>(v[<span class="number">1</span>][<span class="number">0</span>], v[<span class="number">2</span>][<span class="number">0</span>]));</span><br><span class="line">    <span class="type">float</span> min_y = std::<span class="built_in">min</span>(v[<span class="number">0</span>][<span class="number">1</span>], std::<span class="built_in">min</span>(v[<span class="number">1</span>][<span class="number">1</span>], v[<span class="number">2</span>][<span class="number">1</span>]));</span><br><span class="line">    <span class="type">float</span> max_y = std::<span class="built_in">max</span>(v[<span class="number">0</span>][<span class="number">1</span>], std::<span class="built_in">max</span>(v[<span class="number">1</span>][<span class="number">1</span>], v[<span class="number">2</span>][<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x_min = std::<span class="built_in">floor</span>(min_x);</span><br><span class="line">    <span class="type">int</span> x_max = std::<span class="built_in">ceil</span>(max_x);</span><br><span class="line">    <span class="type">int</span> y_min = std::<span class="built_in">floor</span>(min_y);</span><br><span class="line">    <span class="type">int</span> y_max = std::<span class="built_in">ceil</span>(max_y);</span><br><span class="line"><span class="comment">// 遍历矩形内的像素点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x_min; i &lt;= x_max; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = y_min; j &lt;= y_max; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">insideTriangle</span>(i + <span class="number">0.5</span>, j + <span class="number">0.5</span>, t.v)) &#123;</span><br><span class="line">                <span class="comment">// 计算重心坐标的三个参数</span></span><br><span class="line">                <span class="keyword">auto</span>[alpha, beta, gamma] = <span class="built_in">computeBarycentric2D</span>(i + <span class="number">0.5</span>, j + <span class="number">0.5</span>, t.v);</span><br><span class="line"><span class="comment">// 基于中心坐标插值得到深度值</span></span><br><span class="line">                <span class="type">float</span> Z = <span class="number">1.0</span> / (alpha / v[<span class="number">0</span>].<span class="built_in">w</span>() + beta / v[<span class="number">1</span>].<span class="built_in">w</span>() + gamma / v[<span class="number">2</span>].<span class="built_in">w</span>());</span><br><span class="line">                <span class="type">float</span> zp = alpha * v[<span class="number">0</span>].<span class="built_in">z</span>() / v[<span class="number">0</span>].<span class="built_in">w</span>() + beta * v[<span class="number">1</span>].<span class="built_in">z</span>() / v[<span class="number">1</span>].<span class="built_in">w</span>() + gamma * v[<span class="number">2</span>].<span class="built_in">z</span>() / v[<span class="number">2</span>].<span class="built_in">w</span>();</span><br><span class="line">                zp *= Z;</span><br><span class="line"></span><br><span class="line"><span class="comment">// color </span></span><br><span class="line"><span class="keyword">auto</span> interpolated_color = <span class="built_in">interpolate</span>(alpha, beta, gamma, t.color[<span class="number">0</span>], t.color[<span class="number">1</span>], t.color[<span class="number">2</span>], <span class="number">1</span>);</span><br><span class="line"><span class="comment">// normal</span></span><br><span class="line"><span class="keyword">auto</span> interpolated_normal = <span class="built_in">interpolate</span>(alpha, beta, gamma, t.normal[<span class="number">0</span>], t.normal[<span class="number">1</span>], t.normal[<span class="number">2</span>], <span class="number">1</span>).<span class="built_in">normalized</span>();</span><br><span class="line"><span class="comment">// texture</span></span><br><span class="line"><span class="keyword">auto</span> interpolated_texcoords = <span class="built_in">interpolate</span>(alpha, beta, gamma, t.tex_coords[<span class="number">0</span>], t.tex_coords[<span class="number">1</span>], t.tex_coords[<span class="number">2</span>], <span class="number">1</span>);</span><br><span class="line"><span class="comment">// shadingcoords</span></span><br><span class="line"><span class="keyword">auto</span> interpolated_shadingcoords = <span class="built_in">interpolate</span>(alpha, beta, gamma, vp[<span class="number">0</span>], vp[<span class="number">1</span>], vp[<span class="number">2</span>], <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用来传递插值结果的结构体</span></span><br><span class="line"><span class="function">fragment_shader_payload <span class="title">payload</span><span class="params">(interpolated_color, interpolated_normal, interpolated_texcoords, texture ? &amp;*texture : <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">payload.view_pos = interpolated_shadingcoords;</span><br><span class="line"><span class="keyword">auto</span> pixel_color = <span class="built_in">fragment_shader</span>(payload);</span><br><span class="line"><span class="comment">// 设置颜色</span></span><br><span class="line"><span class="built_in">set_pixel</span>(Eigen::<span class="built_in">Vector2i</span>(i, j), pixel_color);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Fragment-Shader-着色模型"><a href="#Fragment-Shader-着色模型" class="headerlink" title="Fragment Shader 着色模型"></a>Fragment Shader 着色模型</h3><p>其中 normal 为着色点的法向量，point 为着色点坐标，intensity 为光强度属性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Eigen::Vector3f n = normal.<span class="built_in">normalized</span>();</span><br><span class="line">Eigen::Vector3f l_vec = light.position - point;</span><br><span class="line"><span class="type">float</span> rad = l_vec.<span class="built_in">dot</span>(l_vec);</span><br><span class="line">l_vec = l_vec.<span class="built_in">normalized</span>();</span><br><span class="line">Eigen::Vector3f v_vec = (eye_pos - point).<span class="built_in">normalized</span>();</span><br><span class="line">Eigen::Vector3f h_vec = (l_vec + v_vec).<span class="built_in">normalized</span>();</span><br><span class="line"></span><br><span class="line">result_color = ka.<span class="built_in">cwiseProduct</span>(amb_light_intensity) +</span><br><span class="line">kd.<span class="built_in">cwiseProduct</span>(light.intensity) * std::<span class="built_in">max</span>(<span class="number">0.f</span>, n.<span class="built_in">dot</span>(l_vec)) / rad +</span><br><span class="line">ks.<span class="built_in">cwiseProduct</span>(light.intensity) * std::<span class="built_in">pow</span>(std::<span class="built_in">max</span>(<span class="number">0.f</span>, n.<span class="built_in">dot</span>(h_vec)), p) / rad;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1X7411F744?p=1&amp;amp;spm_id_from=pageDriver&quot;&gt;博客图片及学习路径来源 Gamse 101课程，在此记录以方便个人查阅为主，强烈建议自行</summary>
      
    
    
    
    <category term="Games-Graphics" scheme="http://remedios14.github.io/categories/Games-Graphics/"/>
    
    
    <category term="games" scheme="http://remedios14.github.io/tags/games/"/>
    
    <category term="计算机图形学" scheme="http://remedios14.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Games101-计算机图形学（一）</title>
    <link href="http://remedios14.github.io/2022/05/23/Games/101%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://remedios14.github.io/2022/05/23/Games/101%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2022-05-23T09:10:11.000Z</published>
    <updated>2022-06-21T02:39:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Overview-of-Computer-Graphics"><a href="#Overview-of-Computer-Graphics" class="headerlink" title="Overview of Computer Graphics"></a>Overview of Computer Graphics</h2><p><strong><a href="https://www.bilibili.com/video/BV1X7411F744?p=1&amp;spm_id_from=pageDriver">博客图片及学习路径来源 Gamse 101课程，在此记录以方便个人查阅为主，强烈建议自行观看学习</a></strong></p><h3 id="What-is-Computer-Graphics？"><a href="#What-is-Computer-Graphics？" class="headerlink" title="What is Computer Graphics？"></a>What is Computer Graphics？</h3><p>以下众多元素都有计算机图形学的支持</p><ul><li>视频游戏：一大重点即为画面的全局亮度；</li><li>电影特效：描述为最简单的图形学应用（画鬼神易画犬马难）；<ul><li>进阶有动作捕捉乃至面部表情捕捉</li></ul></li><li>动画电影：</li><li>光影材质设计：用于实现各种材质对光影效果的反馈，完成如室内设计等工作</li><li>可视化工作：如人体模型等各类可视化</li><li>VR：虚拟现实技术</li><li>Simulation：仿真功能</li><li>Graphical User Interfaces：用户图形接口，即 GUI</li></ul><h3 id="Course-Topics"><a href="#Course-Topics" class="headerlink" title="Course Topics"></a>Course Topics</h3><ul><li>Rasterizaion ：光栅化 —— 把三维空间的几何图形显示在屏幕上</li><li>Curves and Meshes ：曲线和网格的实现 —— 计算机中的几何</li><li>Ray Tracing ：光线追踪 —— 光影效果的实现</li><li>Animation / Simulation ：动画与仿真功能</li></ul><h2 id="线代-Linear-Algebra"><a href="#线代-Linear-Algebra" class="headerlink" title="线代 Linear Algebra"></a>线代 Linear Algebra</h2><p>基础概念不作赘述</p><ul><li>向量内积（点乘）计算夹角余弦值：两个向量计算得到标量值<br>$|\vec{a} \cdot \vec{b}| = |\vec{a}| |\vec{b}|\cos \theta $</li><li><a href="https://blog.csdn.net/minmindianzi/article/details/100056129">向量叉积</a> （cross product）用于构建符合右手坐标系的向量 —— 向量到向量<script type="math/tex; mode=display">\vec{a} \times \vec{b}=A^{*} b=\left(\begin{array}{ccc}0 & -z_{a} & y_{a} \\z_{a} & 0 & -x_{a} \\-y_{a} & x_{a} & 0\end{array}\right)\left(\begin{array}{l}x_{b} \\y_{b} \\z_{b}\end{array}\right)=\left(\begin{array}{l}y_{a}z_{b} - y_{b}z_{a} \\x_{b}z_{a} - x_{a}z_{b} \\x_{a}y_{b} - x_{b}y_{a}\end{array}\right)</script><ul><li>数量级关系：$|\vec{a} \times \vec{b}| = |\vec{a}| |\vec{b}|\sin \theta $</li><li>可用于判断一个点是否在三角形内侧 —— 每次取一条边向量，计算两个叉积再做内积判断目标点是否与第三点在边向量的同一侧</li></ul></li><li>矩阵运算及矩阵左乘向量运算</li></ul><h2 id="变换-Transformation"><a href="#变换-Transformation" class="headerlink" title="变换 Transformation"></a>变换 Transformation</h2><p>包括旋转、缩放、切变，都可以用一个变换矩阵左乘原向量得到</p><ul><li>逆时针旋转 θ 角度<script type="math/tex; mode=display">\mathrm{R} _{\theta} = \left[\begin{array}{c} \cos \theta & -\sin \theta \\\sin \theta & \cos \theta\end{array}\right]</script></li></ul><p>在线性变换基础上加上常数项向量完成平移，但为了保持线性变换的一致性，在原本的坐标上抽象一维常数维构成齐次坐标</p><p>例如原本的</p><ul><li>向量 (vx, vy) -&gt; (vx, vy, 0) 其抽象维取 0 以确保向量和坐标间的运算性质</li><li>点 (x, y) -&gt; (x, y, w) 抽象维 w 通常配合 x、y 缩放至 1</li></ul><p>此时在齐次坐标下的仿射变换可以拥有和线性变换一致的写法</p><p><img src="/images/CG/Affine-Homogenous.png" alt=""></p><h3 id="逆变换"><a href="#逆变换" class="headerlink" title="逆变换"></a>逆变换</h3><p>在已知上方的变换矩阵时，左乘一个逆矩阵即可回归到原来的坐标</p><h3 id="三维变换"><a href="#三维变换" class="headerlink" title="三维变换"></a>三维变换</h3><p>也参考二维向量上对齐次坐标的抽象，构建 (x, y, z, w) 表示点坐标以及 (x, y, z, 0) 表示向量</p><p>通常延坐标轴旋转的变换矩阵可以直接退化成二维平面的旋转来计算；考虑任意的旋转，实际上也是以一个三维向量为轴线进行一定角度的变换，现有计算公式如下（以向量 n 为轴逆时针旋转角度 α）</p><p>Rodrigues’ Rotation Formula</p><script type="math/tex; mode=display">\mathbf{R}(\mathbf{n}, \alpha)=\cos (\alpha) \mathbf{I}+(1-\cos (\alpha)) \mathbf{n} \mathbf{n}^{T}+\sin (\alpha) \underbrace{\left(\begin{array}{ccc}0 & -n_{z} & n_{y} \\n_{z} & 0 & -n_{x} \\-n_{y} & n_{x} & 0\end{array}\right)}_{\mathbf{N}}</script><h4 id="视图变换-Viewport-Transformation"><a href="#视图变换-Viewport-Transformation" class="headerlink" title="视图变换 Viewport Transformation"></a>视图变换 Viewport Transformation</h4><p>首先通过平移、缩放操作将空间中任意矩形变换到 [-1,1]^3 的正方体区域，然后通过 viewport 变换到屏幕上以像素单位来显示，当确定屏幕的 宽高值 $n_x$、$n_y$ 之后即可通过简单的先缩放后平移变换完成</p><script type="math/tex; mode=display">\left[\begin{array}{c}   x_{screen} \\y_{screen} \\1\end{array}\right] = \left[\begin{array}{c}   \frac{n_x}{2} & 0 & \frac{n_x - 1}{2} \\0 & \frac{n_y}{2} & \frac{n_y - 1}{2} \\0 & 0 & 1\end{array}\right]\left[\begin{array}{c}   x_{canonical} \\y_{canonical} \\1\end{array}\right]</script><p>（上面用 $n_x-1$ 是由于像素从 0 开始计数）</p><h4 id="正交投影变换-Orthographic-Porjection-Transformation"><a href="#正交投影变换-Orthographic-Porjection-Transformation" class="headerlink" title="正交投影变换 Orthographic Porjection Transformation"></a>正交投影变换 Orthographic Porjection Transformation</h4><p>正交投影可以理解为在三维上舍弃掉一维，将较远平面的坐标投影到一个较近平面得到的视图，投影过程中不进行缩放变换</p><p>对空间任意一个长方体，都可以通过先平移再缩放的变换得到单位正方体，具体变换矩阵如下</p><p><img src="/images/CG/Orthographic-Projection.png" alt=""></p><h4 id="相机变换-Camera-Transformation"><a href="#相机变换-Camera-Transformation" class="headerlink" title="相机变换 Camera Transformation"></a>相机变换 Camera Transformation</h4><p>由当前视角所处位置坐标 e 以及其视线向量的正向<br>g 和上方朝向 t 来确定一个 View</p><p>习惯上总是通过变换将摄像视角置于三维空间原点，以 -Z 方向（符合右手系）为视角方向，Y 方向为正上方，因此以坐标 e 为原点重新构建右手系 (u, v, w)</p><p><img src="/images/CG/Viewport-Origin.png" alt=""></p><p>容易计算得到 (u, v, w) 的向量表示</p><script type="math/tex; mode=display">\begin{align} &  w = \frac{g}{\lVert g \rVert}, \\& u = \frac{t \times w}{\lVert t \times w \rVert}, \\& v = w \times u.\end{align}</script><p>要计算将 (u, v, w) 系变换到坐标中心的变换矩阵，只需要考虑其逆变换的变换矩阵然后取逆即可</p><script type="math/tex; mode=display">\mathbf{M}_{\mathrm{cam}}=\left[\begin{array}{llll}\mathbf{u} & \mathbf{v} & \mathbf{w} & \mathbf{e} \\0 & 0 & 0 & 1\end{array}\right]^{-1}=\left[\begin{array}{cccc}x_{u} & y_{u} & z_{u} & 0 \\x_{v} & y_{v} & z_{v} & 0 \\x_{w} & y_{w} & z_{w} & 0 \\0 & 0 & 0 & 1\end{array}\right]\left[\begin{array}{cccc}1 & 0 & 0 & -x_{e} \\0 & 1 & 0 & -y_{e} \\0 & 0 & 1 & -z_{e} \\0 & 0 & 0 & 1\end{array}\right]</script><h4 id="透视投影-Perspective-Projection"><a href="#透视投影-Perspective-Projection" class="headerlink" title="透视投影 Perspective Projection"></a>透视投影 Perspective Projection</h4><p>最常用的一种投影变换，需要确定两个与视线向量垂直的平面，将远平面的点投影到近平面上，由此可得相似性</p><p><img src="/images/CG/Similar-Triangle.png" alt=""></p><p>在以上的投影操作下，我们可以确保近平面上的点经过变换不发生变化，而远平面上的点经过变换其 z 值不发生变化， 此时假定近平面到视角点的距离为 n ，远平面到视角点的距离为 f ，即容易计算出缩放的变换矩阵</p><script type="math/tex; mode=display">\mathbf{P}=\left[\begin{array}{cccc}n & 0 & 0 & 0 \\0 & n & 0 & 0 \\0 & 0 & n+f & -f n \\0 & 0 & 1 & 0\end{array}\right]</script><p>最终确定的透视变换矩阵即为 $M<em>{per} = M</em>{orth} \mathbf{P}$</p><p>即先通过矩阵 P 比例缩放变换然后执行正交投影得到透视变换</p><p>综上，完成一个完整的透视变换：</p><ol><li>先执行视角变换将坐标系变换到视角系上</li><li>执行矩阵变换 P 将点都投射到近侧平面的视域范围内</li><li>执行正交投影变换完成透视</li></ol><script type="math/tex; mode=display">M = M_{vp}M_{orth}PM_{cam}</script><h4 id="视域确定-Field-of-View"><a href="#视域确定-Field-of-View" class="headerlink" title="视域确定 Field-of-View"></a>视域确定 Field-of-View</h4><p>上述讨论都是在确定前后两个平面条件下的代数解，实际使用中我们的近侧平面通常是将要被投射到的屏幕，即仅能够投射到屏幕范围内的模型可见，该屏幕可以由三个参数确定：</p><ol><li>屏幕尺寸 <code>r / t</code>，即 宽 / 高</li><li>视角到屏幕的距离 <code>|n|</code></li><li>视角到屏幕上边界的仰角大小 <code>θ / 2</code></li></ol><p>最终的画面呈现即空间中的坐标投影到该视域上的结果</p><p><img src="/images/CG/Field-of-View.png" alt=""></p><h4 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h4><ul><li>世界空间 World Space ：用于理解的三维空间，放置模型、相机、光源等</li><li>局部空间 Local Space ：也称模型空间，规定好模型正向 x 和上方 y 轴以及模型中心点，以此可确定模型上各点坐标</li></ul><ol><li>模型变换 ：依次处理模型自身的 缩放、旋转、平移，变换矩阵在模型空间上描述，得到 M<ul><li>任何的对模型自身的变换都只需要在这里以相应矩阵形式描述</li></ul></li><li>视野变换 ：将摄像机置于世界坐标中心的变换，可以考虑先做世界坐标到相机上的变换再求逆</li><li>投影变换 ：通常先正交再挤压形成透视投影</li></ol><h2 id="光栅化-Rasterization"><a href="#光栅化-Rasterization" class="headerlink" title="光栅化 Rasterization"></a>光栅化 Rasterization</h2><p>光栅 Raster 即德语中的 screen；光栅化即为将物体绘制在屏幕上的过程，其中主要涉及到的计数难点有反走样和 Z-buffering（针对模型前后重叠的显示）</p><p>像素 pixel 为屏幕上的最小单位，通常将其视为网格图中的各个方格，最左下角的顶点为 (0,0) 坐标，而每个像素中心点的坐标都为 ‘.5’</p><h3 id="采样-Sampling"><a href="#采样-Sampling" class="headerlink" title="采样 Sampling"></a>采样 Sampling</h3><p>在光栅化工作时，我们得到的输入通常以 <strong>三角形</strong> 区域来限定色彩（使用三角形能实现渐变等功能），而对于三角形包围的像素格，可以使用采样方法来判断其颜色</p><p>采样即判断像素中心是否处于三角形内部（循环叉积来判断）来确定该像素格的颜色，对边线上的自行规定即可</p><ul><li>锯齿 Jaggies ：使用采样方法来确定像素格颜色不可避免地会出现锯齿，当分辨率较低时尤其明显；为此研究出了<strong>反走样（antialiasing）</strong>方法</li><li>其他采样带来的瑕疵（artifacts）还有如摩尔纹、Wagon wheel effect 等；本质上都是采样频率远远不及信号变化频率造成的</li></ul><h3 id="反走样-Antialiasing"><a href="#反走样-Antialiasing" class="headerlink" title="反走样 Antialiasing"></a>反走样 Antialiasing</h3><p>具体需要学习信号处理知识，总之在图像上可以采用几种成体系的方法：</p><ol><li>下采样：先进行滤波（卷积操作）模糊化再执行采样</li><li>上采样：例如 MSAA，将单个像素细分后考察其位于三角形内的比例，以此比例作为原像素点的颜色分布来光栅化</li></ol><p>发展进程中有几种里程碑式的方法：</p><ol><li>FXAA（Fast Approximate AA）</li><li>TAA（Temporal AA） 动态模糊，沿用上一帧的高频信息</li><li>DLSS（Deep Learning Super Sampling）低分辨率到高分辨率，进行一定的猜测填充</li></ol><h3 id="可见性-Visibility-遮挡-Occlusion"><a href="#可见性-Visibility-遮挡-Occlusion" class="headerlink" title="可见性 Visibility / 遮挡 Occlusion"></a>可见性 Visibility / 遮挡 Occlusion</h3><p>在光栅化工作中，实际上将空间中的模型投射到给出的视域“虚拟屏幕”上，因此另一个显著的问题就是当多个模型在投射过程中重叠的情况，针对此研究出了 <strong>Z-Buffering 深度缓存</strong> 方法</p><ul><li>启发想法：画家算法描述了由远到近来执行绘画的方法，近侧的物体将在视图上覆盖远侧的物体；但此方法对例如循环叠放的三个平面就没法处理，深度实际上也很难定义</li><li>Z-Buffer ：在投射后每个像素上记录当前最小的 z-value 样本点的颜色信息<ul><li>使用两个 buffer 分别存储每个像素点的颜色和当前投射过程中已经记录的最小 z 值，在投射模型时比较目标像素上的 z 值大小，保留较小的（即较近的）即可</li></ul></li></ul><h2 id="代码演练"><a href="#代码演练" class="headerlink" title="代码演练"></a>代码演练</h2><p>借助 eigen3 库已经实现的 <strong>向量和矩阵</strong> 类进行基本的运算即可</p><p><a href="http://eigen.tuxfamily.org/dox/">eigen3 官方文档</a></p><p>注意其中大多数运算符都已经重载，而向量的点积和叉积则需要调用 Vector 对象的 <code>dot()</code> 和 <code>corss()</code> 方法</p><h3 id="旋转后平移"><a href="#旋转后平移" class="headerlink" title="旋转后平移"></a>旋转后平移</h3><p>传入角度和平移量的向量，完成先旋转后平移变换，输出变换后的向量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这里写成一个变换矩阵了，分解一下可知这种写法一定是先旋转后平移</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Eigen::Vector2d <span class="title">rotateAndTransport</span><span class="params">(Eigen::Vector2d p, <span class="type">double</span> theta, Eigen::Vector2d tp)</span> </span>&#123;</span><br><span class="line">    <span class="function">Eigen::Vector3d <span class="title">v</span><span class="params">(p[<span class="number">0</span>], p[<span class="number">1</span>], <span class="number">1.0</span>)</span></span>;</span><br><span class="line">    Eigen::Matrix3d mat;</span><br><span class="line"><span class="type">double</span> angle = theta / <span class="number">180.0</span> * std::<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">    mat &lt;&lt; std::<span class="built_in">cos</span>(angle), - std::<span class="built_in">sin</span>(angle), tp[<span class="number">0</span>],</span><br><span class="line">    std::<span class="built_in">sin</span>(angle), std::<span class="built_in">cos</span>(angle), tp[<span class="number">1</span>],</span><br><span class="line">    <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">auto</span> res = mat * v;</span><br><span class="line">    <span class="keyword">return</span> Eigen::<span class="built_in">Vector2d</span>(res[<span class="number">0</span>], res[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="光栅化实现"><a href="#光栅化实现" class="headerlink" title="光栅化实现"></a>光栅化实现</h3><p>课程提供的框架中首先实现了一个 Triangle 类可记录三个顶点的坐标以及顶点的颜色、材质等</p><ol><li>分别针对摄像机视角，模型的仿射变换，透视投影的仰角和前后投射面设计好相应的函数用于存储变换矩阵，最终仅当要完成光栅化时按照顺序应用变换矩阵<ul><li>Model Transformation : 模型变换由 “旋转轴向量和旋转角度” 以及后续的 “平移操作” 确定变换矩阵</li><li>Camera Transformation : 相机变换由 相机位置坐标 、相机朝向、相机正上朝向 确定变换矩阵</li><li>Perspective Projection : 透视投影由 视野仰角、视域宽长比、投射远近平面距离 确定变换矩阵，记得在压缩后执行 “正交投影”</li><li>Viewport Transformation : 在透视投影后变换至标准正方体区域</li></ul></li><li>Z-Buffering 在光栅化的末尾步骤考虑，对显示区域的每个像素（简单模型可以先缩小其覆盖的 box 范围）记录其当前深度与颜色，在逐步执行模型光栅化时比较深度，若像素点深度更小则更新颜色，否则表面该模型对应的像素已经被遮挡<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check if the point (x, y) is inside the triangle represented by _v[0], _v[1], _v[2]</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">insideTriangle</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">const</span> Vector3f* _v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> i2 = (i + <span class="number">1</span>) % <span class="number">3</span>, i3 = (i + <span class="number">2</span>) % <span class="number">3</span>;</span><br><span class="line">        Eigen::Vector3f edge_vec1 = Eigen::<span class="built_in">Vector3f</span>(_v[i2].<span class="built_in">x</span>() - _v[i].<span class="built_in">x</span>(), _v[i2].<span class="built_in">y</span>() - _v[i].<span class="built_in">y</span>(), <span class="number">0.0</span>);</span><br><span class="line">        Eigen::Vector3f edge_vec2 = Eigen::<span class="built_in">Vector3f</span>(_v[i3].<span class="built_in">x</span>() - _v[i].<span class="built_in">x</span>(), _v[i3].<span class="built_in">y</span>() - _v[i].<span class="built_in">y</span>(), <span class="number">0.0</span>);</span><br><span class="line">        Eigen::Vector3f pnt_vec1 = Eigen::<span class="built_in">Vector3f</span>((x + x + <span class="number">1</span>) / <span class="number">2.0</span> - _v[i].<span class="built_in">x</span>(), (y + y + <span class="number">1</span>) / <span class="number">2.0</span> - _v[i].<span class="built_in">y</span>(), <span class="number">0.0</span>);</span><br><span class="line">        <span class="keyword">if</span> (edge_vec1.<span class="built_in">cross</span>(edge_vec2).<span class="built_in">dot</span>(edge_vec1.<span class="built_in">cross</span>(pnt_vec1)) &lt;= <span class="number">0.0</span> + std::numeric_limits&lt;<span class="type">float</span>&gt;::<span class="built_in">epsilon</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Screen space resterization</span></span><br><span class="line"><span class="type">void</span> rst::Rasterizer::<span class="built_in">rasterizeTriangle</span>(<span class="type">const</span> Triangle&amp; t) &#123;</span><br><span class="line">    <span class="keyword">auto</span> v = t.<span class="built_in">toVector4</span>();</span><br><span class="line">    <span class="type">int</span> l = std::numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    <span class="type">int</span> b = l, r = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[i].<span class="built_in">x</span>() &lt;= l) &#123; l = (<span class="type">int</span>) v[i].<span class="built_in">x</span>(); &#125;</span><br><span class="line">        <span class="keyword">if</span> (v[i].<span class="built_in">x</span>() &gt;= r) &#123; r = (<span class="type">int</span>) v[i].<span class="built_in">x</span>() + <span class="number">1</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (v[i].<span class="built_in">y</span>() &lt;= b) &#123; b = (<span class="type">int</span>) v[i].<span class="built_in">y</span>(); &#125;</span><br><span class="line">        <span class="keyword">if</span> (v[i].<span class="built_in">y</span>() &gt;= tt) &#123; tt = (<span class="type">int</span>) v[i].<span class="built_in">y</span>() + <span class="number">1</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt; r; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = b; j &lt; tt; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">insideTriangle</span>(i, j, t.v)) &#123;</span><br><span class="line">                <span class="keyword">auto</span>[alpha, beta, gamma] = <span class="built_in">computeBarycentric2D</span>(i, j, t.v);</span><br><span class="line">                <span class="type">float</span> w_reciprocal = <span class="number">1.0</span> / (alpha / v[<span class="number">0</span>].<span class="built_in">w</span>() + beta / v[<span class="number">1</span>].<span class="built_in">w</span>() + gamma / v[<span class="number">2</span>].<span class="built_in">w</span>());</span><br><span class="line">                <span class="type">float</span> z_interpolated = alpha * v[<span class="number">0</span>].<span class="built_in">z</span>() / v[<span class="number">0</span>].<span class="built_in">w</span>() + beta * v[<span class="number">1</span>].<span class="built_in">z</span>() / v[<span class="number">1</span>].<span class="built_in">w</span>() + gamma * v[<span class="number">2</span>].<span class="built_in">z</span>() / v[<span class="number">2</span>].<span class="built_in">w</span>();</span><br><span class="line">                z_interpolated *= w_reciprocal;</span><br><span class="line">                <span class="keyword">if</span> (z_interpolated &lt; depth_buf_[i + j * width_]) &#123;</span><br><span class="line">                    depth_buf_[i + j * width_] = z_interpolated;</span><br><span class="line">                    <span class="built_in">setPixel</span>(Eigen::<span class="built_in">Vector3f</span>(i, j, <span class="number">1.0f</span>), t.<span class="built_in">getColor</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Overview-of-Computer-Graphics&quot;&gt;&lt;a href=&quot;#Overview-of-Computer-Graphics&quot; class=&quot;headerlink&quot; title=&quot;Overview of Computer Graphics&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Games-Graphics" scheme="http://remedios14.github.io/categories/Games-Graphics/"/>
    
    
    <category term="games" scheme="http://remedios14.github.io/tags/games/"/>
    
    <category term="计算机图形学" scheme="http://remedios14.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>unity游戏开发（3）</title>
    <link href="http://remedios14.github.io/2022/04/30/Unity/unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%EF%BC%883%EF%BC%89/"/>
    <id>http://remedios14.github.io/2022/04/30/Unity/unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%EF%BC%883%EF%BC%89/</id>
    <published>2022-04-30T07:24:11.000Z</published>
    <updated>2022-04-30T07:24:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用 unity 制作 3D 游戏基本上没有很大差异，因为 2D 游戏也存在 z 轴，可以体现出游戏对象相对于摄像机的远近层级；本篇仅补充 3D 项目相对于 2D 项目的差别</p><h2 id="相对差异"><a href="#相对差异" class="headerlink" title="相对差异"></a>相对差异</h2><h3 id="层级对象-Hierarchy"><a href="#层级对象-Hierarchy" class="headerlink" title="层级对象 Hierarchy"></a>层级对象 Hierarchy</h3><ol><li>3D 项目的新场景内预置的除开 Main Camera 对象还有一个 Directional Light 表示场景光源</li></ol><h4 id="3D-模型对象"><a href="#3D-模型对象" class="headerlink" title="3D 模型对象"></a>3D 模型对象</h4><ul><li>自带的几种 3D 基本模型，右击在 3D Object 选单中：<ul><li>Cube 立方体；Sphere 球体；Capsule 胶囊体；Cylinder 圆柱体；Plane 平面 …</li><li>平面是没有厚度的，且正面可见背面透明；其他立体模型从内部观察也是透明的</li></ul></li><li>针对对象可以进行平移、旋转、缩放操作，左上角选择操纵模式（或 W、E、R 快捷键切换）或者直接修改 Transform 数值<ul><li>对象的平移操作有 Global 模式和 Local 模式，前者以世界坐标系平移，后者以对象自身坐标系平移（例如旋转后），在 Scene 栏左上角切换<ul><li>平移方向 right、up、forward 分别表示 x、y、z 轴向</li></ul></li><li>轴心点 Pivot 在自建模型时可以指定，作为旋转操作的参考；自带几何体的轴心点就在几何中心位置；另有几何中心点模式 Center；同样在左上切换</li></ul></li><li>模型属性查看<ul><li>观察模式：在 Scene 栏的左上方可以选择 shading mode；任何模型表面都是由若干三角面围成（建模资源本身如此）<ul><li>Shaded 着色模式，显示模型的表面材质</li><li>Wireframe 线框模式，仅显示模型网格</li><li>Shaded Wireframe 线框着色模式，同时显示</li></ul></li><li>材质资源：对象的 Material 属性在其 Mesh Render 组件中（可以构成数组来关联多个材质），可以自建材质资源来应用到各个对象上<ul><li>一个模型总是有默认材质的，而若其材质为 None，则显示上变成纯浅紫色</li><li>Albedo 可以选择材质的纹理，或者给其指定贴图；右侧上色</li></ul></li></ul></li><li>导入外部模型，标准模型格式为 FBX，导入到 Unity 资源可以看到其包含 网格、材质以及单独的贴图文件<ul><li>外部导入的模型，其材质资源被包含在 FBX 压缩内，可以选中资源后在 Inspector 栏进行重映射进行修改或者 Extract 来提取材质</li><li>FBX 压缩模型资源可以直接使用其网格和材质作为资源</li></ul></li></ul><p><strong>补充</strong>：摄像机对象可以正常旋转平移等操作；先选中 Main Camera 在工具栏 GameObject-&gt;Align With View 将摄像头视角摆到当前视角上（对其他对象也可以）</p><h4 id="3D-对象常用组件"><a href="#3D-对象常用组件" class="headerlink" title="3D 对象常用组件"></a>3D 对象常用组件</h4><ul><li>Light 光源组件</li><li>Mesh Filter 网格过滤器</li><li>Mesh Renderer 网格渲染器</li></ul><h3 id="场景视图-Scene"><a href="#场景视图-Scene" class="headerlink" title="场景视图 Scene"></a>场景视图 Scene</h3><p>3D 场景的视图中含有几个元素：</p><ul><li>导航器 Gizmo，表示世界坐标的方向，给出当前视角下的 XYZ 方向<ul><li>按住 shift 点中间的方体可以恢复方向</li><li>分别点击某个轴向得到相应轴向的视图</li></ul></li><li>栅格 Grid，表示 XZ 坐标平面，Y 轴为纵向高低</li><li>天空盒 Skybox，表示游戏世界的背景</li></ul><p>操作视图：</p><ul><li>旋转视图：alt + 左键拖拽（Unity 仅支持以视图中心进行旋转，如果希望以对象为中心旋转，可以选中对象然后按 F 将其置于视图中心）</li><li>缩放视图：<ul><li>鼠标滚轮</li><li>alt + 右键拖拽（精细缩放）</li></ul></li><li>平移视图：中键拖拽</li><li>视图模式切换：<ul><li>默认使用透视模式，会有近大远小的效果，不方便物品对齐；在导航器下方的位置单击进行切换，转为正交视图，可以完全正交于一个平面观察</li></ul></li></ul><p>补充注意项：</p><ul><li>新增对象时默认放置在当前视图的中心点坐标，而非世界坐标零点</li></ul><h3 id="脚本操作"><a href="#脚本操作" class="headerlink" title="脚本操作"></a>脚本操作</h3><p>通常的移动操作和 2D 没有差异</p><h2 id="粒子特效"><a href="#粒子特效" class="headerlink" title="粒子特效"></a>粒子特效</h2><p>Unity 自带的粒子系统 Particle System；用于模拟一些流动的、没有形状的物质，如：液体、烟雾、火焰、爆炸、魔法效果等</p><h2 id="粒子系统-Particle-System"><a href="#粒子系统-Particle-System" class="headerlink" title="粒子系统 Particle System"></a>粒子系统 Particle System</h2><p>在层级界面右击 Effects-&gt;Particle System 创建粒子特效，可以看到一个播放式的对象；此对象功能主要由 <strong>Particle System 组件</strong>实现，其主模块下有 22 个子模块，默认启用了 Emission / Shape / Render 三个模块</p><p>选中带粒子系统组件的对象即有一个预览播放窗口，可以执行播放、暂停、变速等</p><h3 id="模块与参数"><a href="#模块与参数" class="headerlink" title="模块与参数"></a>模块与参数</h3><ul><li>主模块 Main Module：设置粒子的基本参数，例如速度、颜色、大小等（其中能由单词确定的暂略）<ul><li>Duration 周期，粒子系统的工作时长</li><li>Looping 循环，粒子系统是否循环工作</li><li>Prewarm 预热，粒子系统是否先内部预热一个周期（不预热就会有从 0 开始的效果，否则一开始就有很多粒子）</li><li>Start Lifetime 粒子的生命时长，默认 5 秒</li><li>Simulation Space 可选择的样式，Local 时粒子位置总是相对对象坐标；World 模式粒子释放后仅相对世界坐标</li></ul></li></ul><h4 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h4><ul><li>Emission ，发射的频率（禁用则不发射任何粒子）<ul><li>匀速发射模式：修改前两项，Rate over Time 数值表示每秒发射 N 个粒子；Rate over Distance 表示对象每前进 1 米发射 N 个粒子（一般作为子对象时使用）</li><li>爆发发射模式：列表形式的设置，每个值可以设计五个参数 —— Time 爆炸发生的时间；Count 爆发出多少粒子；Cycles / Interval 爆炸次数和间隔（可以无限次）；Probability 爆炸的概率，0 表示不爆炸（哑弹）</li></ul></li><li>Shape ，粒子发生器的形状，用于限定所有粒子的运动范围<ul><li>Shape 默认 Cone 表示圆锥，Mesh 可以设置网格资源，Sprite 可以设置图像资源</li><li>禁用 Shape 则仅延对象的本地 z 轴向发射</li></ul></li><li>Renderer ，粒子的显示与渲染<ul><li>Render Mode 表示渲染模式，默认 Billboard 广告牌模式，平面总是朝向摄像机视角（任意角度观察都是平面）</li><li>Material 可以设置材质资源，修改后可见每个粒子都是一个方形的平面<ul><li><a href="http://t.zoukankan.com/jiahuafu-p-14201929.html"><strong>粒子着色器</strong></a> ：通常我们希望用于粒子特效的材质资源具有透明背景（由 PS修改）：<br>但不理想的时候用黑色背景也可以对材质进行设置：1. 将 Shader 改为 Particle/Standard Unilt；2. Render Mode 改为 Additive；3. Color Mode 改为 Multiply；4. Albedo 改为 “指定贴图” （大概是图像掩码）</li></ul></li></ul></li></ul><hr><p>颜色相关</p><ul><li>Color over lifetime ，随粒子生命周期颜色渐变；当同时设置 Start Color 和渐变色时，会对两个颜色进行点乘得到颜色</li><li>Size over lifetime ，大小渐变，编辑渐变曲线可双击增加控制点</li></ul><hr><p>速度相关</p><ul><li>Velocity over lifetime ，速度渐变，和初始速度加法结算；结合 Circle 等形状修改 Orbital （轨道速度）可以实现环形扩散</li></ul><p>（旋转 Rotation 略）</p><hr><p>作用力控制</p><ul><li>Force over lifetime ，作用力，可以分方向给常量或曲线变量</li><li>Limit velocity over lifetime ，速度衰减（介质阻力）<ul><li>Drag ，摩擦系数、模拟介质阻力；结合下面两项相乘结算</li></ul></li><li>Noise ，噪声（来自于介质的扰动）</li></ul><hr><p>粒子碰撞</p><ul><li>Collision 模块<ul><li>Type 指定若干个平面用于碰撞检测（一般作为子对象并隐藏视图）；或者 World 类型可以指定各种碰撞体对象（不推荐，耗费性能）</li><li>可以针对粒子碰撞事件编写脚本，步骤如下：<ol><li>添加脚本并挂载在粒子系统对象上</li><li>脚本覆写事件函数 OnParticleCollision</li><li>Collision 模块中勾选 Send Collision Message</li></ol></li></ul></li></ul><hr><p>视觉效果</p><ul><li>Trails ，实现粒子的拖尾效果</li><li>Texture Sheet Animation ，用帧动画实现粒子效果，可以调整帧率等</li><li>Lights ，让发射的粒子携带一个点光源，需要引用一个点光源预制体（或对象）</li><li>Sub Emitters ，引用一个粒子发射器，可以实现当一级粒子消亡时执行二级粒子发射器等效果</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用 unity 制作 3D 游戏基本上没有很大差异，因为 2D 游戏也存在 z 轴，可以体现出游戏对象相对于摄像机的远近层级；本篇仅补充 3D 项目相对于 2D 项目的差别&lt;/p&gt;
&lt;h2 id=&quot;相对差异&quot;&gt;&lt;a href=&quot;#相对差异&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Unity" scheme="http://remedios14.github.io/categories/Unity/"/>
    
    
    <category term="入门介绍" scheme="http://remedios14.github.io/tags/%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/"/>
    
    <category term="3D游戏" scheme="http://remedios14.github.io/tags/3D%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV功能分类链接</title>
    <link href="http://remedios14.github.io/2022/04/16/OpenCV/OpenCV%E9%80%9F%E6%9F%A5%E8%A1%A8%E5%8F%8A%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://remedios14.github.io/2022/04/16/OpenCV/OpenCV%E9%80%9F%E6%9F%A5%E8%A1%A8%E5%8F%8A%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2022-04-16T09:36:14.000Z</published>
    <updated>2022-07-06T14:58:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>按照 OpenCV 对外接口的功能分类，在此给出速查表形式的记录</p><ul><li><a href="../../../10/OpenCV/OpenCV简述及接口（一）/#图像视频的加载和显式">图像基本操作</a>：包括创建窗体、读写图像和视频素材等；获取到图像对象为一个 ndarray，可以执行一下几类操作<ul><li><a href="../../../11/OpenCV/OpenCV简述及接口（二）/#图像的分割与融合">颜色通道操作</a>：split 、merge 操作</li><li><a href="../../../11/OpenCV/OpenCV简述及接口（二）/#拷贝操作">对象拷贝</a>：对象方法 view 和 copy 分别浅、深拷贝</li><li><a href="../../../11/OpenCV/OpenCV简述及接口（二）/#为图像设置边框">边界填充</a>： copyMakeBorder 函数扩大原图像范围，加上边框</li><li><a href="../../../11/OpenCV/OpenCV简述及接口（二）/#基本运算">对象运算</a> ：包括 ndarray 对象重载的运算符操作和 cv2 定义的函数运算；图像融合可通过加权的加法运算完成</li><li><a href="../../../11/OpenCV/OpenCV简述及接口（二）/#绘制图形">线条文字绘制</a></li></ul></li><li>图像自变换：针对图像自身的像素点分布和值特征做变换<ul><li><a href="../../../10/OpenCV/OpenCV简述及接口（一）/#二值化">图像二值化</a> ：设定一个阈值和类型来对图像自身执行变换</li><li><a href="../../../12/OpenCV/OpenCV简述及接口（三）/#滤波器">图像平滑</a>：使用卷积核平滑处理图像像素，如清洗椒盐噪声等</li><li><a href="../../../12/OpenCV/OpenCV简述及接口（三）/#仿射变换">图像仿射变换</a>：包括平移、旋转、透视变换，通过数学上变换矩阵实现</li></ul></li><li><a href="../../../12/OpenCV/OpenCV简述及接口（三）/#形态学转换">图像形态学变换</a>：包括侵蚀 erode、扩张 dilate 等操作</li><li><a href="../../../12/OpenCV/OpenCV简述及接口（三）/#算子">图像梯度计算</a>：图像的梯度反映了像素点上值的变化趋势，一定程度上描述了物体轮廓；有 Sobel 算子、Scharr 算子、拉普拉斯算子等</li><li><a href="../../../12/OpenCV/OpenCV简述及接口（三）/#边缘检测Canny">边缘检测</a></li><li><a href="../../../10/OpenCV/OpenCV简述及接口（一）/#图像金字塔">图像金字塔</a>：通过高斯卷积核对图像执行两倍的缩小和放大操作，做差运算获取轮廓信息</li><li><a href="../../../11/OpenCV/OpenCV简述及接口（二）/#获取及绘制轮廓">轮廓检测</a>：捕获一般的轮廓特征和一些特殊性的轮廓特征（如拐角等）；以及轮廓近似操作</li><li><a href="../../../14/OpenCV/OpenCV简述及接口（四）/#模板匹配">模板匹配</a>：逐个像素滑动来比较计算相似度，返回一个目标图像大小减去匹配图像大小的对象，每个位置的值表示以此位置为左上角的区域相似度</li><li><a href="../../../14/OpenCV/OpenCV简述及接口（四）/#直方图">直方图</a>：根据像素点的值作为横轴（可能分箱）统计点个数绘制直方图；衍生出均衡算法等来提升图像表现力，如对比度</li><li>进阶算法<ul><li><a href="../../../14/OpenCV/OpenCV简述及接口（四）/#傅里叶变换">傅里叶变换</a></li></ul></li></ul><h2 id="常用功能组"><a href="#常用功能组" class="headerlink" title="常用功能组"></a>常用功能组</h2><h3 id="前后对比识别"><a href="#前后对比识别" class="headerlink" title="前后对比识别"></a>前后对比识别</h3><p>参考别人完成的聊天窗口识别，当前后发生足够的偏差（有人发出新消息）后再执行，其中对比工作通过计算图像直方图的方差完成，大致代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">histCompare</span>(<span class="params">img1, img2, layer = <span class="number">0</span></span>):</span><br><span class="line">    hist1 = cv2.calcHist([img1], [layer], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">    hist2 = cv2.calcHist([img2], [layer], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">    </span><br><span class="line">    h1 = hist1[:, <span class="number">0</span>]</span><br><span class="line">    h2 = hist2[:, <span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    res = math.sqrt(reduce(operator.add, </span><br><span class="line">        <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> a, b:(a-b)**<span class="number">2</span>, h1, h2))) / <span class="built_in">len</span>(h1))</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><hr><p>感觉上面的不好阅读，而且使用中没找到合适的阈值用于检测；实际上可以直接利用 numpy 的 array 运算完成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">varCompare</span>(<span class="params">pre, cur, l = <span class="number">0</span></span>):</span><br><span class="line">    hist1 = cv2.calcHist([pre], [l], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">    hist2 = cv2.calcHist([cur], [l], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">    </span><br><span class="line">    h1 = hist1[:, <span class="number">0</span>]</span><br><span class="line">    h2 = hist2[:, <span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    res = (h2 - h1).var() / <span class="number">256</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;按照 OpenCV 对外接口的功能分类，在此给出速查表形式的记录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;../../../10/OpenCV/OpenCV简述及接口（一）/#图像视频的加载和显式&quot;&gt;图像基本操作&lt;/a&gt;：包括创建窗体、读写图像和视频素材等；获取到图像对</summary>
      
    
    
    
    <category term="OpenCV" scheme="http://remedios14.github.io/categories/OpenCV/"/>
    
    
    <category term="python" scheme="http://remedios14.github.io/tags/python/"/>
    
    <category term="opencv" scheme="http://remedios14.github.io/tags/opencv/"/>
    
    <category term="short-cuts" scheme="http://remedios14.github.io/tags/short-cuts/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV简述及接口（四）</title>
    <link href="http://remedios14.github.io/2022/04/14/OpenCV/OpenCV%E7%AE%80%E8%BF%B0%E5%8F%8A%E6%8E%A5%E5%8F%A3%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://remedios14.github.io/2022/04/14/OpenCV/OpenCV%E7%AE%80%E8%BF%B0%E5%8F%8A%E6%8E%A5%E5%8F%A3%EF%BC%88%E5%9B%9B%EF%BC%89/</id>
    <published>2022-04-14T05:37:47.000Z</published>
    <updated>2022-05-24T07:19:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h2><h3 id="灰度直方图"><a href="#灰度直方图" class="headerlink" title="灰度直方图"></a>灰度直方图</h3><ul><li>calcHist(images, channels, mask, histSize, ranges[, hist, accumulate]) 根据图片得到灰度（或颜色值）的分箱，返回 histSize × 1 的数组<ul><li>images 应当以 mat 对象的列表形式给出</li><li>channels 直方图的通道的索引（灰度图传 [0]），以列表给出</li><li>mask 通常为 None 来全局统计，否则给出区域的掩码图像</li><li>histSize 表示 bin 计数，通常 [256]</li><li>ranges 各像素点的取值范围 [0, 256]<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 灰度图可以直接由 matplotlib 实现</span></span><br><span class="line">plt.hist(imgray.ravel(),<span class="number">256</span>,[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># 彩色图可以分颜色实现</span></span><br><span class="line">color = (<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i, col <span class="keyword">in</span> <span class="built_in">enumerate</span>(color):</span><br><span class="line">    histr = cv2.calcHist([img],[i],<span class="literal">None</span>,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">    plt.plot(histr,color=col)</span><br><span class="line">    plt.xlim([<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="直方图均衡"><a href="#直方图均衡" class="headerlink" title="直方图均衡"></a>直方图均衡</h3><p>将集中分布（像素值接近）的直方图拉伸到两端（像素值范围广）形成较均衡的直方图；通常会提高图像的对比度；对于图像像素值局限在一个区域的对象效果最好</p><p>使用一个均衡化函数将各像素值转变，因此是可逆的；原理是根据累积分布函数将图像的原始分布范围展开到 [0,255] 范围</p><script type="math/tex; mode=display">S_k = \sum^k_{j=0}\frac{n_j}{n} \space k=0,1,2,...,L-1</script><ul><li>numpy 实现：借助掩码数组获取到映射来完成<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hist,bins = np.histogram(img.flatten(),<span class="number">256</span>,[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line">cdf = hist.cumsum()</span><br><span class="line">cdf_m = np.ma.masked_equal(cdf, <span class="number">0</span>)</span><br><span class="line">cdf_m = (cdf_m - cdf_m.<span class="built_in">min</span>()) * <span class="number">255</span> / (cdf_m.<span class="built_in">max</span>()-cdf_m.<span class="built_in">min</span>())</span><br><span class="line">cdf = np.ma.filled(cdf_m, <span class="number">0</span>).astype(<span class="string">&#x27;uint8&#x27;</span>) <span class="comment"># 小数转为整数</span></span><br><span class="line">img2 = cdf[img]</span><br></pre></td></tr></table></figure></li><li>opencv 实现：封装好函数了，直接用就行<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">equ = cv2.equalizeHist(img)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;res&#x27;</span>, np.hstack((img, equ)))</span><br></pre></td></tr></table></figure></li></ul><h4 id="CLAHE"><a href="#CLAHE" class="headerlink" title="CLAHE"></a>CLAHE</h4><p>对比度受限的自适应直方图均衡：将图像分成多个小块然后分别进行直方图均衡（opencv 中默认 8 × 8），为了避免小范围内的噪声而加上了对比度限制 —— 若某个直方图的 bins 数超过对比度限制（默认 40） 则先裁切像素并分配到其他 bin</p><ul><li>createCLAHE([, clipLimit, tileGridSize]) 创建一个 CLANE 对象（类似卷积核），然后可调用其 apply 方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clahe = cv.createCLAHE(clipLimit=<span class="number">2.0</span>, tileGridSize=(<span class="number">8</span>,<span class="number">8</span>))</span><br><span class="line">cl1 = clahe.apply(img)</span><br><span class="line">cv.imshow(<span class="string">&#x27;clahe_2&#x27;</span>,cl1)</span><br></pre></td></tr></table></figure><h3 id="二维直方图"><a href="#二维直方图" class="headerlink" title="二维直方图"></a>二维直方图</h3><p>通常用于处理每个像素的 <strong>色相和饱和度</strong> 两个特征</p><p>仍使用 calcHist 函数计算，传入二维时做出相应的修改（或者 np 也有）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hsv = cv.cvtColor(img,cv.COLOR_BGR2HSV)</span><br><span class="line">hist = cv.calcHist([hsv], [<span class="number">0</span>, <span class="number">1</span>], <span class="literal">None</span>, [<span class="number">180</span>, <span class="number">256</span>], [<span class="number">0</span>, <span class="number">180</span>, <span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line"><span class="comment"># hist, xbins, ybins = np.histogram2d(h.ravel(), s.ravel(),[180,256],[[0,180],[0,256]])</span></span><br><span class="line">plt.imshow(hist, interpolation = <span class="string">&#x27;nearest&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p>其中 色相值介于 0 到 180；饱和度介于 0 到 256</p><h3 id="直方图反投影"><a href="#直方图反投影" class="headerlink" title="直方图反投影"></a>直方图反投影</h3><p>一个论文中给出的方法，用于图像分割或在图像中查找感兴趣的对象。其创建一个与输入图像同大小的单通道图像，每个像素位置表示该点属于目标物体的概率。与 camshift 等算法配合使用</p><ul><li>calcBackProject(images, channels, hist, ranges, scale)<ul><li>可以切片原图的一个区域来代替下例的 rose<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">roi = cv2.imread(<span class="string">&#x27;rose_red.png&#x27;</span>)</span><br><span class="line">hsv = cv2.cvtColor(roi,cv.COLOR_BGR2HSV)</span><br><span class="line">target = cv2.imread(<span class="string">&#x27;rose.png&#x27;</span>)</span><br><span class="line">hsvt = cv2.cvtColor(target,cv.COLOR_BGR2HSV)</span><br><span class="line"><span class="comment"># 计算对象的直方图</span></span><br><span class="line">roihist = cv2.calcHist([hsv],[<span class="number">0</span>, <span class="number">1</span>], <span class="literal">None</span>, [<span class="number">180</span>, <span class="number">256</span>], [<span class="number">0</span>, <span class="number">180</span>, <span class="number">0</span>, <span class="number">256</span>] )</span><br><span class="line"><span class="comment"># 直方图归一化并利用反传算法</span></span><br><span class="line">cv2.normalize(roihist,roihist,<span class="number">0</span>,<span class="number">255</span>,cv.NORM_MINMAX)</span><br><span class="line">dst = cv2.calcBackProject([hsvt],[<span class="number">0</span>,<span class="number">1</span>],roihist,[<span class="number">0</span>,<span class="number">180</span>,<span class="number">0</span>,<span class="number">256</span>],<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 用圆盘进行卷积</span></span><br><span class="line">disc = cv2.getStructuringElement(cv.MORPH_ELLIPSE,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">cv2.filter2D(dst,-<span class="number">1</span>,disc,dst)</span><br><span class="line"><span class="comment"># 应用阈值作与操作</span></span><br><span class="line">ret,thresh = cv2.threshold(dst,<span class="number">50</span>,<span class="number">255</span>,<span class="number">0</span>)</span><br><span class="line">thresh = cv2.merge((thresh,thresh,thresh))</span><br><span class="line">res = cv2.bitwise_and(target,thresh)</span><br><span class="line">res = np.vstack((target,thresh,res))</span><br><span class="line">cv2.imshow(<span class="string">&#x27;res&#x27;</span>,res)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="进阶接口"><a href="#进阶接口" class="headerlink" title="进阶接口"></a>进阶接口</h2><p>简述原理和调用方法，很多高效图像算法都已封装完成</p><h3 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h3><h4 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h4><p>忽视时间上的顺序，仅考虑时域内的频率，构成一个频域；用于分析各种滤波器的频率特性</p><p><a href="https://zhuanlan.zhihu.com/p/19763358">参考知乎链接</a></p><ul><li>作用<ul><li>高频表示变化剧烈的灰度分量，比如轮廓边界</li><li>低频表示变化缓慢的灰度分量，例如一片草原</li></ul></li><li>滤波器<ul><li>低通滤波器仅保留低频，会使图像模糊</li><li>高通滤波器仅保留高频，会使图像细节增强</li></ul></li></ul><h4 id="Numpy-实现"><a href="#Numpy-实现" class="headerlink" title="Numpy 实现"></a>Numpy 实现</h4><ul><li>np.fft.fft2(a, s=None, axes=(-2, -1), norm=None)<ul><li>输入一个数组（我们使用灰度图像）</li><li>s 表示输出大小，会依据大小进行填充 0 或裁切；默认 None 则和输入大小一致</li></ul></li></ul><h4 id="OpenCV-实现"><a href="#OpenCV-实现" class="headerlink" title="OpenCV 实现"></a>OpenCV 实现</h4><p>传入对象需要转为至少 np.float32 格式</p><ul><li>dtf() ：执行正向傅里叶变换，返回的结果是双通道的（实部，虚部），需要转换成图像格式</li><li>idft() ：逆向傅里叶变换</li></ul><p><strong>注意</strong>：得到的结果中频率为 0 的部分会在左上角，通常要转换到中心位置，通过 shift 变换来实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">&#x27;lena.webp&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">img_float32 = np.float32(img)</span><br><span class="line">dft = cv2.dft(img_float32, flags = cv2.DFT_COMPLEX_OUTPUT)</span><br><span class="line">dft_shift = np.fft.fftshift(dft) <span class="comment"># 执行 shift 变换</span></span><br><span class="line"></span><br><span class="line">magnitude_spectrum = <span class="number">20</span>*np.log(cv2.magnitude(dft_shift[:,:,<span class="number">0</span>], dft_shift[:,:,<span class="number">1</span>])) </span><br><span class="line"><span class="comment"># cv2.imshow(&#x27;ftt&#x27;, magnitude_spectrum) # 仅查看频率图</span></span><br><span class="line"></span><br><span class="line">rows, cols = img.shape</span><br><span class="line">crow, ccol = <span class="built_in">int</span>(rows/<span class="number">2</span>), <span class="built_in">int</span>(cols/<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 低通滤波，以中心保留 30 像素作为掩码（中心最低）</span></span><br><span class="line">mask_l = np.zeros((rows, cols, <span class="number">2</span>), np.uint8)</span><br><span class="line">mask_l[crow-<span class="number">30</span>:crow+<span class="number">30</span>, ccol-<span class="number">30</span>:ccol+<span class="number">30</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">fshift = dft_shift*mask</span><br><span class="line">f_ishift = np.fft.ifftshift(fshift) <span class="comment"># 要逆 shift 变换</span></span><br><span class="line">img_l = cv2.idft(f_ishift)</span><br><span class="line">img_l = cv2.magnitude(img_l[:,:,<span class="number">0</span>], img_l[:,:,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 高通滤波，类比低通滤波，外部作为 1 即可</span></span><br><span class="line">mask_h = np.ones((rows, cols, <span class="number">2</span>), np.uint8)</span><br><span class="line">mask_h[crow-<span class="number">30</span>:crow+<span class="number">30</span>, ccol-<span class="number">30</span>:ccol+<span class="number">30</span>] = <span class="number">0</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><h3 id="模板匹配"><a href="#模板匹配" class="headerlink" title="模板匹配"></a>模板匹配</h3><p>使用模板图像在目标图像中查找；可以理解为将模板图像在目标中滑动比较来得到较匹配的位置</p><h4 id="OpenCV-中的模板匹配"><a href="#OpenCV-中的模板匹配" class="headerlink" title="OpenCV 中的模板匹配"></a>OpenCV 中的模板匹配</h4><ul><li>matchTemplate(image, templ, method) 返回一个灰度图像，每个像素表示该像素的邻域与模板匹配的程度，结合 minMaxLoc() 来定位最匹配位置的左上角</li><li>上函数中的可选 method<ul><li>TM_CCOEFF</li><li>TM_CCOEFF_NORMED</li><li>TM_CCORR —— 效果不佳</li><li>TM_CCORR_NORMED</li><li>TM_SQDIFF —— 平方误差和做损失，使用此方法时应找最低值表示最匹配</li><li>TM_SQDIFF_NORMED</li></ul></li></ul><h4 id="多对象的模板匹配"><a href="#多对象的模板匹配" class="headerlink" title="多对象的模板匹配"></a>多对象的模板匹配</h4><p>当目标图像存在多个匹配位置时，应当使用阈值化来定位</p><h3 id="霍夫曼变换"><a href="#霍夫曼变换" class="headerlink" title="霍夫曼变换"></a>霍夫曼变换</h3><p>在二维坐标系上的直线可以由垂线的角度和距离表示</p><p><img src="/images/OpenCV/Hough-Line.png" alt=""></p><p>其中 $\rho = x cos\theta + y sin\theta$ 的 θ 为垂线到横轴的逆时针角度</p><p>霍夫曼变换即是以 ρ 和 θ 两个参数来检索图像中的线条的算法，其接收的图像应当是二进制的，因此先使用阈值变换或 Canny 边缘检测</p><ul><li>HoughLines(image, rho, theta, threshold）输出 (ρ, θ) 值对的数组<ul><li>rho 和 theta 分别表示参数精度，即单位值大小</li><li>threshold 表示接受构成一条线的票数，票数由线上的点个数确定<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">img = cv.imread(cv.samples.findFile(<span class="string">&#x27;sudoku.png&#x27;</span>))</span><br><span class="line">gray = cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line">edges = cv.Canny(gray,<span class="number">50</span>,<span class="number">150</span>,apertureSize = <span class="number">3</span>)</span><br><span class="line">lines = cv.HoughLines(edges,<span class="number">1</span>,np.pi/<span class="number">180</span>,<span class="number">200</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    rho,theta = line[<span class="number">0</span>]</span><br><span class="line">    a = np.cos(theta)</span><br><span class="line">    b = np.sin(theta)</span><br><span class="line">    x0 = a*rho</span><br><span class="line">    y0 = b*rho</span><br><span class="line">    x1 = <span class="built_in">int</span>(x0 + <span class="number">1000</span>*(-b))</span><br><span class="line">    y1 = <span class="built_in">int</span>(y0 + <span class="number">1000</span>*(a))</span><br><span class="line">    x2 = <span class="built_in">int</span>(x0 - <span class="number">1000</span>*(-b))</span><br><span class="line">    y2 = <span class="built_in">int</span>(y0 - <span class="number">1000</span>*(a))</span><br><span class="line">    cv.line(img,(x1,y1),(x2,y2),(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">2</span>)</span><br><span class="line">cv.imwrite(<span class="string">&#x27;houghlines3.jpg&#x27;</span>,img)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="概率霍夫曼变换"><a href="#概率霍夫曼变换" class="headerlink" title="概率霍夫曼变换"></a>概率霍夫曼变换</h4><p>基于前者的优化，采用随机的点子集来减轻计算，相应的需要放宽阈值</p><ul><li>HoughLinesP(image, rho, theta, threshold[, lines, minLineLength, maxLineGap])<ul><li>minLineLength 表示最小线长度</li><li>maxLineGap 表示线段之间允许将他们视为一条线的最大间隙<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">img = cv.imread(cv.samples.findFile(<span class="string">&#x27;sudoku.png&#x27;</span>))</span><br><span class="line">gray = cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line">edges = cv.Canny(gray,<span class="number">50</span>,<span class="number">150</span>,apertureSize = <span class="number">3</span>)</span><br><span class="line">lines = cv.HoughLinesP(edges,<span class="number">1</span>,np.pi/<span class="number">180</span>,<span class="number">100</span>,minLineLength=<span class="number">100</span>,maxLineGap=<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    x1,y1,x2,y2 = line[<span class="number">0</span>]</span><br><span class="line">    cv.line(img,(x1,y1),(x2,y2),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br><span class="line">cv.imwrite(<span class="string">&#x27;houghlines5.jpg&#x27;</span>,img)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="霍夫圈变换"><a href="#霍夫圈变换" class="headerlink" title="霍夫圈变换"></a>霍夫圈变换</h3><ul><li>HoughCircles(image, method, dp, minDist[, circles, param1, param2, minRadius, maxRadius]) 查找图像中的圈<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">img = cv.imread(<span class="string">&#x27;opencv-logo-white.png&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">img = cv.medianBlur(img,<span class="number">5</span>)</span><br><span class="line">cimg = cv.cvtColor(img,cv.COLOR_GRAY2BGR)</span><br><span class="line">circles = cv.HoughCircles(img,cv.HOUGH_GRADIENT,<span class="number">1</span>,<span class="number">20</span>,</span><br><span class="line">                            param1=<span class="number">50</span>,param2=<span class="number">30</span>,minRadius=<span class="number">0</span>,maxRadius=<span class="number">0</span>)</span><br><span class="line">circles = np.uint16(np.around(circles))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> circles[<span class="number">0</span>,:]:</span><br><span class="line">    <span class="comment"># 绘制外圆</span></span><br><span class="line">    cv.circle(cimg,(i[<span class="number">0</span>],i[<span class="number">1</span>]),i[<span class="number">2</span>],(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 绘制圆心</span></span><br><span class="line">    cv.circle(cimg,(i[<span class="number">0</span>],i[<span class="number">1</span>]),<span class="number">2</span>,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">3</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;detected circles&#x27;</span>,cimg)</span><br></pre></td></tr></table></figure></li></ul><h3 id="图像分割与-Watershed-算法"><a href="#图像分割与-Watershed-算法" class="headerlink" title="图像分割与 Watershed 算法"></a>图像分割与 Watershed 算法</h3><p>分水岭算法，类似于等高线找轮廓；对图像中的噪声或其他不规则性可能产生过度分割，因此具体实现时增加了标记方法</p><ul><li>watershed(image, markers) （TODO：看上去蛮复杂，用到的时候看文档，用过再补充）</li></ul><h3 id="交互式前景提取-GrabCut-算法"><a href="#交互式前景提取-GrabCut-算法" class="headerlink" title="交互式前景提取 GrabCut 算法"></a>交互式前景提取 GrabCut 算法</h3><p>一种抠图算法，可以在过程中补充操作来保留或剔除部分内容</p><ul><li>grabCut(img, mask, rect, bgdModel, fgdModel, iterCount[, mode])</li></ul><h2 id="理解特征"><a href="#理解特征" class="headerlink" title="理解特征"></a>理解特征</h2><p>类似于一些图像中物体的边角或中心平坦区域的特征，重点在于为计算机提供一个区分的途径</p><h3 id="哈里斯角检测"><a href="#哈里斯角检测" class="headerlink" title="哈里斯角检测"></a>哈里斯角检测</h3><p>Harris Corner Detection</p><ul><li>cornerHarris(src, blockSize, ksize, k、, dst, borderType])</li><li>cornerSubPix(image, corners, winSize, zeroZone, criteria)</li></ul><h3 id="Shi-tomas-拐角检测器和易于跟踪的特征"><a href="#Shi-tomas-拐角检测器和易于跟踪的特征" class="headerlink" title="Shi-tomas 拐角检测器和易于跟踪的特征"></a>Shi-tomas 拐角检测器和易于跟踪的特征</h3><ul><li>goodFeaturesToTrack(image, maxCorners, qualityLevel, minDistance[, corners, mask, blockSize, useHarrisDetector, k])</li></ul><h3 id="SIFT-尺度不变特征变换"><a href="#SIFT-尺度不变特征变换" class="headerlink" title="SIFT 尺度不变特征变换"></a>SIFT 尺度不变特征变换</h3><p>例如拐角特征是旋转不变的，但对于平滑弧线形式的拐角，尺度放大之后接近一般曲线，失去拐角特征；</p><p>此算法即针对尺度变换下仍保持不变的图像特征</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;直方图&quot;&gt;&lt;a href=&quot;#直方图&quot; class=&quot;headerlink&quot; title=&quot;直方图&quot;&gt;&lt;/a&gt;直方图&lt;/h2&gt;&lt;h3 id=&quot;灰度直方图&quot;&gt;&lt;a href=&quot;#灰度直方图&quot; class=&quot;headerlink&quot; title=&quot;灰度直方图&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="OpenCV" scheme="http://remedios14.github.io/categories/OpenCV/"/>
    
    
    <category term="python" scheme="http://remedios14.github.io/tags/python/"/>
    
    <category term="opencv" scheme="http://remedios14.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV简述及接口（三）</title>
    <link href="http://remedios14.github.io/2022/04/12/OpenCV/OpenCV%E7%AE%80%E8%BF%B0%E5%8F%8A%E6%8E%A5%E5%8F%A3%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://remedios14.github.io/2022/04/12/OpenCV/OpenCV%E7%AE%80%E8%BF%B0%E5%8F%8A%E6%8E%A5%E5%8F%A3%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2022-04-12T04:11:58.000Z</published>
    <updated>2022-07-07T14:29:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要摘录 OpenCV 中对 mat 的数学变换</p><h2 id="OpenCV-数学操作"><a href="#OpenCV-数学操作" class="headerlink" title="OpenCV 数学操作"></a>OpenCV 数学操作</h2><h3 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h3><p>仿射变换主要描述的是旋转、缩放、平移的总称，具体的做法是通过一个矩阵和原图片坐标进行计算，得到新的坐标</p><h4 id="图像平移"><a href="#图像平移" class="headerlink" title="图像平移"></a>图像平移</h4><ul><li>warpAffine(src, M, dsize[, flags, borderMode, borderValue]) 执行仿射变换，若希望将原来点 (x, y) 处的像素点移动至 (x + t_x, y + t_y)，实际上可以看作进行以此矩阵乘法<ul><li>M ：变换矩阵，精度至少是 float32，二维 2 × 3</li><li>dsize ：输出图片的大小（注意横纵）</li><li>flag ：与 resize 中的插值算法一致，INTER_…</li><li>mode ：边界外推法标志</li><li>value ：填充边界值<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dog = cv2.imread(<span class="string">&#x27;./resource/dog.webp&#x27;</span>)</span><br><span class="line">h, w, ch = dog.shape</span><br><span class="line">M = np.float32([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">30</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>]])</span><br><span class="line">new_dog = cv2.warpAffine(dog, M, dsize=(w,h))</span><br><span class="line">cv2.imshow(<span class="string">&#x27;dogs&#x27;</span>, np.hstack((dog, new_dog)))</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="图像旋转"><a href="#图像旋转" class="headerlink" title="图像旋转"></a>图像旋转</h4><p>不同与之前的旋转（90°水平不影响像素点分布），其他角度的旋转需要旋转坐标轴，其难点在于计算变换矩阵；OpenCV 提供了计算的 API ：</p><ul><li><p>getRotationMatrix2D(center, angle, scale) 计算以指定中心旋转指定角度的变换矩阵</p><ul><li>center 中心点坐标，以哪个点作为旋转时的中心点</li><li>angle 旋转的角度，按照逆时针进行旋转</li><li>scale 缩放比例，取正常数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h, w, ch = dog.shape</span><br><span class="line">M = cv2.getRotationMatrix2D((w // <span class="number">2</span>, h // <span class="number">2</span>), <span class="number">75</span>, <span class="number">1</span>)</span><br><span class="line">new_dog = cv2.warpAffine(dog, M, (w, h))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>getAffineTransform(src[], dst[]) 通过三点可以确定变换后的位置，解方程求出偏移的参数和旋转的角度；返回变换矩阵（使用上不方便直观）</p><ul><li>src 原目标的三个点 3 × 2，要取至少 float32</li><li>dst 变换后的三个点<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">src = np.float32([[<span class="number">123</span>,<span class="number">123</span>], [<span class="number">324</span>, <span class="number">324</span>], [<span class="number">121</span>, <span class="number">121</span>]])</span><br><span class="line">dst = np.foat32([[<span class="number">513</span>, <span class="number">513</span>], [<span class="number">126</span>, <span class="number">126</span>], [<span class="number">621</span>, <span class="number">621</span>]])</span><br><span class="line">M = cv2.getAffineTransform(src, dst)</span><br><span class="line">new_dog = cv2.warpAffine(dog, M, (w, h))</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="透视变换"><a href="#透视变换" class="headerlink" title="透视变换"></a>透视变换</h4><p>可以理解为在一个视线内截取不同的平面投影（若取平行的平面则仅发生缩放）</p><ul><li>warpPerspective(img, M, dsize[…]) ：参数同上，执行变换的函数<ul><li>对透视变换来说， M 是一个 3 × 3 的矩阵</li></ul></li><li>getPerspectiveTransform(src[], dst[]) ：获取透视变换的变换矩阵，需要 4 个点，即图片的四个角（可以先展示然后配合鼠标动作来获取）<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">src = np.float32([[<span class="number">100</span>, <span class="number">1100</span>], [<span class="number">2100</span>, <span class="number">1100</span>], [<span class="number">0</span>, <span class="number">4000</span>], [<span class="number">2500</span>, <span class="number">3900</span>]])</span><br><span class="line">dst = np.float32([[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">2300</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">3000</span>], [<span class="number">2300</span>, <span class="number">3000</span>]])</span><br><span class="line">M = cv2.getPerspectiveTransform(src, dst)</span><br><span class="line">new_img = cv2.warpPerspective(img, M, (<span class="number">2300</span>, <span class="number">3000</span>))</span><br></pre></td></tr></table></figure></li></ul><h3 id="滤波器"><a href="#滤波器" class="headerlink" title="滤波器"></a>滤波器</h3><h4 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h4><p>图片卷积就是使用一个卷积核在图片上按照指定步长移动并进行逐元的线性运算，每一步得到一个卷积特征</p><ul><li>步长：即每次卷积核平移的像素个数，通常用 1 来充分扫描图片，当最后不足时就到下一行去</li><li><p>padding：有时为了保持卷积特征的大小和原图一致，可以在原图外围填充一层 0 ；该值即为填充的层数</p></li><li><p>输入体积大小 H1 * W1 * D1</p></li><li>四个超参数：<ul><li>Filter （卷积核）数量 K</li><li>卷积核大小 F （一定是方阵）</li><li>步长 S</li><li>填充层 P</li></ul></li><li>输出体积大小 H2 * W2 * D2<ul><li><code>H2 = (H1 - F + 2P)/S + 1</code></li><li><code>W2 = (W1 - F + 2P)/S + 1</code></li><li><code>D2 = K</code></li></ul></li><li><p>在步长为 1 时，要令 <code>(N + 2P - F + 1) = N</code> 可得到 <code>P = (F-1)/2</code></p></li><li><p>卷积核大小：通常取奇数，方便计算得到整数 padding 来保持大小；同时奇数能取到卷积核中心</p></li></ul><h5 id="接口案例"><a href="#接口案例" class="headerlink" title="接口案例"></a>接口案例</h5><ul><li>filter2D(src, ddepth, kernel[, dst, anchor, delta, borderType]) 返回卷积特征矩阵<ul><li>ddepth 是卷积之后图片的位深，即卷积之后图片的数据类型，一般设为 -1 来和原图保持一致</li><li>kernel 卷积核，用元组或 ndarray，必须是 float 类型</li><li>anchor 锚点，即卷积核的中心点，默认 (-1,1)</li><li>delta 运算时可选地增加一个常数项偏差，默认 0</li><li>borderType 边界类型，一般不设<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kernel = np.ones((5, 5), np.float32) / 25</span></span><br><span class="line">kernel = np.array([[-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>], [-<span class="number">1</span>,<span class="number">8</span>,-<span class="number">1</span>], [-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>]])</span><br><span class="line">dst = cv2.filter2D(img, -<span class="number">1</span>, kernel)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;cmp&#x27;</span>, np.hstack((img, dst)))</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="方盒滤波"><a href="#方盒滤波" class="headerlink" title="方盒滤波"></a>方盒滤波</h4><ul><li>boxFilter(src, ddepth, ksize[, dst, anchor, normalize, borderType]) 方盒滤波，相当于取单位阵乘上一个常数 a 作为卷积核<ul><li>normalize = True 时 <code>a = 1 / (Kw * Kh)</code>，此时等价于均值滤波；否则用 Kw × Kh 大小的全一阵（别用 False）</li></ul></li><li>blur(src, ksize[, dst, anchor, borderType]) 均值滤波，没有位深参数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new_img = cv2.boxFilter(img, -<span class="number">1</span>, (<span class="number">5</span>, <span class="number">5</span>), normalize=<span class="literal">True</span>)</span><br><span class="line">mean_img = cv2.blur(img, (<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">cv2.imshow(<span class="string">&#x27;cmp&#x27;</span>, np.hstack((img, new_img, mean_img)))</span><br></pre></td></tr></table></figure></li></ul><h4 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h4><p>使用符合<strong>二维高斯分布</strong>的矩阵滤波器来进行滤波操作(通常取相同的方差且不相关情形)</p><p>要使用高斯滤波的重点在于计算符合高斯分布的卷积核（高斯模板）</p><p>通常假定中心点坐标为 (0,0) 并自行选取一个 $\sigma$</p><p>例如对 3 × 3 卷积核取 1.5 做标准差，代入计算得到</p><p><img src="/images/OpenCV/Gauss-Model-Filter.png" alt=""></p><p>为了符合卷积核的概率形式需要对计算出的高斯模板<strong>归一化</strong></p><h5 id="接口示例"><a href="#接口示例" class="headerlink" title="接口示例"></a>接口示例</h5><ul><li>GaussianBlur(src, ksize, sigmaX[, dst, sigmaY, borderType])<ul><li>ksize 高斯核的大小</li><li>sigmaX ，X 轴的标准差</li><li>sigmaY ，默认为 0，此时 sigmaY = sigmaX</li><li>当指定 sigmaX = 0 时会使用 ksize 来计算<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dst = cv2.GaussianBlur(img, (<span class="number">5</span>,<span class="number">5</span>), sigmaX=<span class="number">100</span>)</span><br><span class="line">dst_0 = cv2.GaussianBlur(img, (<span class="number">5</span>,<span class="number">5</span>), sigmaX=<span class="number">0</span>)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;cmp&#x27;</span>, np.hstack((img, dst, dst_0)))</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h4><p>取卷积感受野内的中值作为卷积特征的滤波操作；对于椒盐噪音（即零散的噪声像素点，像撒盐一样）效果明显</p><ul><li>medianBlur(src, ksize[, dst]) 中值滤波，注意此处的 ksize 用单整数</li></ul><h4 id="双边滤波"><a href="#双边滤波" class="headerlink" title="双边滤波"></a>双边滤波</h4><p>对于图像边缘信息能够更好的保存；其原理为使用一个与空间距离相关的高斯函数，以及一个与灰度距离相关的高斯函数相乘</p><ul><li><strong>空间距离</strong>：当前点与中心点的欧氏距离代入空间域高斯函数，其中 sigma 为空间域标准差<br><img src="/images/OpenCV/Space-Gauss-Func.png" alt=""></li><li><strong>灰度距离</strong>：当前点灰度与中心点灰度的差的绝对值代入，sigma 为值域标准差<br><img src="/images/OpenCV/Gray-Gauss-Func.png" alt=""></li></ul><p>大致效果即 —— 当感受野内有显著灰度差异时，仅对灰度较大区域进行高斯模糊</p><ul><li>bilateralFilter(src, d, sigmaColor, sigmaSpace[, dst, borderType]) 双边滤波<ul><li>d 是一维的卷积核尺寸</li><li>sigmaColor 是计算像素信息使用的 sigma</li><li>sigmaSpace 是计算空间信息使用的 sigma</li></ul></li></ul><h3 id="算子"><a href="#算子" class="headerlink" title="算子"></a>算子</h3><p>主要用于识别图像边缘，边缘是像素值发生跃迁的位置，是图像的显著特征之一；在图像特征提取，对象检测，模式识别等方面都有重要的作用</p><h4 id="Sobel-算子"><a href="#Sobel-算子" class="headerlink" title="Sobel 算子"></a>Sobel 算子</h4><p>对图像求一阶导数：因为图像的灰度值都是离散的数字，sobel 算子采用离散差分算子计算图像像素点亮度值的近似梯度</p><p>为了近似地求出一个像素点处的梯度，使用横纵向两个卷积核扫描得到两个方向上的亮度变化情况，然后综合得到梯度</p><p><img src="/images/OpenCV/Sobel-Grad-Kernel.png" alt=""></p><p>分别卷积扫描（padding=1）后得到两个同大小的新矩阵；对两个分量进行均方求和或者绝对值求和来近似梯度</p><ul><li>Sobel(src, ddepth, dx, dy[, dst, ksize, scale, delta, borderType])<ul><li>ksize 设置为 -1 就得到 Scharr 算子<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dx = cv2.Sobel(img, -<span class="number">1</span>, dx=<span class="number">1</span>, dy=<span class="number">0</span>, ksize=<span class="number">3</span>)</span><br><span class="line">dy = cv2.Sobel(img, -<span class="number">1</span>, dx=<span class="number">0</span>, dy=<span class="number">1</span>, ksize=<span class="number">3</span>)</span><br><span class="line">sm_grad = cv2.addWeighted(dx, <span class="number">0.5</span>, dy, <span class="number">0.5</span>, gamma=<span class="number">0</span>)</span><br><span class="line">sq_grad = (dx ** <span class="number">2</span> + dy ** <span class="number">2</span>) ** <span class="number">0.5</span> <span class="comment"># 貌似这个运算改变了数据类型</span></span><br><span class="line">cv2.imshow(<span class="string">&#x27;cmp&#x27;</span>, np.hstack((img, dx, dy)))</span><br><span class="line">cv2.imshow(<span class="string">&#x27;grad&#x27;</span>, np.hstack((sm_grad, sq_grad)))</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="Scharr-算子"><a href="#Scharr-算子" class="headerlink" title="Scharr 算子"></a>Scharr 算子</h4><p>当内核大小为 3 时，Sobel 算子误差较大；Scharr 算子针对 3 大小做了优化，使用了不同的 kernel（水平如下，纵向类似）</p><p>[[-3, 0, +3],<br>[-10, 0, +10],<br>[-3, 0, +3]]</p><ul><li>Scharr(src, ddepth, dx, dy[, dst, scale, delta, borderType]) 不允许修改卷积核大小，仅允许 3 × 3</li></ul><h4 id="拉普拉斯算子"><a href="#拉普拉斯算子" class="headerlink" title="拉普拉斯算子"></a>拉普拉斯算子</h4><p>寻找二阶导数为 0 的位置判断为边缘（但二阶导为 0 也可能是噪声点，可以之后结合高斯滤波处理）</p><ul><li><p>拉普拉斯算子求导（卷积核为左阵，用它去点乘感受野）<br><img src="/images/OpenCV/Laplace-Twice-grad.png" alt=""></p></li><li><p>Laplacian(src, ddepth[, dst, ksize, scale, delta, borderType]) 同时求两个方向的边缘</p><ul><li>对噪声敏感，一般需要结合去噪的滤波算法</li></ul></li></ul><h3 id="边缘检测-Canny"><a href="#边缘检测-Canny" class="headerlink" title="边缘检测 Canny"></a>边缘检测 Canny</h3><ul><li>由 John F. Canny 于 1986 年开发的多级边缘检测算法，被认为是最优的；边缘检测的三个主要评价标准：<ul><li>低错误率：标识出尽可能多的实际边缘，同时尽可能的减少噪声产生</li><li>高定位性：标识出的边缘要与图像中的实际边缘尽可能接近</li><li>最小响应：图像中的边缘只能标识一次</li></ul></li><li><p>执行算法的一般步骤</p><ol><li>使用高斯滤波器，以平滑图像，滤除噪声</li><li>计算图像中每个像素点的梯度强度和方向：对平滑后的图像采用 sobel 算子计算梯度和方向<ul><li>$G = \sqrt {G^2_x+G^2_y}$ 为了方便一般可用绝对值</li><li>$\theta = arctan(\frac{G_y}{G_x})$</li><li>梯度方向被归为四类：竖直，水平，和两个对角线方向</li></ul></li><li>应用非极大值（Non-Maximum Suppression）抑制，以消除边缘检测带来的杂散响应：扫描所有计算后的像素点，检查该点是否是其梯度方向（分解成四种）上的极大值，若是则保留到下一阶段，若不是则抑制（置为0）</li><li>应用双阈值（Double-Threshold）检测来确定真实的和潜在的边缘：设置上下阈值 maxVal 和 minVal，大于上阈值必定为边缘点，小于下阈值必定非边缘，范围内的点根据连通性归类（是否与边缘点相连通）</li><li>通过抑制孤立的弱边缘最终完成边缘检测</li></ol></li><li><p>Canny(image, threshold1, threshold2[, edges, apertureSize, L2gradient]) 调用 Canny 算法进行边缘检测</p><ul><li>两个阈值依次为 minVal 和 maxVal</li><li>apertureSize 标识过程中 Sobel 算子的核大小</li><li>L2gradient 表示计算梯度方法，默认 False 使用绝对值和<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cny_img = cv2.Canny(img, <span class="number">100</span>, <span class="number">200</span>) <span class="comment"># 会得到仅二维的结果</span></span><br><span class="line">cv2.imshow(<span class="string">&#x27;org&#x27;</span>, img)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;grad&#x27;</span>, cny_img)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="形态学转换"><a href="#形态学转换" class="headerlink" title="形态学转换"></a>形态学转换</h3><p>将原始图像上区分度较高的形状执行一定变换的操作，通常在二进制图像上执行</p><h4 id="侵蚀"><a href="#侵蚀" class="headerlink" title="侵蚀"></a>侵蚀</h4><p>大致是侵蚀前景物体的边界（尽量使前景保持白色），去除图像中的一部分；大致实现是使用一个卷积核滑动，在感受野中所有实际像素为 1 的当前像素被认为是 1，否则被侵蚀为 0 —— 舍弃边缘</p><ul><li>erode(src, kernel)</li></ul><h4 id="扩张"><a href="#扩张" class="headerlink" title="扩张"></a>扩张</h4><p>与侵蚀相反，大致当感受野内存在 1 时就被认为是 1</p><ul><li>dilate(src, kernel)</li></ul><h4 id="形态学-Ex-操作"><a href="#形态学-Ex-操作" class="headerlink" title="形态学 Ex 操作"></a>形态学 Ex 操作</h4><ul><li>morphologyEx(src, op, kernel) 其中的 op 是以 MORPH 开头的一类操作，一下取值分别有几种效果<ul><li>MORPH_OPEN 开运算，相当于先侵蚀在扩张来还原；对消除噪音有帮助（对比高斯模糊）</li><li>MORPH_CLOSE 闭运算，先扩张后侵蚀</li><li>MORPH_GRADIENT 形态学梯度，对比扩张和侵蚀得到的结果，看上去像求轮廓</li><li>MORPH_TOPHAT 顶帽，是原图像和开运算图像之差</li><li>MORPH_BLACKHAT 黑帽，是闭运算和原图像之差</li></ul></li></ul><h4 id="快捷-kernel"><a href="#快捷-kernel" class="headerlink" title="快捷 kernel"></a>快捷 kernel</h4><p>一般使用 kernel 可以自己创建 ndarray 对象，OpenCV 也提供了几个快捷的形状</p><ul><li>getStructuringElement(shape, ksize) 返回指定形状的 ndarray<ul><li>ksize 为二元组</li><li>shape 可选<ul><li>MORPH_RECT 全 1 填充矩形</li><li>MORPH_ELLIPSE 椭圆形填充 1</li><li>MORPH_CROSS 十字形填充 1</li></ul></li></ul></li></ul><h2 id="性能衡量和提升"><a href="#性能衡量和提升" class="headerlink" title="性能衡量和提升"></a>性能衡量和提升</h2><h3 id="计时"><a href="#计时" class="headerlink" title="计时"></a>计时</h3><p>当然用 python 自带的 time 模块可以实现计时，用 OpenCV 也可以</p><ul><li>getTickCount() 返回从参考时间（如启动计算器）到调用此函数时刻的时钟周期数</li><li>getTickFrequency() 返回时钟周期的频率或每秒的时钟周期数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">e1 = cv2.getTickCount()</span><br><span class="line"><span class="comment"># 执行过程代码</span></span><br><span class="line">e2 = cv2.getTickCount()</span><br><span class="line">time - (e2 - e1) / cv2.getTickFrequency()</span><br></pre></td></tr></table></figure></li></ul><p>使用魔术方法 <code>%timeit &#123;code&#125;</code> 会多次执行代码段计平均耗时</p><h3 id="OpenCV-默认优化"><a href="#OpenCV-默认优化" class="headerlink" title="OpenCV 默认优化"></a>OpenCV 默认优化</h3><p>许多 OpenCV 函数都是使用 SSE2、AVX 等进行优化的，默认都会启用</p><ul><li>useOptimized() 检查是否启用</li><li>setOptimized() 设置启用</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇主要摘录 OpenCV 中对 mat 的数学变换&lt;/p&gt;
&lt;h2 id=&quot;OpenCV-数学操作&quot;&gt;&lt;a href=&quot;#OpenCV-数学操作&quot; class=&quot;headerlink&quot; title=&quot;OpenCV 数学操作&quot;&gt;&lt;/a&gt;OpenCV 数学操作&lt;/h2&gt;&lt;h3</summary>
      
    
    
    
    <category term="OpenCV" scheme="http://remedios14.github.io/categories/OpenCV/"/>
    
    
    <category term="python" scheme="http://remedios14.github.io/tags/python/"/>
    
    <category term="opencv" scheme="http://remedios14.github.io/tags/opencv/"/>
    
  </entry>
  
</feed>
