[{"title":"ありがとう","date":"2025-11-07T13:26:48.000Z","url":"/2025/11/07/music-life/harmonica/%E3%81%82%E3%82%8A%E3%81%8C%E3%81%A8%E3%81%86/","tags":[["音乐","/tags/%E9%9F%B3%E4%B9%90/"]],"categories":[["口琴","/categories/%E5%8F%A3%E7%90%B4/"]],"content":"原链接"},{"title":"星之所在","date":"2025-11-02T16:33:54.000Z","url":"/2025/11/03/music-life/harmonica/%E6%98%9F%E4%B9%8B%E6%89%80%E5%9C%A8/","tags":[["音乐","/tags/%E9%9F%B3%E4%B9%90/"]],"categories":[["口琴","/categories/%E5%8F%A3%E7%90%B4/"]],"content":"原链接"},{"title":"one last kiss","date":"2025-11-02T06:56:53.000Z","url":"/2025/11/02/music-life/harmonica/one-last-kiss/","tags":[["音乐","/tags/%E9%9F%B3%E4%B9%90/"]],"categories":[["口琴","/categories/%E5%8F%A3%E7%90%B4/"]],"content":"原链接"},{"title":"一番的宝物","date":"2025-10-26T13:38:02.000Z","url":"/2025/10/26/music-life/harmonica/%E4%B8%80%E7%95%AA%E7%9A%84%E5%AE%9D%E7%89%A9/","tags":[["音乐","/tags/%E9%9F%B3%E4%B9%90/"]],"categories":[["口琴","/categories/%E5%8F%A3%E7%90%B4/"]],"content":"原链接"},{"title":"深海少女","date":"2025-10-26T13:36:05.000Z","url":"/2025/10/26/music-life/harmonica/%E6%B7%B1%E6%B5%B7%E5%B0%91%E5%A5%B3/","tags":[["音乐","/tags/%E9%9F%B3%E4%B9%90/"]],"categories":[["口琴","/categories/%E5%8F%A3%E7%90%B4/"]],"content":"原链接"},{"title":"秋姐妹鸣泣之时","date":"2025-10-07T15:53:31.000Z","url":"/2025/10/07/music-life/harmonica/%E7%A7%8B%E5%A7%90%E5%A6%B9%E9%B8%A3%E6%B3%A3%E4%B9%8B%E6%97%B6/","tags":[["音乐","/tags/%E9%9F%B3%E4%B9%90/"]],"categories":[["口琴","/categories/%E5%8F%A3%E7%90%B4/"]],"content":"原链接"},{"title":"妄想感伤代偿联盟","date":"2025-10-07T15:43:17.000Z","url":"/2025/10/07/music-life/harmonica/%E5%A6%84%E6%83%B3%E6%84%9F%E4%BC%A4%E4%BB%A3%E5%81%BF%E8%81%94%E7%9B%9F/","tags":[["音乐","/tags/%E9%9F%B3%E4%B9%90/"]],"categories":[["口琴","/categories/%E5%8F%A3%E7%90%B4/"]],"content":"原链接"},{"title":"勾指起誓","date":"2025-10-06T13:21:51.000Z","url":"/2025/10/06/music-life/harmonica/%E5%8B%BE%E6%8C%87%E8%B5%B7%E8%AA%93/","tags":[["音乐","/tags/%E9%9F%B3%E4%B9%90/"]],"categories":[["口琴","/categories/%E5%8F%A3%E7%90%B4/"]],"content":"原链接"},{"title":"众神眷恋的幻想乡","date":"2025-10-05T15:13:13.000Z","url":"/2025/10/05/music-life/harmonica/%E4%BC%97%E7%A5%9E%E7%9C%B7%E6%81%8B%E7%9A%84%E5%B9%BB%E6%83%B3%E4%B9%A1/","tags":[["音乐","/tags/%E9%9F%B3%E4%B9%90/"]],"categories":[["口琴","/categories/%E5%8F%A3%E7%90%B4/"]],"content":"原链接"},{"title":"雪之华","date":"2025-10-05T14:53:54.000Z","url":"/2025/10/05/music-life/harmonica/%E9%9B%AA%E4%B9%8B%E5%8D%8E/","tags":[["音乐","/tags/%E9%9F%B3%E4%B9%90/"]],"categories":[["口琴","/categories/%E5%8F%A3%E7%90%B4/"]],"content":"原链接"},{"title":"虽然歌声无形","date":"2025-10-05T14:33:03.000Z","url":"/2025/10/05/music-life/harmonica/%E8%99%BD%E7%84%B6%E6%AD%8C%E5%A3%B0%E6%97%A0%E5%BD%A2/","tags":[["音乐","/tags/%E9%9F%B3%E4%B9%90/"]],"categories":[["口琴","/categories/%E5%8F%A3%E7%90%B4/"]],"content":"原链接"},{"title":"cry for me-口琴谱","date":"2025-08-27T15:53:56.000Z","url":"/2025/08/27/music-life/harmonica/cry%20for%20me-%E5%8F%A3%E7%90%B4%E8%B0%B1/","tags":[["音乐","/tags/%E9%9F%B3%E4%B9%90/"]],"categories":[["口琴","/categories/%E5%8F%A3%E7%90%B4/"]],"content":"原链接"},{"title":"鸟之诗-口琴谱","date":"2025-08-27T15:53:07.000Z","url":"/2025/08/27/music-life/harmonica/%E9%B8%9F%E4%B9%8B%E8%AF%97-%E5%8F%A3%E7%90%B4%E8%B0%B1/","tags":[["音乐","/tags/%E9%9F%B3%E4%B9%90/"]],"categories":[["口琴","/categories/%E5%8F%A3%E7%90%B4/"]],"content":"原链接"},{"title":"卡农-口琴谱","date":"2025-08-27T15:43:17.000Z","url":"/2025/08/27/music-life/harmonica/%E5%8D%A1%E5%86%9C-%E5%8F%A3%E7%90%B4%E8%B0%B1/","tags":[["音乐","/tags/%E9%9F%B3%E4%B9%90/"]],"categories":[["口琴","/categories/%E5%8F%A3%E7%90%B4/"]],"content":"原链接"},{"title":"secret-base-口琴谱","date":"2025-08-13T16:48:19.000Z","url":"/2025/08/14/music-life/harmonica/secret-base-%E5%8F%A3%E7%90%B4%E8%B0%B1/","tags":[["音乐","/tags/%E9%9F%B3%E4%B9%90/"]],"categories":[["口琴","/categories/%E5%8F%A3%E7%90%B4/"]],"content":"原链接全程升半音 "},{"title":"樱花樱花想见你-口琴谱","date":"2025-08-13T16:46:27.000Z","url":"/2025/08/14/music-life/harmonica/%E6%A8%B1%E8%8A%B1%E6%A8%B1%E8%8A%B1%E6%83%B3%E8%A7%81%E4%BD%A0-%E5%8F%A3%E7%90%B4%E8%B0%B1/","tags":[["音乐","/tags/%E9%9F%B3%E4%B9%90/"]],"categories":[["口琴","/categories/%E5%8F%A3%E7%90%B4/"]],"content":"原链接"},{"title":"美丽之物-口琴谱","date":"2025-08-13T16:41:34.000Z","url":"/2025/08/14/music-life/harmonica/%E7%BE%8E%E4%B8%BD%E4%B9%8B%E7%89%A9-%E5%8F%A3%E7%90%B4%E8%B0%B1/","tags":[["音乐","/tags/%E9%9F%B3%E4%B9%90/"]],"categories":[["口琴","/categories/%E5%8F%A3%E7%90%B4/"]],"content":"原链接"},{"title":"Npm 概述","date":"2023-12-24T14:16:29.000Z","url":"/2023/12/24/FrontEnd/Npm-%E6%A6%82%E8%BF%B0/","tags":[["前端","/tags/%E5%89%8D%E7%AB%AF/"]],"categories":[["通用工具","/categories/%E9%80%9A%E7%94%A8%E5%B7%A5%E5%85%B7/"]],"content":"yosoro~"},{"title":"React-QuickIntro","date":"2023-12-24T11:34:57.000Z","url":"/2023/12/24/FrontEnd/React/React-QuickIntro/","tags":[["前端","/tags/%E5%89%8D%E7%AB%AF/"],["QuickStart","/tags/QuickStart/"],["React","/tags/React/"]],"categories":[["React","/categories/React/"]],"content":"yosoro~比较适合喜欢 ‘手动搓轮子’ 的选手，如果对前端没有很多经验，不如学 Vue 更直接有效。 基础介绍安装与启动 先获取 npm 以及配置镜像仓库，正式创建项目需要 create-react-app 脚手架，但运行项目并不必要 npx create-react-app &lt;project-name&gt; 使用 npx 可以临时安装并且在初始化后自动删除 npm start 来启动项目 基本项目结构 index.js 为项目总入口，启动时默认在该页面 App.js 为基础组建，读入数据并模块化显示，需要将组件内的函数 export 才能供外部使用 "},{"title":"WebGL-入门环境搭建","date":"2022-09-11T12:30:55.000Z","url":"/2022/09/11/Graphics/WebGL-%E5%85%A5%E9%97%A8%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","categories":[["WebGL","/categories/WebGL/"]]},{"title":"Golang-常规算法实现","date":"2022-09-10T15:20:41.000Z","url":"/2022/09/10/Golang/Golang-%E5%B8%B8%E8%A7%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/","tags":[["algorithm","/tags/algorithm/"],["datastruct","/tags/datastruct/"]],"categories":[["Golang","/categories/Golang/"]],"content":"暂时不更新虽然没有变成很厉害的程序员，但是已经开始工作了，非必要情况下反而没意愿去实现算法了，所以此篇章可能长期保持不更新状态"},{"title":"Golang-QuickIntro","date":"2022-09-02T16:26:02.000Z","url":"/2022/09/03/Golang/Golang-QuickIntro/","tags":[["QuickStart","/tags/QuickStart/"],["菜鸟教程","/tags/%E8%8F%9C%E9%B8%9F%E6%95%99%E7%A8%8B/"]],"categories":[["Golang","/categories/Golang/"]],"content":"yosoro~编写一个简单的 在当前目录下 go build 编译所有 .go 文件并生成同名的二进制文件(或者 go build &lt;name.go&gt; 编译指定文件)，在终端直接执行； 或者 go run &lt;name.go&gt; 直接运行指定代码文件 主要特性： 自动垃圾回收 GC 更丰富的内置类型 函数多返回值 错误处理 匿名函数和闭包 类型和接口 并发编程 反射 语言交互性 Go 语言结构基础组成包括如下： 包声明（必须在第一行声明所属）；package main 表示一个可独立执行的程序，每个 Go 应用程序都至少要有一个 引入包，格式 import &quot;pname&quot;，其中 fmt 包进行 IO，fmt.Println() 函数（main 函数是可执行程序必须的，但若有 init() 函数会先执行它） 变量 语句&amp;表达式 注释（同 Java） 标识符（包括常量、变量、类型、函数名、结构字段等）若以大写字母开头如 Group1 则可被外部的包使用（类似 public）；否则类似 protected，仅包内部可见 注意 &#123; 不能单独构成一行 Go 语言基础语法通常一行完成一条语句无需 ; 换行，但若多条写在同一行（虽然不推荐）则需要用 ; 分隔 字符串直接用 + 拼接 关键字 break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 以及预定义标识符 append bool byte cap close complex complex64 complex128 uint16 copy false float32 float64 imag int int8 int16 uint32 int32 int64 iota len make new nil panic uint64 print println real recover string true uint uint8 uintptr 杂项空格增加可读性 fmt.Sprintf 格式化输出字符串 Go 语言数据类型数据类型用于声明函数和变量，申请内存 序号 类型和描述 1 布尔型 布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。默认值 false 2 数字类型 整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。默认值（包括 complex64/128） 为 0 3 字符串类型: 字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。默认值为 “” （空字符串） 4 派生类型: 包括：(a) 指针类型（Pointer）(b) 数组类型(c) 结构化类型(struct)(d) Channel 类型(e) 函数类型(f) 切片类型(g) 接口类型（interface）(h) Map 类型 派生类型中， 1) 指针；2) 数组；3) Map；4) Chan；5) Func；6) error (接口) 类型的默认值为 nil 数字类型 序号 类型和描述 1 uint8 无符号 8 位整型 (0 到 255) 2 uint16 无符号 16 位整型 (0 到 65535) 3 uint32 无符号 32 位整型 (0 到 4294967295) 4 uint64 无符号 64 位整型 (0 到 18446744073709551615) 5 int8 有符号 8 位整型 (-128 到 127) 6 int16 有符号 16 位整型 (-32768 到 32767) 7 int32 有符号 32 位整型 (-2147483648 到 2147483647) 8 int64 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) 浮点型 序号 类型和描述 1 float32 IEEE-754 32位浮点型数 2 float64 IEEE-754 64位浮点型数 3 complex64 32 位实数和虚数 4 complex128 64 位实数和虚数 其他数字类型 序号 类型和描述 1 byte 类似 uint8 2 rune 类似 int32 3 uint 32 或 64 位 4 int 与 uint 一样大小 5 uintptr 无符号整型，用于存放一个指针 Go 语言变量 一般使用 var 关键字，可同时声明多个变量，在最后指定类型 三种声明方法 先初始化再赋值，需要指定类型 直接赋值，可以自动判断类型无需显式写 type := 完成声明和赋值，只能用于初次声明变量（也只能用在函数体中） 值类型和引用类型值类型所有像 int、float、bool 和 string 这些基本类型都属于值类型，其变量直接指向内存中的值，在 = 赋值时在内存中进行了拷贝 &amp;i 获取到变量 i 的内存地址，如 0xf840000040 （每次运行的地址都可能不一样）。值类型变量的值存储在栈中。 引用类型r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置。 这个内存地址称之为指针，这个指针实际上也被存在另外的某一个值中。 当使用 r2 = r1 时，只有引用（地址）被复制 注意点 在代码块中不使用一个声明的局部变量会编译错误，仅赋值也不行 全局变量允许声明不使用 交换变量值 a, b = b, a 在同类型变量间可用 空白标识符 _ 用于抛弃值，其是一个只写变量，不能获取值 Go 语言常量 const常量是一个简单值的标识符，在程序运行时不会被修改的量。 常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。定义格式如下 可以省略 [type] 交给编译器自行判断 常量不能用 := 语法声明 常量还可以用作枚举，也可以用内置函数计算表达式的值 iota特殊常量，可以认为是一个可以被编译器修改的常量 在 const 语句块中构成行索引，初始化 0，每行 +1 Go 语言运算符算数、关系、逻辑、位、赋值、其他 算术运算符+ - * / % ++ -- 完全一致，其中 / 对整数为整除 关系运算符== != &gt; &lt; &gt;= &lt;= 逻辑运算符&amp;&amp; || ! 位运算符&amp; 与 | 或 ^ 异或 &lt;&lt; 左移 &gt;&gt; 右移 赋值运算符略 其他运算符 运算符 描述 实例 &amp; 返回变量存储地址 &a; 将给出变量的实际地址。 * 指针变量。 *a; 是一个指针变量 运算符优先级 优先级 运算符 5 * / % &lt;&lt; &gt;&gt; &amp; &amp;^ 4 + - \\ ^ 3 == != &lt; &lt;= &gt; &gt;= 2 &amp;&amp; 1 \\ \\ Go 语言条件语句if ... else if ... else ... 类似 Python 无需括号，但 &#123;&#125; 必须 可以在条件语句中声明变量（仅在条件语句 if ... else ... 内部生效的局部变量） Switch 语句自上到下逐一测试直到匹配（默认在 case 最后自带 break ，若不希望终止可以使用 fallthrough ）支持多值 match 其中 var1 可以是任何类型，而 val1 和 val2 只需要是同类型值（或表达式）即可 Type Switchswitch 的用法之一，用于判断某个 interface 变量中实际存储的变量类型 fallthrough写在原来 break 的位置，当遇到时会无视下一条 case 的条件执行下一条 Select 语句类似于通信的 switch 语句，每个 case 必须是一个通信操作（发送或接收） select 随机执行一个可运行的 case ，如果没有 case 可运行，则会阻塞直到有。 一个默认的子句应该总是可运行的 select 语句的语法如下： 每个 case 都必须是一个通信 所有 channel 表达式都会被求值 所有被发送的表达式都会被求值 如果人以某个通信可以进行，它就执行，其他被忽略 如果有多个 case 都可以运行，Select 会随机公平地选出一个执行。其他不会执行。 否则： 如果有 default 子句，则执行该语句 如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值 Go 语言循环语句for 循环 for init; condition; post &#123;&#125; 可以省略其中的 init 和 post （但要有分号） for condition &#123;&#125; 类同 while 直接 for &#123;&#125; 类同 C 中的 for (;;) ，会直接无限循环 For-each range 循环可以对字符串、数组、切片等进行迭代输出元素 循环控制语句break 语句 用于循环语句中跳出循环，并开始执行循环之后的语句 在 switch 语句中执行一条 case 后跳出语句 在多重循环中用标号 label 标出想 break 的循环 continue 语句可以使用 label ，其他无变化 goto 语句不推荐使用 Go 语言函数最少有一个 main() 函数 函数声明告诉编译器 函数的名称，返回类型和参数 函数定义 函数定义解析： func ：函数由 func 开始声明 function_name ：函数名称，参数列表和返回值类型构成了函数签名 parameter list ：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的时参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数 return_types ：返回类型，函数返回一列值。return_types 时该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的 函数体：函数定义的代码集合 函数调用可以前缀关键词实现不同形式的函数调用 defer defer 会将函数推迟到外层函数返回之后执行 推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用 推迟的函数调用会被压入一个栈中，最后按照后进先出顺序调用 函数返回多个值 函数参数函数如果使用参数，该变量可称为函数的形参，形参就像定义在函数体内的局部变量 值传递 在调用函数时将实际参数复制一份传递到函数中，从而在函数中的修改不会影响到实际参数 默认情况下，Go 语言使用的是值传递 引用传递 在调用函数时将实际参数的地址传递到函数中，从而在函数中对参数所进行的修改将影响到实际参数 操作上是将指针参数传递到函数内 函数用法 传递给变量构成一个函数变量 闭包，借助匿名函数可直接使用函数内的变量而不必声明 方法，即一个包含了接受者的函数，接受者可以使命名类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集（类似面向对象） Go 语言变量作用域作用域为已声明标识符所表示的常量、类型、变量、函数或包在源代码中的作用范围 变量可以在三个地方声明： 函数内定义的变量称为局部变量 函数外定义的变量称为全局变量 函数定义中的变量称为形式参数（相当于函数体内的局部变量） 局部变量在函数体内声明，包括参数和返回值变量 可以与全局变量同名，在函数内会优先使用局部变量 全局变量在函数体外声明（main 函数外），可以在整个包甚至外部包（被导出后）使用 Go 语言数组数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，类型可以是任意的原始类型（整型、字符串等）或自定义类型 一个数组变量表示整个数组，在赋值或传递时会复制整个数组，如果希望避免复制则可以传递数组的指针 声明数组需要指定元素类型及元素个数 var variable_name [SIZE] variable_type —— var balance [10] float32 初始化数组 &#123;&#125; 中的元素个数不能大于 [] 多维数组套几个 [] 来声明，&#123;&#125; 来初始化即可 访问数组元素同其他语言 Go 语言指针取地址符 &amp; 什么是指针一个指针变量指向了一个值的内存地址，声明格式如下： var var_name *var-type 例如： 如何使用指针流程： 定义指针变量 为指针变量赋值 访问指针变量中指向地址的值（在指针类型前加上 * 来获取指针所指向的内容） 特殊指针空指针当一个指针被定义后没有分配到任何变量时，它的值为 nil，也被称为空指针 指针数组var ptr [Max]*int 声明一个存储指针的数组后逐个给其赋值地址 ptr[i] = &amp;a[i] 指向指针的指针var ptr **int 即已有一个指针，在获取其地址赋值给一个指针 指针作为函数参数在函数定义时 func swap(x *int, y *int) &#123;&#125; 在函数调用时 swap(&amp;a, &amp;b) （回想赋值格式即可） Go 语言结构体 Struct结构体是由一系列具有相同类型或不同类型的数据构成的数据集合 可同一般变量一样作为函数参数和指针（且仍用 . 访问成员） 定义结构体 访问结构体成员结构体.成员名 可用于获取和赋值 Go 语言切片 （Slice）切片是对数组的抽象，是一种“动态数组”，可追加元素 切片的零值是 nil ； nil 切片的长度和容量为 0 且没有底层数组 对切片的修改会作用到实际数组上 var identifier []type 未指定大小的数组即为一个切片 此处的 make([]T, length, capacity) 中 capacity 为可选参数 - 容量（最大长度） 具体切片操作同 python （貌似没有步长） 使用自带函数 len() 和 cap() 可获取长度和容量 切片在未初始化之前默认为 nil，长度为 0 copy(toSlice, fromSlice) 进行切片内容拷贝； Slice&lt;T&gt; = append(Slice&lt;T&gt;, Ts...) 进行元素追加（不增加容量） Slice&lt;T&gt; = AppendByte(Slice&lt;T&gt;, Ts...) 自动扩容的追加（原长加上追加长后 * 2） Go 语言范围（Range）range 关键字用于 for 循环中迭代数组（array）、切片、通道（channel）或集合（map）的元素，无需括号 在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key 对 Go 语言 Map （集合）Map 是一种无序的键值对集合，通过 key 来快速检索数据 如果不初始化 map，则会创建一个 nil map，其不能用来存放键值对；所以一定要 make 或者指向已存在的 delete(mapVar, mapKey) 用于删除指定 Map 的指定 Key Go 语言类型转换用于将一种数据类型的变量转换为另外一种类型的变量 type_name(expression) Go 语言接口是一种数据类型，把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口 Go 错误处理通过 error 类型接口提供，其定义如下 用 errors.New(str) 返回一个错误信息 Go 并发只需要通过关键字来启动 goroutine 即可支持并发 goroutine 是轻量级线程，goroutine 的调度是由 Golang 运行时进行管理的 go 函数名（参数列表） 以一个不同的、新创建的 goroutine 来执行一个函数 同一个程序中的所有 goroutine 共享同一个地址空间 通道（channel）是用来传递数据的一个数据结构，可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯 操作符 &lt;- 用于指定通道的方向，发送或接收。若未指定方向则为双向通道 通道缓冲区默认没有缓冲区，可通过 make 的第二个参数指定缓冲区大小 ch := make(chan int, 100) 带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。 不过由于缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，否则缓冲区一满，数据发送端就无法再发送数据了。 注意：如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。 通道遍历与关闭通道"},{"title":"Shader入门精要-常用编写","date":"2022-07-14T15:19:10.000Z","url":"/2022/07/14/Games/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81-%E5%B8%B8%E7%94%A8%E7%BC%96%E5%86%99/","tags":[["图形学应用","/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%BA%94%E7%94%A8/"],["着色器","/tags/%E7%9D%80%E8%89%B2%E5%99%A8/"]],"categories":[["Games-Graphics","/categories/Games-Graphics/"]],"content":"Shader 常用编写标准光照模型逐像素光照 和 逐顶点光照；通常逐像素的效果略佳 环境光部分 fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz; Lambert 反射考虑环境光和漫反射的着色模型，环境光视作常量，漫反射的光源视作平行光，反射光量由入射角度和法向的余弦值确定，即两个单位向量点积 将计算过程置于 vertex 部分或 fragment 部分就是顶点着色和像素着色的区别，不过需要的信息都是一样的；对顶点较少的简单模型通常其像素着色效果更佳，而复杂模型则差不多 Half Lambert 模型 ：初始的 Lambert 模型对负的余弦值直接取 0 做成纯黑，实际视觉效果不好；该方法即将 [-1,1] 的余弦值缩放平移到 [0,1] 来对负的值也进行着色 Specular 反射镜面反射，能计算出高光的出射角，当视线方向在出射角附近时能观察到高光，此附近判断通过计算角度代入一个指数函数的基得到 Blinn-Phong 光照模型简化反射角度的计算，使用光照和视线向量的和 v_sum，若视线接近出射角度则 v_sum 和法线比较接近，因此可以使用 v_sum 点积 normal 来代入上面的指数基 感觉高光范围更大一点 纹理映射一个模型的顶点通常都会定义 纹理坐标 texcoord 属性，描述该模型的平面展开图到一个 [0,1]^2 范围的映射，而在应用纹理时即通过这个值得到纹理细节分布；纹理 ST 通常为 (1,1,0,0) 表示无缩放无偏移 环境光和漫反射部分受材质影响，但镜反射高光与材质颜色无关，为什么呢？ 凹凸纹理o.uv 前两个值存 _MainTex 的纹理坐标，后两个存 _BumpMap 的（实际上通常使用同一组纹理坐标）；后续同样要 tex2D(_BumpMap, i.uv.zw) 渐变纹理下面实现了渐变的漫反射颜色 遮罩纹理实际使用中通常可以充分利用 mask_tex 的每个通道 透明效果必要声明 透明度测试效果 透明度混合效果（ZWrite Off 也可以写在 SubShader 中） Alpha Test使用 CG 语言中的 clip，其可传入标量或向量，只要任一分量小于 0 就舍弃该片元；其他实现没啥差别 Alpha BlendTags {“Queue”=”Transparent” “IgnoreProjector”=”True” “RenderType”=”Transparent”} 不需要 cutoff 部分，只要在 Pass 内声明，并在片元着色器中给透明度赋值即可由内部完成 开启深度写入的 Alpha Blending使用两个 Pass，在第一个 Pass 内仅声明 ZWrite On 和 ColorMask 0 来写入深度并且不输出颜色，第二个 Pass 和通常的 Alpha Blending 一致 ColorMask 后接 RGBA 的任意组合或 0，设置颜色通道的写掩码(write mask) 混合模式感觉可以另起一篇，回去看第八章最后再写吧"},{"title":"Shader入门精要-概述","date":"2022-07-14T15:16:45.000Z","url":"/2022/07/14/Games/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81-%E6%A6%82%E8%BF%B0/","tags":[["图形学应用","/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%BA%94%E7%94%A8/"],["着色器","/tags/%E7%9D%80%E8%89%B2%E5%99%A8/"]],"categories":[["Games-Graphics","/categories/Games-Graphics/"]],"content":"简介 HLSL 语法 数据类型：bool、int、float、double；half 表示 16位浮点数；fixed 通常使用 11 位，精度范围 -2.0~+2.0 向量 ：TypeN(2 &lt;= N &lt;= 4) 例如 float3 初始化 ： 访问 ：vec[i]; 或者字母语法 xyzw 或 rgba，可以同时用，例如 vec.xy 得到一个二维向量；甚至可以 vec.xxyy 得到四维 矩阵 ：TypeAxB 初始化 ： 访问 ：mat[i][j]; 或 mat._12; 或 mat._m12; 其中 数组 ：例如 float arr[i][j]; 以及 int3 vecarr[3] 结构体 ：struct … 仅允许变量成员，直接下标访问 内置函数 ：官方文档 流程控制 ：基本和 C/C++ 一致，多一条 discard 放弃该像素输出 语义 ：描述着色器在渲染管线上的标准输入输出内容，通过语义变量传递；官方文档 着色器 Shader一般的着色流程是 ：顶点数据-&gt;顶点着色器-&gt;曲面细分着色器-&gt;几何着色器-&gt;裁剪（剔除视野外顶点转为可见点）-&gt;屏幕映射-&gt;三角形设置-&gt;三角形遍历-&gt;片元着色器-&gt;逐片元操作-&gt;屏幕图像 顶点着色器 Vertex Shader ：主要执行顶点的坐标系变换来模拟不同的材质效果；一个毫无变化的变换即左乘 MVP 变换矩阵进行透视投影 裁剪 ：经过变换后部分顶点在标准 Cube 之外，也即当前 FOV 的视野外，通过裁剪将外部顶点剔除，或者转为 Cube 上的可见顶点 屏幕映射 ：直观地从 [-1.1] 映射到屏幕，DirectX 以左上角为 (0,0) 而 OpenGL 以左下角 片元着色器 Fragment Shader ：将三角形的覆盖关系综合（类似深度缓存等）得到片元的综合信息；纹理采样也在这一步完成 模型空间 model space 指的是以模型自身定义轴朝向的空间裁剪空间 clip space 指的是以远近平面执行透视投影的视锥范围 Unity Shader集成了 Shader 的必要编写和其他渲染的设置开关 最外部是 ShaderLab 语义块，定义了该 Shader 的名称和目录层级 Proderties 语义块内可以定义一些通用属性，会在编辑器内可见 格式写为变量名(“说明”,类型)=(默认值) SubShader 语义块用于针对不同的系统定义不同的 Shader Pass 语义块，（必须）其内定义顶点、片元着色器，需要用 CGPROGRAM 和 ENDCG 在首尾行包围；一些特效可使用多个 pass 语句块；（可选）定义一些 Tags 例如光照模式 FallBack 没有适配的 SubShader 时调用这个 一个普通的贴图着色器；其中需要在 Pass 内引入 Properties 定义的属性到变量，函数后接 基本语义 传入顶点着色器 POSITION ：模型空间顶点位置，通常为 float4，要转为世界空间 NORMAL ：顶点法线，通常是 float3 TANGENT ：顶点切线，通常是 float4，因为有两个垂直的方向 TEXCOORDn ：顶点的纹理坐标，n 描述第几组，通常 float2 或 float4；前两个分量为 uv，后两个分量表示偏移量 COLOR ：顶点颜色，通常 fixed4 或 float4 传入片元着色器 SV_POSITION ：裁剪空间中的顶点坐标，传入的结构体中必须包含一个用该语义修饰的变量；float4 COLORn ：通常用于输出几组顶点颜色，但非必须 TEXCOORDn ：通常用于输出纹理坐标，但非必须 片元着色器输出 SV_Target ：输出值将存储到渲染目标中；fixed4 八股 顶点着色器任务 把顶点位置从模型空间转换到裁剪空间，即对 POSITION 的变量施加 MVP 变换传给 SV_POSITION；UnityObjectToClipPos(v.vert) （片元光照需要）把法向从模型空间转换到世界空间，因为 unity 存了 World2Object，所以反过来乘；wNorm = mul(v.norm, (float3x3)unity_WorldToObject);；当然用 unity_ObjectToWorld 也行 片元着色器任务 一些常见 Shader 的原理标准光照模型 自发光（emissive）部分：由材质直接决定，但此处不视作光源 高光反射（specular）部分：在镜面反射的出射方向周围能看到高光 使用实际观察视角对比反射方向；或者半角向量对比法向 Gloss 参数反映高光的范围 漫反射（diffuse）部分：遵从 Lambert 定律，均匀到所有出射方向 环境光（ambient）部分：此模型下假设为一个常量，实际应当考虑光线多次反射，即全局光照 一些常用变量，来自 Lighting.cginc UNITY_LIGHTMODEL_AMBIENT.xyz 四维环境光向量 _WorldSpaceLightPos0.xyz 世界坐标中光源的位置或方向向量；若 w 为 0 表示平行光（描述方向）；为 1 表示点光源或聚光灯（从而描述位置） _LightColor0.rgb 光照也有颜色，不过通常认为都是白光 _WorldSpaceCameraPos.xyz 世界坐标中相机位置 一些常用函数 pow(x, y) 计算以 x 为底 y 为指数的值 saturate(x) 相当于 max(0, x) 纹理在 Shader.Properties 中提供 _MainTex (&quot;Main Tex&quot;, 2D) = &quot;white&quot; &#123;&#125; 可以赋予纹理贴图，然后在 HLSL 代码片段中声明 sampler2D _MainTex; float4 _MainTex_ST; 其中后者要与前者变量名对应，并以 _ST （Scale、Translation）结尾，该四维向量描述了 xy 缩放值和 zw 偏移值； 因此实际的纹理 uv 要用 o.uv = texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw; 然后再到纹理上采样 tex2D(_MainTex, i.uv).rgb 纹理类型 Texture ： Alpha from Grayscale ：使用像素灰度值生成透明度通道 Wrap Mode ：平铺模式，有 Repeat 和 Clamp(截取) Filter Mode ：拉伸时的滤波模式；其中 Trilinear 需要纹理使用 mipmap 才由于 Bilinear Normal map ： Cubemap ： 法线纹理 法线纹理 ：在每个顶点的切线空间中描述法线，则法线为 z 轴正向的单位向量；存储了法线经过映射后得到的像素值，将原本的 [-1,1] 区间映射到 [0,1] 区间，因此在从 BumpMap 采样后要反映射；虽然没太懂，反正用切线空间做法线贴图就对了，TA的工作 高度纹理 ：存储强度值（intensity）描述局部海拔高度，模拟表面的顶点位移 需要 _BumpMap (&quot;Normal Map&quot;, 2D) = &quot;bump&quot; &#123;&#125; 和 _BumpScale (&quot;Bump Scale&quot;, Float) = 1.0 引入 声明时 sampler2D _BumpMap; float4 _BumpMap_ST; 渐变纹理使用简单的 [0,1] 区间的渐变色映射达成非真实渲染效果，可以用于漫反射等部分 同样使用 _RampTex 引入，并声明 sampler2D _RampTex; float4 _RampTex_ST; （虽然好像没用到 ST） 遮罩纹理mask texture，通常用于保护某些区域不被修改，例如采样纹素后用某个通道的值乘上某个表面属性，控制纹素值为 0 即避免被修改变化； 同样引入 2D 的 Texture 不过也无需声明 ST（因为大多数时候无需缩放偏移，或者都使用同一套缩放偏移） 透明效果透明通道，为 0 表示全透明，在 Unity 中通过透明度测试或者透明度混合实现；深度缓存足够解决非透明（opaque）物体的渲染 Alpha Test：暴力二值化，透明度小于阈值就不光栅化，大于就视作不透明 Alpha Blending：使用透明度做片元的混合因子；需要关闭深度写入，但不关闭深度测试 即构建一个只读的 depth buffer，尽可能把最近的不透明物写入深度 先渲染所有不透明物体，并开启深度测试和深度写入 从远到近排序半透明物体，并此顺序渲染；开启深度测试但关闭深度写入 然而物体还是可能循环遮罩，因此可能需要分割网格 Unity 的解决方法提供了 render queue，队列索引号越小越先进行渲染 名称 队列索引号 描述 Background 1000 在任何其他队列之前，用于渲染背景上的物体 Geometry 2000 默认队列，大多数物体、不透明物体 AlphaTest 2450 需要透明度测试的物体使用 Transparent 3000 任何使用了 alpha blending 的物体都应该使用 Overlay 4000 用于实现叠加效果，最上层（UI等） 透明度测试的额外工作比较少；而透明度混合需要使用 Unity 提供的混合命令 Blend Off : 关闭混合 Blend SrcFactor DstFactor : 开启并设置混合因子，该片元颜色乘以 Src，缓存颜色乘以 Dst 相加后存入颜色缓存 Blend SrcFactor DstFactor, SrcFactorA DstFactorA : 针对 rgb 和 A 通道使用不同的混合因子 BlendOp BlendOperation : 非简单相加，而是指定其他 Operation 开启混合模式(第二项)默认以 SrcAlpha 和 1 - SrcAlpha 为因子；当然可以自行指定 特效类模型操作上即使仅仅用把法向转为颜色来输出都能看到效果，因此 Shader 其实是个看重想法的工具 锈蚀效果 ：另增添一个 tex2，采样点若在 tex2 上超过某个阈值则更改他（实际上也不是必要 tex2） "},{"title":"Games202-实时全局光照","date":"2022-07-02T05:29:52.000Z","url":"/2022/07/02/Games/202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/Games202-%E5%AE%9E%E6%97%B6%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/","tags":[["games","/tags/games/"],["计算机图形学","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"]],"categories":[["Games-Graphics","/categories/Games-Graphics/"]],"content":"Real-Time Global Illumination全局光照即描述光线多次反射照亮物体的效果，递进式地先考虑间接光照 Reflective Shadow Maps （RSM）要计算间接光照首先要得到直接光照点，即光源首次照射到的物体，回顾 Shadow Map 显然就是需要的方法，光线穿过足量的网格落在场景点上 此时需要假设在每个直接光照点处，光线都发生漫反射，向所有方向均匀地反射光线 在考虑间接光照的时候已经顾不上去计算间接光的 visibility 提速为了提升效率达到实时，使用了非常大胆的 trick ：只有足够近的点作为次级光源会照亮着色点 对于 RSM 上记录的着色点 p，需要同时记录其 深度、世界坐标、法向、flux 等，然后通过世界坐标确定其他足够近的着色点 rs，计算 rs 到 p 的间接光照最终完成着色 针对手电筒类光源效果最好 Light Propagation Volumes (LPV)基于光线在直线传播时能量不变的性质，考虑在三维上划分空间网格；算法大致流程如下 Generation ：使用 RSM（足矣）或其他算法得到直接光源照亮的样本点，经过可选的采样得到虚拟光源 Injection ：基于预划分的网格逐个对其内部各朝向的 radiance 求和，然后投影到二阶（4个）球谐函数上 Propagation ：每个网格统计其六个面上接收的光照，向对应的相邻网格传播，持续多轮迭代直到光照在所有网格上稳定 Rendering ：对任意的着色点，确认其所在网格，根据网格内的各朝向 radiance 进行着色 因为统计了方向，因此对 diffuse 和 glossy 都有效 问题 ：网格过大发生漏光，网格过小耗费内存和效率 Voxel Global Illumination (VXGI)类似 RSM 是一种执行两步的算法，相较之下的主要区别是 ： 将场景内的建模物体划分为网格，直接光照照射物体时描述具体到单个网格（体素 Voxel） 网格具有树状的层级关系，多个网格的集合构成上层节点 Pass 1 from the light ：从光源出发向场景采样式（RSM 等）发出光线，落到树结构上，在每个层级节点上记录入射光线和该层级反射面法线的分布 Pass 2 from the camera ：同样发出视线落到场景着色点上，反射出一条射线并构成锥体，该锥体再与第一步完成的树结构交互来统计对着色点有贡献的间接光源；针对 diffuse 则使用相邻的几个圆锥覆盖半球面 GI in Screen Space大致概括为从已知直接光照渲染结果的屏幕图出发，实现全局光照的渲染效果 Screen Space Ambient Occlusion (SSAO)环境光遮蔽，即邻近物体间的阴影效果，使场景更具有立体感 假设： 所有位置都会有来自各个方向的等量环境光（同 Blinn-Phong 模型思想） 不同的着色点不一定能对所有环境光可见，因此实现遮蔽 因此环境光遮蔽效果实际上就是使用常量光去乘上着色点的平均 visibility 得到 计算 visibility在模型空间上很容易理解可见性的计算，实际从着色点出发进行 Ray Tracing ，在一定距离内若未发生遮挡则认为该该方向可见 在屏幕空间上，我们可以使用渲染时记录的深度图，对每个着色点进行球体范围内的采样，每个样本点映射到深度图上比较记录的深度，由此得到样本点是否位于物体内部，转化为是否能被着色点可见；由此近似着色点的 visibility 因为 AO 效果通常不会单独实现，因此不必要过多采样，而是用少量采样（约 16 个）得到有噪声的结果，然后模糊处理再叠加到渲染图上即可 HBAO相交于 SSAO 进一步考虑着色点的法线方向，由此可以仅对半球采样，效果更好 Screen Space Directional Occlusion类似 AO 考虑着色点的可见性，但是 AO 认为近处的物体造成遮蔽效果，使得实际着色变暗；而 DO 认为近处遮挡物体造成间接光照，向着色点染上其他颜色，未被遮挡的光线为固定的环境光照 同样考虑间接光照时，也像考虑遮挡性一样仅计算较近距离内的遮挡物 Screen Space Reflection (SSR)在屏幕空间做光线追踪 先从视线处向反射表面射出 ray 根据 depth buffer 到达 ray 与反射面的交点，根据存储的法线、粗糙度信息得到反射 ray 分 step 追踪反射 ray 并比较深度，直到当前点大于深度，认为已经到达物体内部 步长的确定显著影响效率和效果，使用 Hierarchical Tracing 算法，通过 minPooling 建立原始图像的 mipmap（从高到低细分），则光线与高层像素未相交时，显然与低层像素不会相交 屏幕空间只能看到二维深度记录的点，如果光线反射到外部都未发生交则认为没有反射（使用时根据反射光线的长度减弱反射效果） 屏幕空间上的遮挡点未记录深度，会有部分反射效果无法实现（不知道怎么解决） Our requirements Sharp and blurry reflection Contact hardening Specular elongation 各向同性的反射面上，形成（雨天水面）拉长的效果 Per-pixel roughness and normal "},{"title":"Games202-实时渲染阴影","date":"2022-06-20T13:50:15.000Z","url":"/2022/06/20/Games/202%E9%AB%98%E8%B4%A8%E9%87%8F%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93/Games202-%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E9%98%B4%E5%BD%B1/","tags":[["games","/tags/games/"],["计算机图形学","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"]],"categories":[["Games-Graphics","/categories/Games-Graphics/"]],"content":"内容概述RTR dose not trust in Complexity 实时渲染不相信复杂度，只相信速度；2n 就是不如 n Real-Time High Quality Rendering 高质量实时渲染 Real-Time 实时性 Speed ：高于 30 FPS 甚至更高 Interactivity ：实时交互性 High Quality 保持较高质量 Realism ：具有真实性 Dependability ：维持正确的渲染 涉及 Shadow and Environment Mapping ：动态物体的实时多维阴影 Interactive Global Illumination Techniques ：实时的全局光照 Precomputed Radiance Transfer ：预计算 Real-Time Ray Tracing ：实时光追 Non-Photorealistic Rendering ：非真实感渲染（略述，另起专题） Antialiasing and Supersampling ：反走样和上采样 Glossy 是介于 Diffuse 和 Specular 之间的类似金属材质的反射 作业框架分为 Vertex Shader 和 Fragment Shader Vertex Shader ： attribute 关键字声明顶点属性，仅在顶点着色器内使用 uniform 关键字表示从 CPU 直接拷贝入 GPU 的全局变量 varying 关键字描述要处理后交给片元着色器的变量 highp 表示高精度 变换后的顶点位置要赋值给 gl_Position 变量，一个 vec4 Fragment Shader ： 更多的全局变量，如折射率，光源位置等 声明 varying 的变量用于表示从顶点着色器中收到 输出的颜色要赋值给 gl_FragColor 变量，一个 vec4 Shadows 阴影传统方法 Shadow Mapping ：执行两次渲染，先从光源出发得到所有可照射点的深度，然后从相机出发将可视点对照其在前一次渲染中的深度来确定是否有阴影；有几个缺陷 Self Occlusion 自遮挡 ：光源斜射向平面，由于没穿过一个像素射出的光线打到平面上都认为是常数的深度，分布在一个与该光线垂直的小方片上，此结果就可能遮挡在小方片后面的平面点，造成“不存在的阴影”；解决Trick ：当深度显著大于记录时才认为有阴影，即引入一个 threshold，可以根据角度变动；或者使用二次深度，但工业上没人用，增加时间 Aliasing 走样 ：跟光栅化时的走样原因一样 数学近似在实时渲染中有一个贯穿始终的近似式，其在 g(x) 的支撑集较小或者取值较平滑时都能有很好的近似效果 \\int_{\\Omega}f(x)g(x)dx\\simeq \\frac{\\int_{\\Omega}f(x)dx}{\\int_{\\Omega}dx}\\cdot \\int_{\\Omega}g(x)dx基于这个近似将 RTR 的渲染方程中 可见性 一项视作 f(x) ，处理点光源或平行光源照射到漫反射表面的模型时近似效果最佳 Percentage Closer Soft Shadows PCSS软阴影描述了一种由面光源产生的具有一定渐变性的阴影效果 使用 PCF（Percentage Closer Filter） 实现的软阴影效果，其中前者本身用于抗锯齿 PCF 原理 ：可以理解为基于原始的 Shadow map，采用一个卷积核 Filter 观察每个点在核视域内的可见点占比，以此比率作为该点的可见性，形成软阴影效果；公式如下 V(x)=\\sum_{q\\in \\mathcal{N}(p)}w(p,q)\\cdot \\chi^+[D_{SM}(p)-D_{scene}(x)]其中 x 表示着色点，p 为向光源中心射线后到 Shadow map 的交点，邻域由 Filter 大小确定，权重通常使用高斯核 使用时越小的 Filter 得到锐利的阴影，越大的则得到软阴影；为了更符合现实，通常使靠近遮挡物的阴影更锐利，远处则采用更大的卷积核做出软阴影 完整流程 Blocker search ：从着色点向面光源中心射线，得到 shadow map 上的像素，然后使用可调的 Filter 获取区域内所有深度小于该点的平均深度，表示遮挡物的平均深度 一个启发式的方法，不向光源中心而是向面光源顶点射线，由此得到 shadow map 上的区域 Penumbra estimation ：使用平均深度来确定合适的 PCF 大小 PCF 注意 ：非常遗憾，反复的卷积操作非常耗时，因此工业上还需要很多的 Tricks 才能应用 Variance Soft Shadow MappingPCSS 主要耗时在于第一步和第三步，比较直觉的优化是引入噪声采样而非全部遍历，但缺点也很明显 针对第三步 由于 PCF 步骤需要根据卷积核内的更深像素数占比来确定阴影强度，相当于检查深度名次，因此近似看作高斯分布，确定 均值、方差、当前值 来快速确定该“名次” 为此需要快速查询区域的均值和方差方法： 均值 ：使用 Hardware Mipmap 或者 Summed Area Tables （推荐） 方差 ：使用平方的期望减期望的平方计算方差，因此即使用两张 SM 来完成查询，正好查均值也要用；在生成 SM 时就可以完成 然而根据高斯分布查表或求数值解还是不算快，因此又引入切比雪夫不等式用于近似（把不等号直接视作越等号，要求 t 值在均值右侧） P(x>t)\\le \\frac{\\sigma^2}{\\sigma^2+(t-\\mu)^2} 针对第一步 容易查询得知区域内的所有点深度均值 $Z{avg}$，需要获知深度小于当前点的平均深度 $Z{ooc}$，与之对应的非遮挡物平均深度为 $Z_{unooc}$ 由此有个简单的公式 \\frac{N_1}{N}Z_{unooc}+\\frac{N_2}{N}Z_{ooc}=Z_{avg}使用切比雪夫近似地估计 $\\frac{N_1}{N}$ 并且将非遮挡点的深度视作和当前点深度一致为 t （纯纯的 Trick），由此即可计算出遮挡点的平均深度 范围查询上面都说了查到均值后如何计算，这里则给出如何快速查询均值，即使用 MIPMAP 或 SAT MIPMAP ：（仅能查询方形区域）根据目标点找到两个层级，然后插值完成 Summed Area Tables ：即是用前后的前缀和做差得到范围内的和（一维），二维则使用矩形区域 Moment Shadow MappingVSSM 在非均匀的深度分布下可能漏光，因为切比雪夫的近似仅使用到二阶矩 MSM 即使用高阶矩（通常 4 阶）来近似分布函数去计算比率 Distance Field Soft ShadowsOptimal Transport 在空间中定义一个物体的距离场，描述各个点到该物体表面的最近距离，（可以考虑带符号，内部为负）用于实现运动的插值；距离场函数用 SDF(p) 描述，表示点 p 到物体的最近距离 此时可知从点 p 出发向任意方向运动 SDF(p) 都不会撞上物体 注意 ：渲染上尽量避免复杂的运算，因此 arcsin 这类也要避免，转而使用下式近似描述角度，同时 k 可调整软硬程度，k 越大越锐利 min{\\frac{k\\cdot SDF(p)}{p-o}, 1.0}然而还要考虑生成 SDF 的时间，针对形变的物体都要重新生成 Environment Mapping描述环境光是指从当前点向任意方向看去所能捕获到的光照，有两种图像表现形式 ：Spherical、Cube ；其中球状的映射在南北极会有明显的拉伸变形 Image-Based Lighting （IBL）已知环境光照的存储图像，还原任意物体的着色；通过 Rendering Equation 借助蒙特卡洛方法能实现，但其效率通常认为无法用在实时渲染上 回顾在 SM 中使用过的积分近似，针对 glossy 表面的 brdf 仅在较小的反射区域取值，而针对 smooth 表面则在半球面上保持平稳，正好符合要求 The Split Sum针对近似的渲染方程，分两个部分考虑积分值： 框选分式部分 ：基于高斯滤波对环境光照图像进行预处理（mipmap），然后按照 brdf 去单次采样特定方向的光照图；例如镜面反射方向（glossy）或法线方向（漫反射） 余下积分式部分 ：回顾 101（五） 中提及的 “微表面 BRDF”，将式子中的 f 拆分为分子中的三式；考虑菲涅尔项的 Schlick 近似，将 f 除以 F 再乘以近似式并展开，得到积分可写成仅与粗糙度和角度有关，足以做成 LookUpTable 最终将所有的积分都转为小变量求和，即构成 Split Sum Shadow from Environment Lighting具体很难实现，工业上有一个做法是仅实现一个最强光源产生的阴影 前置知识频域图可以理解为以坐标为变化频率的点数统计，中心即代表变化频率 (0,0) ，因此表示低频信息 每一阶的球谐函数都构成一组基，对于任意角度函数 f(ω) ，其表示成相应基的线性组合时的系数可计算 c_i = \\int_{\\Omega}f(\\omega)B_i(\\omega)d\\omega使用前三阶的球谐函数来近似漫反射的 BRDF 和入射光照（两者都是低频信号）足以取得很好的效果 Precomputed Radiance Transfer （PRT） 针对漫反射情况，将光照项分解成球谐函数的线性组合，提取出系数项并将基函数项保留在积分式中，预计算积分部分（也可以展开成基函数的线性组合）；最终与任何角度都无关 代价就是，一旦场景中物体发生位置变化，就会影响可见性的部分，即需要重新预计算 针对 Glossy 情况，输出结果与观察方向有关，将出射方向 o 展开成基函数形式，最终针对一个着色点需要存储一个矩阵大小的信息 进阶往后还有使用小波变换来代替球谐函数的研究"},{"title":"Games104-游戏引擎中的渲染、动画、物理","date":"2022-06-12T04:03:33.000Z","url":"/2022/06/12/Games/104%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Games104-%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E6%B8%B2%E6%9F%93%E3%80%81%E5%8A%A8%E7%94%BB%E3%80%81%E7%89%A9%E7%90%86/","tags":[["games","/tags/games/"],["现代游戏引擎","/tags/%E7%8E%B0%E4%BB%A3%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"]],"categories":[["Game-Engine","/categories/Game-Engine/"]],"content":"Basic of Game Rendering针对场景、材质等渲染和动画的渲染，可以花费时间代价来追求效果，而游戏中的渲染则更加注重实时性 Challenges on Game Rendering 实时性 针对不同硬件平台的统一性 帧率的稳定性 算力限制，不能在渲染上花费太多资源，要分给其他部分 非真实感渲染 渲染问题总是非常耗时，为了实现好的渲染效果，一个很基本的思想即是预计算转化为少量参数，成像时仅需要采样即可 投影和光栅化；补充上反走样的处理 Hardware architecture SIMT (Single Instruction Multiple Threads) 现代显卡的理念 Render data organization 将网格、材质等描述的 Game Object 组织起来进行渲染 网格顶点的数据实际存储，而构成的面则可以仅存储顶点的索引 材质数据主要由纹理来描述 经过 Renderer 完成具体效果的渲染 架构问题 ：一个完整网格物体通常由很多部分不同材质构成，以 submesh 区分；很多对象通常有一致的模型，因此在渲染一种材质后构成一个 pool，通过对应检索即可略过大量重复计算 Visibility： 仅需要渲染当前视野内可见范围的对象，即一个从相机出发的四棱锥；引入一些树划分方法（如 BVH）来快速地确定可见区域内地对象 Potential Visibility Set ：一种早期想法，以房间划分则仅有门窗可透视，此时仅需要渲染有门窗相连地场景 贴图压缩 Texture Compression为了节约存储同时又保证随机访问的效率，通常采用 Block 压缩，将贴图每四个方形像素分块，保存少量信息实现压缩 Cluster-Based Mesh Pipeline现代化的新发展方向、Nanite Materials, Shaders and Lighting渲染方程（见 Games101） 三大难点：1.如何计算各个方向的入射 irradiance；2. 如何精确地在半球面上积分；3. 如何考虑光线的多次反射 考虑散射光、Blinn Phong、Shadow Mapping，实现的效果以及差不多够看了 球谐函数 Spherical Harmonics —— 一组三维空间中使用两个角度 θ 和 φ 描述的基函数，因为是基函数，可用于近似任意的三维函数，只要提升阶数就能降低偏差 使用球谐函数简化光照 PBR(SG, MR) Physics-Based Rendering Shader permutation Lighting Special Rendering地形、大气、云层；以及后处理 渲染上的实现通常控制屏幕中的像素量保持不变，原始的大地模型都采用比较大的网格，根据相机位置将近处的网格细分，保证在同样的 FOV 下观察到的网格总量尽可能一致；一些射击游戏中的倍镜通过缩小视角实现，此时在保持网格数不变的情况下，对远处图像的表示精度就提升了 Terrain：通常借助等高线 HeightField； QuadTree 四叉树，将大面积的地形切割存储 —— 切割时总会有一个边界上两侧的切割数不一致，解决方法是将更细分得到的顶点吸附到粗分的顶点，称为 stiching Mesh Shader Real-Time Deformable Terrian ：外部 GO 交互影响材质，形成类似“雪痕”效果 Camera-Raletive Rendering —— 制作大地形时，对远处的网格渲染很容易发生浮点数精度误差而抖动；一种 trick 就是挪动相机后使用相对相机的位置 数目、装饰物（如草丛等）的渲染：近处实现精细渲染，远处简化为柱体等 Sky / Fog ：都通过介质描述，光路在通过介质时会发生 散射、通透；其中通透部分经过积分削弱即完成 Rayleigh Scattering、Mie Scattering Clouds ：使用 Volumetric Modeling（体积度量的模型），引入噪声实现不同的形状，模拟分形效果 PiplineAmbient Occlusion ：环境光遮蔽，描述一种表面凹陷形成黑暗区域的视觉效果 雾效 Fog Everything 反走样 Anti-aliasing ：由于输出以像素为单位，总是存在走样问题 后处理 Post-process Real pipeline with mixed effects Ring buffer and V-Sync Tiled-based rendering Basic of Animation Technology基于视觉残留 游戏动画的挑战 ： 交互性和动态变化 实时需求，和所有的功能模块竞争单帧算力 动画的真实性，包括整体动作和微观细节，如表情 2D 动画Sprite Animation —— 使用大量的连续帧构成动画；早期节约资源的方法 Live2D —— 将各种需要分别设计动作的部分（眼睛、眉毛、嘴巴等）分为图元，调节深度可控制显式，加入控制点实现局部形变来模拟动作 3D 动画DoF (Degrees of Freedom) —— 对刚体运动的表达，例如三个轴向的平移加上绕三个轴的旋转即达到 6DoF；再加上三个方向的 Scale 达到 9DoF 几种动画方法： Per-vertex Animation —— 记录每个顶点的位置离线模拟，顶点变化影响法向，从而影响材质的表现 Morph Target Animation —— 由顶点动画发展来，通过关键帧顶点位置插值完成动画 3D Skinned Animation —— 使用骨骼结构穿插到模型内，模拟动作；使用最广泛的一种，2D 也有 Physics-based Animation —— 布娃娃系统，使用纯物理来模拟骨架；IK (Inverse Kinematic) Skined 动画如何实现先建立骨骼然后在外部套上网格，基本固定网格相对骨骼位置，控制骨骼运动 几个重要的设计点： 先确立骨骼的局部坐标系，以此为基准确定外部网格，然后转为世界坐标系进行渲染；其中转化的矩阵运算需要确保无误 不同动物体的骨骼都有所不同，都需要符合现实分别设计 实际上骨骼的运动是通过关节运动实现的，正向运动学已知关节变化角度来确定位置，但不方便设计；逆向动力学已知位置逆推关节角度 需要初期设计好一个标准模型的骨骼架构，而针对一些复杂模型如带大服饰、物件的模型再追加设计 在椎骨末端增加一个尾骨连接到两足中间，不影响模型位置，同时方便实现跳跃、下蹲等动作的高度调整 两个或多个骨骼模型的绑定实现，当绑定后将有部分形变保持一致 Math of 3D Rotation 欧拉角度的几个问题： Gimbal Lock ：一定角度下会失去一个 DoF（查一下） 难以插值，线性插值结果不正确 无法进行旋转组合，仅方便描述单物体单次旋转 难以给定向量绕其旋转 Quaternion 四元数，神中神 （定时22/10/01自己整理一篇） 将等式同时左乘关节的 pose 矩阵，可以理解为在绑定时刻仅知道绑定关节的空间位姿和本节点的坐标，以此算出本节点相对绑定关节的局部空间坐标 以此局部空间坐标，在任意时刻左乘绑定关节的空间位姿，即得到本节点在该时刻的模型空间坐标 Skin 的网格坐标通常取几个关节点的 model space 坐标加权后插值得到 插值前做一个点积运算判断往那边是更近的插值 插值方法 ：NLerp 首尾点连线上插值，然后伸长到弧上（不均匀）、SLerp 反三角函数运算，根据角度插值 通常角度较小时 NLerp 节约时间；较大时 SLerp 保持自然 动画压缩 Animation Compression大致思路是分为 Rotation、Transparent、Scale 三个维度，逐帧检查是否需要插入关键帧，若以某处为关键帧向前插值会造成较大误差，则取前面发生该误差的时间点作为关键帧，然后继续向后搜索 Advanced of Animation动画混合 Blending 线性 Blending 实现连贯的动画效果转换，以人物的行走到跑动的转变为例 ： 行走和跑动都有一组循环的动画，并且分别有一个速度水平 根据实际动画中的速度水平线性插值计算出当前速度下的两者权重 将行走和跑动的动画都根据时长归一化，然后对应每一个点都是用上面算出的权重插值得到中间的动画 更进一步的有更多方向的运动，但要进行插值都至少要有几组确定好的循环动画；关于多方向运动的插值有 Delaunay Triangulation 进行二维空间划分然后使用三角形重心坐标插值 Skeleton Mask Blending ：遮罩混合（不翻译更好），类比图像的 mask，即一部分骨骼不应用动画；例如坐着摆手 Additive Blending ：仅保存动画的变化量，例如点头动画，可以任意加上旋转；但也要适度，否则会有 joint 异常 动作状态机 Animation State Machine就是状态机，按照一定的规则切换动画；具体的状态机仅判断输入和前一刻状态完成状态更新，具体动画通过读取当前状态以及是否发生更新来选择输出 Cross Fade ：切换过程中采用一定时长及曲线来渐变转换，有很多种 Fade Curves Layer ASM ：分层状态机（鬼泣5），查查看 动画树 Animation Blend Tree学习虚幻引擎 IK 技术 Two Bone IK ：以脚踩凸出地块为例，确定大腿根部和凸出地块坐标，分别以大小腿骨骼长度做出两个球，则球表面相交环都可以作为中间关节的位置；然后考虑运动方向，只取通向侧的最外点即得到结果 稍微长一点的骨骼结构就很难，一些启发式算法（都不能确保达到终点，需要给出一个接受水平来停止迭代）： CCD (Cyclic Coordinate Decent) ：几乎纯 hack 的方法，从叶子关节往上迭代，每次都调整当前关节使末关节靠近目标点（达到一定范围后进入下一次），迭代到根关节时再重开 FABRIK (Forward And Backward Reaching IK) ：循环执行向前和向后步骤直到一定水平 向前步骤，强制移动叶关节到目标位置，向前一个关节连线，保留骨骼长度得到前几段的终点，然后递归；完成一步后通常根关节会变化位置 向后步骤，即把初始的根关节位置作为目标点，反向执行上面描述的步骤 动画重定向相同的一组动画效果应用到不同的骨骼结构上 Physics SystemBasic Concepts通常把游戏实现分为逻辑层和渲染层，物理效果大部分在逻辑层实现 一个物理系统的参与者称为 actor，可分为四类：Static、Dynamic、Trigger、Kinematic（运动学规则约束，违背物理） 基础的几何形体（方便求交）：球体、胶囊体（通常用在人物上）、Box、Convex Mesh（石块类）、Triangle Mesh、Height Field（地形等） 形体属性：质量、密度、质心、物理材质 Material（摩擦力 Friction、弹性 Restitution） 力与运动 常规持续的作用力，如重力，拖拽力，摩擦力 瞬时触发力冲量 impulse 运动的实现 ：见简述粒子运动 动量 = 质量 × 速度 刚体动力学 朝向 Orientation $\\mathbf{R}$（矩阵或四元数表达） 角速度 Angular velocity $\\vec{\\omega}$ 角加速度 Angular acceleration $\\vec{\\alpha}$ 惯性张量 Inertia tensor $\\mathbf{I}$ 角动量 Angular momentum $\\vec{L}=\\mathbf{I}\\vec{\\omega}$ Torque $\\vec{\\tau}=\\frac{d\\vec{L}}{dt}$ 碰撞检测一般通过粗细两次筛选 粗筛中可用 BVH、Sort and Sweep —— 分轴向排序盒子边界来判断是否相交 细筛中有三种方法： 形状相交检测 ：基于简单形状判断，球、胶囊类 Minkowski Difference-based Methods Minkowski 和，描述两个集合内各取任意一（向量）点的和的集合；同理定义差 平面上的两个凸包点集有交 iff 两者的 Minkowski 差包含原点 后续引入 GJK 算法对有交的情况快速找交点 Separation Axis Theorem 不相交的两个形状一定能找到分离轴；三维上即分离面 Applications暂略 PBD、XPBD"},{"title":"Python-游戏脚本","date":"2022-06-08T11:51:41.000Z","url":"/2022/06/08/OpenCV/Python-%E6%B8%B8%E6%88%8F%E8%84%9A%E6%9C%AC/","tags":[["game-script","/tags/game-script/"]],"categories":[["Python","/categories/Python/"]],"content":"基于 opencv、pillow、pywin 来捕获图像并模拟按键操作 星露谷物语钓鱼脚本设计工作流程：（确保预先调整好钓鱼位置并切换到钓竿） 获取窗体并正常显示后置于最前 执行单次钓鱼流程 模拟鼠标左击并等到蓄力满时模拟释放左键 等待画面，人物头顶出现感叹号时模拟左击，鱼上钩 追踪钓鱼条直到完成捕获 循环执行钓鱼流程，等待终止命令 细节完成模拟蓄力目前使用 time.sleep(1.03) 来完成了，实际中偶尔出现卡顿而发生偏差。但不蓄满力不影响钓上鱼，暂且先不管了 捕获感叹号：目前截取屏幕中央的矩形区域，采样后发现叹号出现约 0.6+ 秒，考虑刚出现叹号的帧，用较小区域内的像素变化来捕获 当场景背景深色时前后截图的差较小，场景背景亮色时前后截图的差较大，暂且凭感觉根据负相关性给出一个阈值了 TODOs： 部分钓鱼点由于处在游戏区域边缘，人物模型不在屏幕中央，改进矩形捕获位置 —— 可以试试轮廓检测能否捕获到人物位置所在矩形，然后以此确定叹号位置 捕获鱼条位置： 由于鱼条的绿色不纯正，还经常变成浅色，与背景框混淆，目前采用通道 g - r 同时将鱼条和鱼都捕获，然后根据尺寸区分 鱼块比较容易确定，定位后比较位置来判断执行左键按下或抬起 死亡细胞自动格挡脚本"},{"title":"Cpp环境配置及编译流程","date":"2022-06-04T13:03:07.000Z","url":"/2022/06/04/C++/Cpp%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/","tags":[["cpp","/tags/cpp/"],["pre-tasks","/tags/pre-tasks/"]],"categories":[["Cpp","/categories/Cpp/"]],"content":"虽然个人目前未接触过很多 c++ 工程，不懂多少编译手段，但是先在此记录能起步使用程度的知识，并祈祷今后会不断增加 Windows 环境 编辑器随意选择，使用习惯的即可，或者 VSCode 比较优秀 编译器通常使用 mingw 完成单文件编译，配合 cmake 完成多文件编译，具体安装教程很多 编辑环境配置及三方库安装 一般安装第三方库时先使用 MSYS 的命令检索 pacman -Ss keywords 找到之后根据操作系统对应的编译器来选择安装，Windows 下为 mingw64，在其子环境下安装 cmake 使用 pacman -S mingw-w64-x86_64-cmake 补充 ：使用 msys 安装的外部库在 VSC 中不能立刻看到代码提示，此时需要 ctrl+shift+p 搜索 “edit configuration” 编辑 C/C++ 的配置，在其 includePath 条目下追加上 **/msys64/mingw64/include 具体目录视自身情况修改，大致是这个位置 g++ 编译mingw64 内置 g++ / gcc 等，通常编译 c++ 程序使用 g++ 即可；其中 -g 参数会后续生成调试信息，进行调试前需要编辑 launch.json 和 tasks.json，若无调试需求可以不加这个参数 编译单文件，生成带调试信息的可执行文件、并调试 编译多文件，生成带调试信息的可执行文件、并调试；（不推荐，需要把所有文件都加入） cmake 编译ctrl + shift + P 输入 cmake 来指定 GCC 编译器，可以基于工作区文件生成 CMakeLists.txt（或者自行先编写好） 编写 CMakeLists.txt 写入必要信息 工程项目下执行指令将完成 cmake 编译 cmakelists 文件编写参考文档 通常子目录都可以编写 cmakelists 生成一个 lib 然后在父目录内添加 一般的例子： 调试工作的配置调试工作是由 VSCode 读取调试信息和调试配置完成的，其中调试信息由编译器在编译中处理并储存，我们则需要需改调试配置 VSCode 上可以直接找到调试栏 “创建 launch.json 文件” 来快捷完成 关键点要将 “program” 属性定位到编译完成的 *.exe 文件 tasks.json 用于指定在 debug 前的 build 工作，如果子集完成编译和调试信息则无需该文件 Visual Studio 的项目配置以 SDL2 为例，参考博客 修改工程的 VC++-&gt;包含目录和库目录； 修改 链接器-&gt;输入-&gt;附加依赖项-&gt;追加 .lib "},{"title":"Games101-计算机图形学（六）","date":"2022-06-04T02:50:20.000Z","url":"/2022/06/04/Games/101%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E5%85%AD%EF%BC%89/","tags":[["games","/tags/games/"],["计算机图形学","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"]],"categories":[["Games-Graphics","/categories/Games-Graphics/"]],"content":"博客图片及学习路径来源 Gamse 101课程，在此记录以方便个人查阅为主，强烈建议自行观看学习 Animation / Simulation历史；关键帧动画；物理仿真；运动学 Kinematics；Rigging fps ：frames per second；通常电影 24 就足够，一般的视频 30；往上游戏、虚拟现实等要求才高起来 关键帧动画 Keyframe Animation：连续动作的“转折点”，关键帧之间的内容可以使用插值填充过程，当然不是简单的线性插值 为了符合平滑的运动，至少要加上 连续性、样条 等约束 物理仿真 Physical Simulation ：即通过模拟力在每个点上的作用和碰撞检测来仿真现实物理效果 质点弹簧系统 Mass Spring System ：见下段落 有限元分析 Finite Element Method (FEM) ：可以代替弹簧系统实现模拟 粒子系统 Particle Systems ：用众多粒子建模并模拟粒子受到的力和粒子间的相互力；也算物理仿真的一部分，要考虑的力有： 关联力：引力、斥力、电磁力、弹性力等；Damping 力：摩擦力、空气阻力等；碰撞作用力：与场景或其他粒子 Rigging ：相当于在网格模型上设立关键的操控点，以及执行相应控制后对其它部位的影响和约束；例如完成提线木偶的控制、人物表情的变化、细微动作的实现 动作捕捉 Motion Capture ：基于前者的逆向想法，真人携带控制点来执行动作，反馈给虚拟模型完成模拟；现有更广泛使用的方法还是 光学动作捕捉 运动学 Kinematics类比一个基础的骨架结构，运动学模型需要进行几个基本定义： 拓扑结构 ；即各个组件（组件有长度并附带关节）之间的连接关系 关节处的几何关系 ：例如三维中用两个角度描述，其坐标系基于关节的父组件 树状结构 ：组件之间的层级构成树结构，避免成环 正向运动学 Forward Kinematics ：即通过每个关节的运动情况描述整体模型的运动 优点 ：关节的描述很容易，且计算渐变 缺点 ：使用数值输入而非视觉确定，不方便设计 逆向运动学 Inverse Kinematics ：可理解为主观控制组件的端点位置，求解各个组件的适当位置 存在多解或误解情况，无直接求解方法，采用优化方法来调整 其他补充质点弹簧系统 单个弹簧 考虑一个简单的 a,b 端点弹簧，具有自然长度 l 称为 rest length，其拉伸作用力 f_{a\\rightarrow b} = k_s\\frac{b-a}{||b-a||}(||b-a||-l)然而弹簧显然是不会“永动”的，因此要引入能量损耗，也即摩擦力 其中 $\\dot{b}$ 表示 位置 b 点的导数，也即 b 端点的速度 弹簧网格 仅完成单个弹簧的力显然不足以模拟物理效果，甚至连一块平面布都模拟不了： 考虑屏幕上的方形弹簧网格，则其无法抵抗对角线上同时向外的切边力，也无法模拟沿对角线翻折的旋转力 —— 每个小方格都连接两个对角线 到上一步仍无法沿模拟水平、竖直方向的翻折，在此基础上增加横竖方向上端点的单步跳跃连接 “skip connection” —— 至此的弹簧系统能不错地模拟布匹的效果了 动画生产流程 但是实时渲染太牛啦，直接统括了很多流程 求解方法粒子运动的求解先考虑单个粒子在一个速度场内的运动，速度场可以由 v(x, t) 表述，因此建立了一个常微分方程 Ordinary Differential Equation \\frac{dx}{dt}=\\dot{x}=v(x, t) 欧拉方法 Euler Method ：引入一个很小的 Δt 的微分来计算下一时刻的位置，有不稳定等诸多问题，且对很多场景没有正确的解 中点法 Midpoint Method ：基于欧拉法略微优化，实践有更好的效果 在 Δt 下计算出单步的下一个点 a ，取到 a 的中点 b 以速度场在中点的速度作为当前点速度计算 Δt 后的位置 公式 $x(t+\\Delta t=x(t)+\\Delta t \\cdot v(x_{mid}, t$ Adaptive Step Size 自适应步长 ：比较当前步长 Δt 下欧拉法结果和执行两次 Δt/2 的欧拉法结果的差异，若足够小就采用中点法，否则步长折半 隐式欧拉法 Implicit Euler Method ：见下段落 龙格库塔法 Runge-Kutta Methods ：使用典型的四阶方法求解 欧拉法会能量自增，隐式欧拉法会能量衰减；综合后有半隐式欧拉 隐式欧拉法相比于显式欧拉法用 t 时刻的微分推导 t+Δt 时刻，隐式欧拉法采用向后差商 \\dot{x}(t+\\Delta t) = \\frac{x(t+\\Delta t) - x(t)}{\\Delta t}代入微分方程导数项得到 x(t+\\Delta t) = x(t) + \\Delta t v(x(t + \\Delta t), t + \\Delta t)然后解方程得到下一步结果 隐式欧拉法还有一个改进方法，其使用近似的积分形式来建立下一时刻的值方程 龙格库塔法同样已知初值 $\\dot{x} = v(x, t), \\space x(t_0)=x_0$ 经典四阶方法 RK4 由如下方程给出 x_{t+dt} = x_t + \\frac{dt}{6}(k_1 + 2k_2 +2k_3 +k_4)描述了下一步的值由当前值、间隔 dt 和一个估算的斜率确定；其中 $k_1 = v(x_t, t)$ 是片段起始的斜率 $k_2=v(x_t+\\frac{dt}{2}k_1, t+\\frac{dt}{2})$ 是片段中点的斜率，通过欧拉法采用 k1 来确定 $k_3=v(x_t+\\frac{dt}{2}k_2, t+\\frac{dt}{2})$ 也是中点斜率，但是通过欧拉法采用 k2 来确定 $k_4=v(x_t+dt \\dot k_3, t + dt)$ 是片段终点的斜率，用 k3 确定 该方法是四阶的，单步误差 O(dt^2) ，总误差 O(dt) Position-Based / Verlet Integration ：给出一些约束来限制属性，会直接违背物理系统，但是用于保持稳定 刚体模拟 Rigid Body Simulation刚体即视为内部点相对位置绝对不变的 “大粒子”，相对于粒子运动，其多考虑两个维度，即朝向角和角速度（旋转相关） 流体模拟 Fluid Simulation 核心想法： 假定流体是由很多刚体小球构成的 假定流体在任何位置都是不可压缩的 此时为了模拟流体的运动，即引入 Verlet Integration，通过给出密度的约束，检测空间各位置上小球的密度，总是执行运动使其保持常数水平 代码实现作业框架没搞定，实现几个弹簧作用力很简单，有机会再补充"},{"title":"Games101-计算机图形学（五）","date":"2022-06-02T11:42:48.000Z","url":"/2022/06/02/Games/101%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E4%BA%94%EF%BC%89/","tags":[["games","/tags/games/"],["计算机图形学","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"]],"categories":[["Games-Graphics","/categories/Games-Graphics/"]],"content":"博客图片及学习路径来源 Gamse 101课程，在此记录以方便个人查阅为主，强烈建议自行观看学习 Materials and Apperances 材质与外观对于一个材质，到现在已经接触过的与其关联的属性有 渲染方程中的 BRDF，即已知 “入射、出射、法向” 的条件下计算出反射量的系数（镜面反射略，仅需考虑角度计算和吸收率即可实现）； 考虑完全的漫反射，则对任一角度的入射光线，其都会向半球面均匀地反射，反过来即是说，对任一出射角度，其输出都是由半球面上的入射光线均匀地反射贡献的；将 f_r 视作常数提出积分式 考虑能量守恒，出射的总 irradiance 不会大于入射的，仅在完全反射（如白色表面）时相等；因此变换积分式如下 结论即 f_r 在 [0, 1/Π] 中取值 材质表面发生的光线折射，需要定义出入介质的折射率 η，$\\eta_i sin\\theta_i=\\eta_t sin\\theta_t$，使用时通常计算 $cos\\theta_t$，存在一些情况下无解，即全反射情形 菲涅尔项 Fresnel Term ：描述不同的入射角度下不同材质对光线的反射水平，已经有完整的计算公式，以及 Schlick 近似 微表面理论 Microfacet Theory认为根据视角远近观察一个表面有不同的效果： 远处观察：表面可视作一个平面，具有粗糙不均匀的材质；表面的每个微元上进行完全的镜面反射 近处观察：可以看到表面上完整的几何形状，即构成曲面 微表面理论将凹凸不平的表面近似成平面，该平面的法向视作所有凹凸镜面的法向的综合，即在一定范围内变动（变动范围视具体表面的凹凸水平），在此基础上构建材质的 BRDF，其中中间项 G 描述了凹凸块互相遮挡的情况，在入射光较水平时作用显著 各向异性 BRDF回顾空间中的极坐标表示，其有两个角度 φ 和 θ 分别表示与 x 正向和 y 正向的夹角； 当一个材质的 BRDF 随 φ 的变化而不同时，称为各向异性 —— 现实例子有各种金属表面形成辐射状的高光 在渲染实现上： 各向同性通常构成有聚散的高光 各向异性通常构成条状分布的高光 BRDF 的性质 非负性 线性性：可随材质线性组合？ 可逆性：入射和出射方向对换时保持值不变 能量守恒：文首给出的取值范围 测量 BRDF使用固定光入射，从不同角度观察采集，然后通过角度关系来生成所有角度下的值情况； 现有可调库使用 Advanced Topics in Rendering介绍为主 Advanced Light Transport无偏的光线传播方法 双向路径追踪 Bidirectional Path Tracing (BDPT) ：思想即从光源和相机都打出 ray ，相连时渲染成像 已经是非常牛的算法了，只要能够实现，就足以自制渲染器 Metropolis Light Transport (MLT) ：已知一条正确光路后使用随机扰动来生成其他光路；在困难的渲染任务中效果尤佳 有偏的方法 Photon Mapping ：能很好地实现 caustics 效果，做法大致是从光源发射光子，正确地经过折射和镜面反射，直到漫反射表面上，然后在该表面上进行密度估计来着色 密度估计：现有做法是固定一个光子数 N ，在着色点周围找面积 A 内含该数量的光子，以此估计密度，结果是有偏的，但一致的；若固定面积记光子数，则结果不是一致的 Vertex Connection and Merging (VCM) ：结合 BDPT 和 Photon Mapping 的方法，即双向路径中部分没有连接上但是落到相近位置的子路径，将其视作光子来密度估计，最终完成着色 实时辐射度算法 Instant Radiosity整体思路是将直接光源照射到的点视作虚拟的光源 Virtual Point Light ，后续有很多研究 Advanced Appearance ModelingNon-surface Models Participating media ：散射介质 光线在介质传播过程中，被吸收或者散射，其中吸收部分使用系数即可 散射部分在介质内进行多次得到一条路径上多个着色点，然后都与光源连接并综合即得到单条路径在屏幕上的成像 例子如 烟雾效果，浓烟即吸收的多，散射的少；大多数物体都能作为散射介质，如各种流体 Hair / fur / fiber (BCSDF) ：非常遗憾的，这几种材质的光作用效果并不完全相同 头发通常视作玻璃柱体，接收到光线 部分反射，部分折射进入内壁再反射出来 … Marschner model 现有的已经取得很好头发渲染效果的模型，贴合现实 动物毛发相比人类头发有更大的髓质，因此相当于双层玻璃管，针对此构建了 Double Cylinder Model，反过来也能用到头发上；模型中带 s 表示穿过髓质发生散射的部分 Granular material ：粒状堆积的材料 Surface Models Translucent material (BSSRDF) 如玉石等接近半透明的材质，光线从某个点进入材质，在内部发生大量散射，最终离开材质 —— 称为 次表面散射 BSSRDF Dipole Approximation，实际上没搞定这种效果，用材质表面的内外两个点光源近似实现的观察效果 Cloth 由一系列缠绕形成的 Fibers -&gt; Plys -&gt; Yarn -&gt; Cloth ；暴力的将某个层级的单位视作玻璃主题进行渲染，使用越原始层级则越复杂 Detailed material (non-statistical BRDF) ：即微表面上的凹凸效果渲染，神了 Wave Optics 波动光学，更细微到将光线细分到波 … Procedural Appearance使用噪声来对空间中任意的坐标点定义纹理，完成视觉效果 Cameras, Lenses and Light Fields相机、透镜和光场 摄像机原理之前介绍的图形学上成像方法都是合成方法，光栅化和光线追踪都是将虚拟的由 坐标、关系、属性 定义的空间物体经过物理模拟算法变换到成像平面上的结果 这里大致介绍一下现实中的摄像机原理，以助理解 Field of View相比于光栅化中提及的，摄像机的外物和成像平面在透镜两侧，先穿过透镜完成倒立的画面 Exposure 曝光Exposure = time × irradiance 相机上有 快门 等来从时间上控制曝光量 透镜和焦点高中物理知识；平行光过焦点、过焦点光会平行 Light Field / Lumigraph在一个三维极坐标系下记录每一个角度 (θ, φ) 下看到的光即得到个体的视觉世界，在此基础上增加时间维度形成动画，后续也可以追加其他可视点作为视角位置进行拓展，由此构成了 全光函数 ：$P(\\theta, \\phi, V_x, V_y, V_z)$ 光场 ：描述了在任意一个位置向任意一个方向的光强度，是全光函数的一部分；光场即一个四维函数，方便表述观察某个点的光效果 对于这个四维函数，可以由两个前后平行平面上的两个点确定，因此也可以理解客观世界在平面 2 后方，观测者在平面 1 前方，透过 1 观察 2 的效果 昆虫复眼的成像原理就像光场一样，每一个复眼的单位视作平面 2 和 1 的组合，将观察外部得到的光线方向记录下来 Color and Perception Spectrum 光谱：是复色光经过色散系统（如棱镜、光栅）分光后，被色散开的单色光按波长（或频率）大小而依次排列的图案，全称为光学频谱 Spectral Power Distribution 谱功率密度 (SPD) ：描述光在单位波长的分布情况，具有线性叠加的性质 颜色源自于人的感知，而非光的一般性质： 光线的光谱进入人眼到达视网膜 光谱视作与波长有关的函数 视网膜上三种细胞感受到光谱 每种细胞对光谱的接受度不一样，同样是与波长有关的函数，根据其分布分为 S、M、L 分别对 短、中、长 波长强接受 三种细胞综合处理将结果传给大脑 （处理可以理解为积分运算） Metamerism 同色异谱使用不同的光谱调配出相同的颜色结果 认为地定义三个分布函数去模拟上述地 S、M、L 细胞的组合，可以自行构建颜色空间 颜色空间加色系统 HSV (Hue-Saturation-Value) ：色调、饱和度、值 的三维组合 CIELAB 空间：使用 亮度加上两队互补色 减色系统 CMYK "},{"title":"Games101-计算机图形学（四）","date":"2022-05-31T05:52:31.000Z","url":"/2022/05/31/Games/101%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E5%9B%9B%EF%BC%89/","tags":[["games","/tags/games/"],["计算机图形学","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"]],"categories":[["Games-Graphics","/categories/Games-Graphics/"]],"content":"博客图片及学习路径来源 Gamse 101课程，在此记录以方便个人查阅为主，强烈建议自行观看学习 光线追踪是类比光栅化的另一种成像方式，主要为了解决光栅化的问题：软阴影、光线的多次反射效果；其实现效果比光栅化更佳，但相应的效率更低 在图形学中几个关于光线的假设（非现实物理）： 光线仅直线运动 光线交叉时不会互相影响 光线从光源处运动到视野点（光路可逆） 回顾光栅化模型中的阴影生成方法 —— 由点光源确定可见点的深度，然后对相机可见点逆投射去检查是否有阴影 —— 光线追踪则从视野点穿过成像平面得到可见点，然后去检查该点对光源的可见性，以此来确定着色 Whitted-Style Ray Tracing一个现代使用的递归式光线追踪方法，视线穿过物体时若可以折射则执行之，最终将所有同一条视线的可见点的着色效果累加得到成像平面上的像素点效果 在此模型下有几个关键的技术问题要解决 光线与物体的交点数学上认为光线是一条射线，从光源处出发，因此其表达式写为 \\mathbf{r} (t)=\\mathbf{o} + t\\mathbf{d} , \\space 0 \\leq t \\lt \\infty考虑光线与不同的物体交点的计算： 球面：即到达某个点 c 的距离为 R，将光线上点的表达式代入即可得到方程来求解 t；根据解的个数判断光线与球的相交模式 \\mathbf{d} \\cdot \\mathbf{d} *t^2 + 2(\\mathbf{o}-\\mathbf{c})\\cdot \\mathbf{d}*t + (\\mathbf{o}-\\mathbf{c})\\cdot(\\mathbf{o}-\\mathbf{c})-\\mathbf{R}^2=0 一般性的隐式表面都可以通过表达式求解来得到交点的 t 显式表面，转为判断光线和三角形求交，进而先转为光线对平面求交，然后判断是否在三角形内，而一个显式平面可以由一个法向量 N 和平面上任意一个点 p’ 确定，最终相应的表达式及求解的方程为 \\begin{align} \\mathbf{p}:(\\mathbf{p}-\\mathbf{p}')\\cdot\\mathbf{N}=0 \\\\ (\\mathbf{o}+t\\mathbf{d}-\\mathbf{p}') \\cdot\\mathbf{N}=0 \\end{align} Moller-Trumbore 算法 ：而针对三角形求交还有一个更快的方法，借助重心坐标表示来求出重心坐标的三个系数，只要三个系数均为正则交点在三角形内 然而实际操作中，模型表面有巨量的三角形，更何况场景中有很多物体，且成像平面也有众多像素点，若逐一运算判断交点效率太低，因此需要加速方法 Acceleration Ray-Surface Intersection考虑一个三角形的包围盒，通常取用轴对齐的长方体来包围，当光线不与长方体相交时，显然不会与三角形相交 轴对齐包围盒 ：Axis-Aligned Bounding Box 即每个边都和一个轴共线构成的长方体包围盒 为了判断光线是否进入包围盒，先将包围盒视为三组对立平行平面，则每一组平面都可以很容易计算出进入和离开的 t （直觉上可以看作时间），当最大的进入时间小于最小的离开时间即可知光线进入包围盒，当离开时间有负值则不可能进入包围盒 空间划分既然使用 AABB 能很方便地判断光线是否进入，那很自然地会想到用更多的包围盒来跟随一条光线，只需要处理光线经过的包围盒，判断其内部是否有光物相交；基于此想法先产生了对空间均等划分的思想，为了平衡效率在三维上经验性地取 物体数\\*27 的均等划分 KD-Tree ：均等化分又有一个问题，即比较多的包围盒与物体完全不相交，因此后续引入了 KD-树 来划分（三维即三个轴平面轮流循环划分） 完成划分后，一条光线即沿着树的根节点开始搜索，只要在某个节点处判断光线进入包围盒，就需要检查该节点的子节点，直到到达叶子节点 注意：由于 KD-Tree 仍有较多问题，如一个物体可能出现在多个节点处、建树方法并不容易等，因此现代已基本不再使用其来划分 Bounding Volume Hierarchy (BVH) 层级式地分割物体为两组创建新一级的包围盒 全部物体划分进一个包围盒，相当于根节点 递归地将物体集分割成两个子集 重新计算创建子集的包围盒（可以有重叠） 必要时停止，通常是每个子集包含的物体个数小于阈值时 将所有物体储存在树结构的叶子节点 启发式的分割算法：总是选择最长的轴来进行分割；每次分割尽可能等分 Surface Area Heuristic (SAH) 一个同样非常不错的提升效率算法，自行搜索补充 辐射度量学 Basic Radiometry相当于为光照建立了一个完整的度量体系和单位，有以下几个新增术语 Radiant flux，intensity，irradiance，radiance 并给出一个物理上合理的计算逻辑 度量概念 Radiant Energy and Flux ：辐射的能量以 焦耳 Joule 为单位，flux 可以理解为通量或功率，表示单位时间内产生、反射、传输或接收的能量，其度量和单位如下 ‘瓦特或流明 luminous’ \\Phi \\equiv \\frac{dQ}{dt}\\space[W=Watt][lm=lumen]^* Intensity ：衡量单位立体角范围内发散出的功率，由于空间中光源向所有方向都均匀发射，规定了一个立体角 solid angle 作为角度单位，公式如下 I(\\omega )\\equiv \\frac{d\\Phi}{d\\omega} \\space[\\frac{W}{sr}][\\frac{lm}{sr}=cd=candela] 立体角类比二维中弧度的确定，其定义式表达式为 $\\Omega=\\frac{A}{r^2}$ ，即球面上的区域面积除以半径的平方；一个完全发散的立体角大小为 4π steradians 考虑球面坐标系，使用两个角度 θ 和 φ 分别表示和 y 轴正向及 z 轴正向的夹角，由此计算出单位立体角 $d\\omega=sin\\theta \\space d\\theta \\space d\\phi$ Intensity 最终即为总功率 Φ 除以 4π Irradiance ：衡量光落到单位面积的表面上的功率，其中功率的具体大小根据方向需要转换成与表面垂直的分量（回顾 Lambert’s cosine law），面积取平方米为单位，得到公式如下 E(\\mathbf{x})\\equiv \\frac{d\\Phi(\\mathbf{x})}{dA}\\space [\\frac{W}{m^2}][\\frac{lm}{m^2}=lux] 回顾着色模型，实际上随距离衰减的是单位面积的 irradiance Radiance ：衡量光沿着一条射线运动的强度；the power emitted … by a surface, per unit solid angle, per projected unit area；大致理解为通过单位面积表面的光线向单位立体角放出的功率 理解上可以参考下图，即将 Radiance 理解为 Irradiance 在半球体上各个单位立体角上的分解；或者反之理解为积分 双向反射分布函数Bidirectional Reflectance Distribution Function；规定了从某个方向 $\\omega_i$ 入射的 radiance 经过物体表面反射到某个方向 $\\omega_r$ 得到的 radiance 的运算函数，相当于描述了一个材质用于实现着色效果 f_r(\\omega_i \\rightarrow \\omega_r) = \\frac{dL_r(\\omega_r)}{dE_i(\\omega_i)}=\\frac{dL_r(\\omega_r)}{L_i(\\omega_i)cos\\theta_i d\\omega_i} \\space [\\frac{1}{sr}]将所有半球方向的入射光线经过 BRDF 反射到摄像机方向即得到总体反射的效果 在此基础上，再考虑环境中其他物体反射到该点的光就会更复杂 渲染方程 The Rendering Equation在反射的基础上加上物体自身可能辐射的值得到渲染方程，式中的 p 表示着色点（其中为了计算方便几个出入向量 ω 都取向外）： L_o(p, \\omega_o)=L_e(p,\\omega_o)+\\int_{\\Omega^+} L_i(p,\\omega_i)f_r(p,\\omega_i,\\omega_o)(n\\cdot \\omega_i)d\\omega_i当递归地考虑所有物体表面的反射时，将上方等式的积分部分近似地写成算子形式，经过数学上移项以及后续的展开得到全局光照的表达式 表达式将光照的视觉效果按照光线的反射次数分成了无穷项，当考虑所有项时即为全局光照效果，仅直接光照和单次弹射即为光栅化的原理 蒙特卡洛积分 Monte Carlo Integral实现渲染方程的展开和求解的方法 首先简单介绍蒙特卡洛积分： 对于一个要求积分的函数 f(x) 及片段 [a, b] 引入积分域上的独立同分布随机变量 $X_i \\sim p(x)$ 近似的蒙特卡洛估计 $\\int f(x)dx = FN = \\frac{1}{N}\\sum^N{i=1}\\frac{f(X_i)}{p(X_i)}$ 路径追踪 Path Tracing回顾 Whitted-Style 光线追踪，其没有实现光线在多个表面的重复漫反射效果，很多实现结果不符合现实，而渲染方程则能符合实际物理，其求解有两个关键点：1. 在半球面上积分；2. 递归地执行；为此借助蒙特卡洛积分方法 考虑 “反射等式” 部分，其为半球面上的积分，引入蒙特卡洛积分方法，选取半球面上的均匀分布 $F(\\omega_i)=\\frac{1}{2\\pi}$，则将积分式转为求和式 上述伪代码会轻易地因 N 次采样而指数爆炸，因此取 N=1 并在条件判断后直接 return 相应计算结果；仅执行一次采样即变成了对单条光线的路径追踪 上述伪代码的递归仍然有两个问题：1. 单次采样方差较大；2. 递归没有重点； 各自的解决方法如下 像素点上采样：然而对积分的单次采样计算显然是不太理想的，会产生较大的方差；因此多次采样的工作转到像素点上 —— 因为最终在像素点上成像，我们在像素点上采样 N 个点并以相机到样本点的路径追踪光线，将追踪结果综合起来得到该像素点的成像结果 引入生存概率：引入一个伯努利分布服从参数 P_RR，在每一步递归中，都从 [0, 1] 中取随机数 ksi，若该值大于 P_RR 则认为光线“消亡”而终止递归，否则将原本的返回值除以 P_RR，此方法具体的返回值期望为 $E(Lo) = P \\times Lo / P + (1 - P) \\times 0.0 = Lo$ 与原值无差异 至此得到了正确的路径追踪算法 Sampling the Light 效率提升上述路径追踪的实现效果受到单个像素点的采样量（samples per pixel）影响，因为每个像素点上的采样对应的 ray 到达着色点时，仅执行后续一次采样，这个单次采样不容易指向光源，造成其着色效果不佳；下述的方法主要针对 shade 部分 在 PT 中通常考虑面光源（点光源始终是难点，课程推荐是视作非常小的面光源），当考虑着色时的直接光照，原先的方法是在半球面上采样立体角，问题即不容易指向光源；更有效的方法是采样光源上的面积，转换成立体角的微分即可代入原本的计算式 观察上面的积分公式中的积分变换，显然 A 仅针对光源面，对其积分表示了直接光照的部分，因此还需要考虑非光源物体的反射光；最终实现的时候再追加一步，在计算直接光照时判断是否有其他物体遮挡，完成总的代码流程 Further LearningPath Tracing 是当前工业界实际使用的且已经证实过其重现真实感的方法，只要能正确实现就已经能取得相当好的效果；而凡是上面提到的采样积分，都可以引入 重要性采样 来取得更好的效果 学术界上还有更深入的研究 The general solution of light transport, including Unidirectional &amp; bidirectional path tracing Photon mapping Metropolis light transport VCM / UPBP… 代码实现回顾整体流程，可以独立实现的部分有： 空间划分 + 射线与面相交判断 物体表面着色 + 像素点采样成像 射线与 AABB 相交判断分三个轴向计算进入和离开时间，根据逻辑判断即可 递归的路径追踪函数 作业中犯的错误 借用算法判断射线是否相交三角形时，叉乘写成了点乘 BVH 到有相交的叶子节点忘记写 return "},{"title":"Games101-计算机图形学（三）","date":"2022-05-29T04:24:06.000Z","url":"/2022/05/29/Games/101%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E4%B8%89%EF%BC%89/","tags":[["games","/tags/games/"],["计算机图形学","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"]],"categories":[["Games-Graphics","/categories/Games-Graphics/"]],"content":"博客图片及学习路径来源 Gamse 101课程，在此记录以方便个人查阅为主，强烈建议自行观看学习 Geometry 几何包括各种几何形体（曲线、曲面等）的实现以及存储、渲染问题（远视图的简化存储）；课程概括了两种几何形体 Implicit 可以由满足指定关系的点所表述的几何，简单如平面、球面等，能很容易判断一个点是否在表面上 algebraic surface level sets 水平集，给出空间网格（或方格）及格内的值，使用双线性插值求出类似等高线的结果 $(x^2+\\frac{9y^2}{4}+z^2-1)^3=x^2z^3+\\frac{9y^2z^3}{80}$ Constructive Solid Geometry 由基础几何执行交并差等运算 Blending Distance Function 给出空间中点到几何体的距离函数（内部为负）确定几何体；可以用于模拟补完运动的中间效果 Fractals 分形 Explicit 直接给出所有的点或者给出参数映射关系（2D -&gt; 3D），较难判断点相对面的位置 point cloud polygon mesh 存储顶点、多边形的信息，有例如 Wavefront Object File 存储格式得到 .obj 文件，实际上是存储了 顶点、法线、坐标和连接关系等 subdivision，NURBS … 曲线和曲面 Curves and Surfaces贝塞尔曲线必定经过首尾两点，由中间的控制点来调整弯曲程度；de Casteljau 算法用于在确定空间中不少于三个点（含首尾）点时绘制曲线 算法原理：已知一列点 $b_0, b_1, … ,b_n$ 包含首尾点，则有 n 个线段，假设最终曲线上的点由 [0, 1] 的比例 t 表示，对每个线段都找到其 t 分位点，以此作为递归后的一组点，类似归纳法得到最终单个点为曲线上的 t 分位点；例如下 相当于不断进行线性插值，由此可以写出公式 \\begin{align} b^n(t)=\\sum^n_{j=0}b_jB^n_j(t), \\\\ B^n_i(t)=\\mathsf{C}^i_n t^i(1-t)^{n-i} \\end{align}优良性质：贝塞尔曲线对仿射变换保持不变，即先变换控制点再绘制和直接变换曲线上的点结果一致（投影不保持） Piecewise 贝塞尔曲线：当控制点增多时，每个点对曲线的控制程度会很弱，因此通常以四个点为一组确定一个贝塞尔曲线，并尽可能保持组之间连接处的连续性 连续性：该点处的左右导数相等 —— 共线且等长 样条 Spline常用的如 B-Spline 和 NURBS，可以更方便地控制局部性质 贝塞尔曲面首先通过四个控制点确定一个贝塞尔曲线，同时每个点都有完整的运动轨迹，在轨迹上不断地确定曲线最终形成曲面 因此贝塞尔曲面上单个点需要两个 [0,1] 范围内的值 (u, v) 来确定 不妨用 u 表示轨迹的分位数，用 v 表示确定四个控制点后的曲线分位数 网格操作细分 Subdivision细分不仅是将原有平面分割，还需要考虑分割后产生一定程度的空间变化；三角形的分割很容易确定，因此主要考虑分割后的形变 Loop Subdivision ：针对三角形的细分，先将三角形的每个边等分得到三个新顶点，然后针对新顶点和旧顶点分别处理 新顶点：假设其所处边有两个旧顶点 A、B，共享该边的两个三角形各有另一个旧顶点 C、D，经过加权平均最终确定该新顶点坐标为 $\\frac{3}{8}(A+B)+\\frac{1}{8}(C+D)$ 旧顶点：定义一个度 n 描述以该点为顶点的三角形个数，然后所有相邻三角形的其他顶点等价地赋权 u ，当 n = 3 时 u = 3/16；否则 u = 3 / (8n)；更新旧顶点坐标 (1 - n*u) * origin_position + u * neighbour_position_sum Catmull-Clark Subdivision ：处理一般网格（以四边形为主），每一个面都取一个中心点，将该中心点与其边上的中点都相连进行细分；称相连边数不为 4 的顶点为奇异点，则此细分仅在第一次细分时增加奇异点；后续点的更新规则如下 简化 Simplification一个不错的方法 —— Edge Collapse —— 选择一个边将其简化成一个顶点 具体的操作是贪心的启发式算法，分为两个步骤考虑： 坍缩后的单个顶点位置：最小化二次度量误差（Quadric Error Distance），即在坍缩前的空间中任取一点，可以计算该点到所有原有平面的距离平方和，最小化该平方和来确定坍缩后的目标点 怎样选择边：基于前一步的计算，每一条边都能计算出最优坍缩下的二次度量误差，使用优先队列存储这些信息，选择最优的边执行坍缩，并动态更新会受到影响的边的信息 正规化 Regularization暂略，看书后补充"},{"title":"Games101-计算机图形学（二）","date":"2022-05-28T02:22:48.000Z","url":"/2022/05/28/Games/101%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E4%BA%8C%EF%BC%89/","tags":[["games","/tags/games/"],["计算机图形学","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"]],"categories":[["Games-Graphics","/categories/Games-Graphics/"]],"content":"博客图片及学习路径来源 Gamse 101课程，在此记录以方便个人查阅为主，强烈建议自行观看学习 Shading 着色游戏引擎中一个关键要素 —— 光源， 以及后续物体材质在光源下的观察效果，明暗变化等；在图形学中的着色可以概括为将一个由几何描述的场景呈现到二维屏幕上的过程 基本模型结构着色问题的一个基本问题结构即为： 已知一个物体位置并以其表面的点为观察对象 shading point，基于此点已知了光源位置从而确定光线方向，已知了相机位置从而确定了视线方向，点上有一个物体表面法向，最后还有材质相关的各种参数会影响着色效果（以下向量都取单位向量，为了表示方便，将光线方向取反修改为从 shading point 出发的向量） 漫反射着色 Diffuse Shading现实的物理表面大多数都发生漫反射，因此在图形学上也考虑模拟漫反射行为，此时表面点在视觉上的效果即需要考虑该点漫反射向视线向量的光强度，该强度可以分为几个部分考虑： 基于 Lambert’s cosine law ，一个单位大小的表面，其接收到的光线通量与 法向量 n 和光线向量 l 的夹角 有关 考虑光线的分散，假设某一时刻从点光源中发散出的总光能为 I，该光能会始终均匀分布在以光源为圆心的球形表面上，因此当球壳的半径增大时，分布在单位圆弧上的光能就会较少，考虑球壳表面积公式即可计算得到 $I / r^2$ 根据物体材质、颜色不同，反射的光能也不同，此项给出一个系数来计算（例如黑色将光线全吸收不反射，系数为 0），具体的系数视情况变化，可以分 rgb 通道各自给出计算 综上得到完整的计算公式 补充：漫反射光的观察强度与观察视线向量无关，因为漫反射从反射点出发向任意方向反射出相同强度的光线 镜面反射 Specular Term除开漫反射之外也有表面的镜反射，即入射角度和出射角度相等，在此角度上（或比较接近）的区域观察会形成高光效果；为了衡量这种高光效果的具体强度，引入 Blinn-Phong 模型 即借助（反向）入射 l 和出射 v 的中间向量 h 与法向量 n 的偏移程度来评估此反射接近镜面反射的程度 其中指数 p 在于作用到 $\\cos \\alpha$ 上将高光区域限定到较小范围 环境光照 Ambient Term在理解上应当与光源、视线等无关，因此图形学上近似的用常数代替 L = k_{a}I_{a}综合的 Blinn-Phong 反射模型将三种情况下的光照效果复合起来即得到 L = L_{a} + L_{d} + L_{s} = k_{a}I_{a} + k_{d}(I/r^2)\\max(0,n \\cdot l) + k_{s}(I/r^2)\\max(0, n \\cdot h)^p着色频率 Shading Frequencies也是一个效率和效果的取舍问题：着色整个三角形平面 Flat shading -&gt; 着色每个三角形顶点再插值填充 Gouraud shading -&gt; 着色每个像素点 Phong shading 其中平面的法线容易确定，后续顶点的法线由其所有相接平面的法线（根据面积加权）平均得到 图形管线 Graphics Pipeline描述了完整的图形生成的流程 Shadow Mapping 阴影映射模拟光源下的物体阴影效果，核心是使用光栅化的思想，大致分为两个步骤实现： 模拟一个光源视角来确定光源可以到达的点，在一个像素平面上记录所有可见点的深度； 对于实际相机观察到的点，重新映射到前一步的光源像素平面上，比较平面上记录的深度是否小于观察点实际深度，若（显著）小于说明被遮挡，应该看到阴影 一些难以解决的问题： 只能实现硬阴影 —— 点是否在阴影中；针对点光源执行的过程，视觉效果即仅能看到锐利的边缘；相对的软阴影采用有体积的球形光源，可以部分观察到来渐变地实现阴影 上方步骤一中的像素平面也有具体的精度问题，需要考虑效果和效率的平衡 trade-off 浮点数精度问题以及衍生的计算误差问题不可避免，因此实现效果上也存在瑕疵 纹理映射 Texture Mapping纹理可以大致地理解为不同位置具有不同的反射参数的 2D 图片，将这种图片映射到 3D 模型上来实现多样化的着色效果 为了实现纹理的效果，需要考虑两方面的难点： 将 2D 图形上的点映射到 3D 模型各个三角形平面的顶点上 基于三角形顶点的信息（颜色、材质、法向量等）插值填充平面 首先是插值方法，需要用到 重心坐标 Barycentric coordinates 三角形插值 Interpolation Across Triangles 重心坐标系：已知三角形三个顶点的坐标，给出归一系数 $\\alpha + \\beta + \\gamma = 1$，则顶点坐标在此系数下的线性组合一定在三角形所在平面上；更进一步地，若各系数非负，则线性组合一定在三角形内部（非外部）；三个系数相等时表示的点即为三角形的重心 实际插值时，即先根据空间坐标计算得到重心坐标系的表达式，然后采用其系数对各顶点的属性进行线性组合完成插值 注意：重心坐标表示法不具有投影不变性，因此要明确具体在哪个空间中求重心坐标进行插值 透视矫正插值在作业框架中执行光栅化时，具体传入了投影后的三角形用于确定需要着色的像素点，同时传入了已经完成变换但未透视投影的顶点坐标，用于处理插值得到三个系数，然后经过 透视矫正插值 转化为透视投影后的值 其中的推导过程略过，给出最终 z 轴向的插值运算 \\frac{1}{z_0} = \\alpha \\frac{1}{z_1} + \\beta \\frac{1}{z_2} + \\gamma \\frac{1}{z_3}而对于顶点具有的其他属性，下以 b 符号记来给出插值运算 \\frac{b_0}{z_0} = \\alpha \\frac{b_1}{z_1} + \\beta \\frac{b_2}{z_2} + \\gamma \\frac{b_3}{z_3}应用纹理 Applying Texture 其中 (x, y) 通常取像素中心点，即 .5 坐标；基于光栅化后屏幕上的坐标计算重心坐标，插值得到 (u, v)，然后在文理图上查询该 (u, v) 得到该样本点对应的纹理颜色 由于经过透视投影会产生近大远小的视觉效果，因此实际使用中有几个难以避免的问题：（为了区分纹理和屏幕，称纹理上的像素为 texel 纹素） 纹理相对于目标区域太小，像素太低，此时就会对纹理执行放大操作，造成一个 texel 内有多个像素，此时如果直接取最近的 texel 值回传则效果不佳，引入插值方法 双线性插值 Bilinear interpolation ：取相邻四个纹素点的值进行两次横向一次纵向的线性插值得到当前点的值 Bicubic（代补充） Texture Magnification —— 相对远处的目标，纹理图过大，像素太高，此时单个像素会覆盖多个 texel，产生的效果类似走样，采用反走样方法追加采样点去计算 texel 的平均值，增加大量运算但能优化效果，也有更好的方法（另起一小节） Texture Magnification Mipmap ：即 CV 中的图像金字塔，先对纹理进行处理来存储额外的信息，得到多个层，高层直接存储了多个 texel 的平均信息，而总的额外空间并不多 使用 Mipmap 时，原像素经过计算得到 0 层纹理上的点 P ，理想情况即找到目标层 D 来确保 P 对应该层上的点为单像素，取用该值即得到查询结果，而确定该层 D 的方法有 上方的 dx、dy 为像素点的差，du、dv 为纹素点的差 借助映射前后的距离差异来确定需要折半的次数，即目标层数 实际计算得到的层数 D 是一个浮点数，如果直接向上取整则结果不太连贯，因此可以继续引入插值形成 Trilinear Interpolation，对 D 相邻的层都进行插值得到结果，然后对结果参照 D 插值得到最终值 各向异性过滤 Anisotropic Filtering ：一定程度上弥补 Mipmap的不足，同样是对纹理进行预先处理存储，将纹理横纵向分别收缩，此时当像素点投射到收缩后的图上时，其还原结果即为矩形状，较符合远处的视觉效果 各向异性过滤对横纵向的压缩能有较好的效果 为了进一步弥补倾斜方向的压缩缺陷，后续也有 EWA filtering 方法，采用圆心来进行层级划分查询，只是开销更大 环境映射 Environmental Map将环境光信息记录在类似镜面球的表面上，其映射原理分为两种： Spherical EM ：直接经过几何运算记录到球体表面上，但在球的不同位置不均匀，球的极点处发生严重扭曲（因为球体是不可展平面） Cube Map ：将球体表面分割来得到正方体表面的映射，可以保证均匀分布，需要额外的计算来确定对应关系 特殊属性纹理一个纹理贴图不止可以存储颜色信息，也可以存储虚拟的高度信息，用于在每一个位置重新计算法向进行插值 Bump / Normal Mapping 凹凸/法线贴图 ：在一个确定的表面上定义不同位置的高度，在每一个点处可以通过近似的微分求导确定该点的法线，以此法线属性作为采样的值；不改变模型原始的形状，只是通过法线的着色效果产生凹凸不平的视觉效果；其中法线的计算是先建立局部的坐标系，然后通过 TBN 矩阵重新映射到世界坐标 Displacement Mapping 位移贴图 ：相比于凹凸贴图，位移贴图实际移动了每一个三角形顶点的位置，因此需要模型较为细致，包含许多三角形（具体多少不确定，因此有曲面细分方法，在使用中视具体效果分割曲面得到更精细的模型） 代码实例前注 ：矩阵的逐元乘法调用 cwiseProduct 插值计算三角形内点属性其中两个插值函数只是将三个向量按参数加权相加然后除以权重 weight 传入的 vp —— view_pos 为空间中的点在执行投射变换前一步的坐标组 Fragment Shader 着色模型其中 normal 为着色点的法向量，point 为着色点坐标，intensity 为光强度属性 "},{"title":"Games101-计算机图形学（一）","date":"2022-05-23T09:10:11.000Z","url":"/2022/05/23/Games/101%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/Games101-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%EF%BC%88%E4%B8%80%EF%BC%89/","tags":[["games","/tags/games/"],["计算机图形学","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"]],"categories":[["Games-Graphics","/categories/Games-Graphics/"]],"content":"Overview of Computer Graphics博客图片及学习路径来源 Gamse 101课程，在此记录以方便个人查阅为主，强烈建议自行观看学习 What is Computer Graphics？以下众多元素都有计算机图形学的支持 视频游戏：一大重点即为画面的全局亮度； 电影特效：描述为最简单的图形学应用（画鬼神易画犬马难）； 进阶有动作捕捉乃至面部表情捕捉 动画电影： 光影材质设计：用于实现各种材质对光影效果的反馈，完成如室内设计等工作 可视化工作：如人体模型等各类可视化 VR：虚拟现实技术 Simulation：仿真功能 Graphical User Interfaces：用户图形接口，即 GUI Course Topics Rasterizaion ：光栅化 —— 把三维空间的几何图形显示在屏幕上 Curves and Meshes ：曲线和网格的实现 —— 计算机中的几何 Ray Tracing ：光线追踪 —— 光影效果的实现 Animation / Simulation ：动画与仿真功能 线代 Linear Algebra基础概念不作赘述 向量内积（点乘）计算夹角余弦值：两个向量计算得到标量值$|\\vec{a} \\cdot \\vec{b}| = |\\vec{a}| |\\vec{b}|\\cos \\theta $ 向量叉积 （cross product）用于构建符合右手坐标系的向量 —— 向量到向量 \\vec{a} \\times \\vec{b}=A^{*} b=\\left(\\begin{array}{ccc} 0 & -z_{a} & y_{a} \\\\ z_{a} & 0 & -x_{a} \\\\ -y_{a} & x_{a} & 0 \\end{array}\\right)\\left(\\begin{array}{l} x_{b} \\\\ y_{b} \\\\ z_{b} \\end{array}\\right)=\\left(\\begin{array}{l} y_{a}z_{b} - y_{b}z_{a} \\\\ x_{b}z_{a} - x_{a}z_{b} \\\\ x_{a}y_{b} - x_{b}y_{a} \\end{array}\\right) 数量级关系：$|\\vec{a} \\times \\vec{b}| = |\\vec{a}| |\\vec{b}|\\sin \\theta $ 可用于判断一个点是否在三角形内侧 —— 每次取一条边向量，计算两个叉积再做内积判断目标点是否与第三点在边向量的同一侧 矩阵运算及矩阵左乘向量运算 变换 Transformation包括旋转、缩放、切变，都可以用一个变换矩阵左乘原向量得到 逆时针旋转 θ 角度 \\mathrm{R} _{\\theta} = \\left[\\begin{array}{c} \\cos \\theta & -\\sin \\theta \\\\ \\sin \\theta & \\cos \\theta \\end{array}\\right] 在线性变换基础上加上常数项向量完成平移，但为了保持线性变换的一致性，在原本的坐标上抽象一维常数维构成齐次坐标 例如原本的 向量 (vx, vy) -&gt; (vx, vy, 0) 其抽象维取 0 以确保向量和坐标间的运算性质 点 (x, y) -&gt; (x, y, w) 抽象维 w 通常配合 x、y 缩放至 1 此时在齐次坐标下的仿射变换可以拥有和线性变换一致的写法 逆变换在已知上方的变换矩阵时，左乘一个逆矩阵即可回归到原来的坐标 三维变换也参考二维向量上对齐次坐标的抽象，构建 (x, y, z, w) 表示点坐标以及 (x, y, z, 0) 表示向量 通常延坐标轴旋转的变换矩阵可以直接退化成二维平面的旋转来计算；考虑任意的旋转，实际上也是以一个三维向量为轴线进行一定角度的变换，现有计算公式如下（以向量 n 为轴逆时针旋转角度 α） Rodrigues’ Rotation Formula \\mathbf{R}(\\mathbf{n}, \\alpha)=\\cos (\\alpha) \\mathbf{I}+(1-\\cos (\\alpha)) \\mathbf{n} \\mathbf{n}^{T}+\\sin (\\alpha) \\underbrace{\\left(\\begin{array}{ccc} 0 & -n_{z} & n_{y} \\\\ n_{z} & 0 & -n_{x} \\\\ -n_{y} & n_{x} & 0 \\end{array}\\right)}_{\\mathbf{N}}视图变换 Viewport Transformation首先通过平移、缩放操作将空间中任意矩形变换到 [-1,1]^3 的正方体区域，然后通过 viewport 变换到屏幕上以像素单位来显示，当确定屏幕的 宽高值 $n_x$、$n_y$ 之后即可通过简单的先缩放后平移变换完成 \\left[\\begin{array}{c} x_{screen} \\\\ y_{screen} \\\\ 1 \\end{array}\\right] = \\left[\\begin{array}{c} \\frac{n_x}{2} & 0 & \\frac{n_x - 1}{2} \\\\ 0 & \\frac{n_y}{2} & \\frac{n_y - 1}{2} \\\\ 0 & 0 & 1 \\end{array}\\right] \\left[\\begin{array}{c} x_{canonical} \\\\ y_{canonical} \\\\ 1 \\end{array}\\right]（上面用 $n_x-1$ 是由于像素从 0 开始计数） 正交投影变换 Orthographic Porjection Transformation正交投影可以理解为在三维上舍弃掉一维，将较远平面的坐标投影到一个较近平面得到的视图，投影过程中不进行缩放变换 对空间任意一个长方体，都可以通过先平移再缩放的变换得到单位正方体，具体变换矩阵如下 相机变换 Camera Transformation由当前视角所处位置坐标 e 以及其视线向量的正向g 和上方朝向 t 来确定一个 View 习惯上总是通过变换将摄像视角置于三维空间原点，以 -Z 方向（符合右手系）为视角方向，Y 方向为正上方，因此以坐标 e 为原点重新构建右手系 (u, v, w) 容易计算得到 (u, v, w) 的向量表示 \\begin{align} & w = \\frac{g}{\\lVert g \\rVert}, \\\\ & u = \\frac{t \\times w}{\\lVert t \\times w \\rVert}, \\\\ & v = w \\times u. \\end{align}要计算将 (u, v, w) 系变换到坐标中心的变换矩阵，只需要考虑其逆变换的变换矩阵然后取逆即可 \\mathbf{M}_{\\mathrm{cam}}=\\left[\\begin{array}{llll} \\mathbf{u} & \\mathbf{v} & \\mathbf{w} & \\mathbf{e} \\\\ 0 & 0 & 0 & 1 \\end{array}\\right]^{-1}=\\left[\\begin{array}{cccc} x_{u} & y_{u} & z_{u} & 0 \\\\ x_{v} & y_{v} & z_{v} & 0 \\\\ x_{w} & y_{w} & z_{w} & 0 \\\\ 0 & 0 & 0 & 1 \\end{array}\\right]\\left[\\begin{array}{cccc} 1 & 0 & 0 & -x_{e} \\\\ 0 & 1 & 0 & -y_{e} \\\\ 0 & 0 & 1 & -z_{e} \\\\ 0 & 0 & 0 & 1 \\end{array}\\right]透视投影 Perspective Projection最常用的一种投影变换，需要确定两个与视线向量垂直的平面，将远平面的点投影到近平面上，由此可得相似性 在以上的投影操作下，我们可以确保近平面上的点经过变换不发生变化，而远平面上的点经过变换其 z 值不发生变化， 此时假定近平面到视角点的距离为 n ，远平面到视角点的距离为 f ，即容易计算出缩放的变换矩阵 \\mathbf{P}=\\left[\\begin{array}{cccc} n & 0 & 0 & 0 \\\\ 0 & n & 0 & 0 \\\\ 0 & 0 & n+f & -f n \\\\ 0 & 0 & 1 & 0 \\end{array}\\right]最终确定的透视变换矩阵即为 $M{per} = M{orth} \\mathbf{P}$ 即先通过矩阵 P 比例缩放变换然后执行正交投影得到透视变换 综上，完成一个完整的透视变换： 先执行视角变换将坐标系变换到视角系上 执行矩阵变换 P 将点都投射到近侧平面的视域范围内 执行正交投影变换完成透视 M = M_{vp}M_{orth}PM_{cam}视域确定 Field-of-View上述讨论都是在确定前后两个平面条件下的代数解，实际使用中我们的近侧平面通常是将要被投射到的屏幕，即仅能够投射到屏幕范围内的模型可见，该屏幕可以由三个参数确定： 屏幕尺寸 r / t，即 宽 / 高 视角到屏幕的距离 |n| 视角到屏幕上边界的仰角大小 θ / 2 最终的画面呈现即空间中的坐标投影到该视域上的结果 完整流程 世界空间 World Space ：用于理解的三维空间，放置模型、相机、光源等 局部空间 Local Space ：也称模型空间，规定好模型正向 x 和上方 y 轴以及模型中心点，以此可确定模型上各点坐标 模型变换 ：依次处理模型自身的 缩放、旋转、平移，变换矩阵在模型空间上描述，得到 M 任何的对模型自身的变换都只需要在这里以相应矩阵形式描述 视野变换 ：将摄像机置于世界坐标中心的变换，可以考虑先做世界坐标到相机上的变换再求逆 投影变换 ：通常先正交再挤压形成透视投影 光栅化 Rasterization光栅 Raster 即德语中的 screen；光栅化即为将物体绘制在屏幕上的过程，其中主要涉及到的计数难点有反走样和 Z-buffering（针对模型前后重叠的显示） 像素 pixel 为屏幕上的最小单位，通常将其视为网格图中的各个方格，最左下角的顶点为 (0,0) 坐标，而每个像素中心点的坐标都为 ‘.5’ 采样 Sampling在光栅化工作时，我们得到的输入通常以 三角形 区域来限定色彩（使用三角形能实现渐变等功能），而对于三角形包围的像素格，可以使用采样方法来判断其颜色 采样即判断像素中心是否处于三角形内部（循环叉积来判断）来确定该像素格的颜色，对边线上的自行规定即可 锯齿 Jaggies ：使用采样方法来确定像素格颜色不可避免地会出现锯齿，当分辨率较低时尤其明显；为此研究出了反走样（antialiasing）方法 其他采样带来的瑕疵（artifacts）还有如摩尔纹、Wagon wheel effect 等；本质上都是采样频率远远不及信号变化频率造成的 反走样 Antialiasing具体需要学习信号处理知识，总之在图像上可以采用几种成体系的方法： 下采样：先进行滤波（卷积操作）模糊化再执行采样 上采样：例如 MSAA，将单个像素细分后考察其位于三角形内的比例，以此比例作为原像素点的颜色分布来光栅化 发展进程中有几种里程碑式的方法： FXAA（Fast Approximate AA） TAA（Temporal AA） 动态模糊，沿用上一帧的高频信息 DLSS（Deep Learning Super Sampling）低分辨率到高分辨率，进行一定的猜测填充 可见性 Visibility / 遮挡 Occlusion在光栅化工作中，实际上将空间中的模型投射到给出的视域“虚拟屏幕”上，因此另一个显著的问题就是当多个模型在投射过程中重叠的情况，针对此研究出了 Z-Buffering 深度缓存 方法 启发想法：画家算法描述了由远到近来执行绘画的方法，近侧的物体将在视图上覆盖远侧的物体；但此方法对例如循环叠放的三个平面就没法处理，深度实际上也很难定义 Z-Buffer ：在投射后每个像素上记录当前最小的 z-value 样本点的颜色信息 使用两个 buffer 分别存储每个像素点的颜色和当前投射过程中已经记录的最小 z 值，在投射模型时比较目标像素上的 z 值大小，保留较小的（即较近的）即可 代码演练借助 eigen3 库已经实现的 向量和矩阵 类进行基本的运算即可 eigen3 官方文档 注意其中大多数运算符都已经重载，而向量的点积和叉积则需要调用 Vector 对象的 dot() 和 corss() 方法 旋转后平移传入角度和平移量的向量，完成先旋转后平移变换，输出变换后的向量 光栅化实现课程提供的框架中首先实现了一个 Triangle 类可记录三个顶点的坐标以及顶点的颜色、材质等 分别针对摄像机视角，模型的仿射变换，透视投影的仰角和前后投射面设计好相应的函数用于存储变换矩阵，最终仅当要完成光栅化时按照顺序应用变换矩阵 Model Transformation : 模型变换由 “旋转轴向量和旋转角度” 以及后续的 “平移操作” 确定变换矩阵 Camera Transformation : 相机变换由 相机位置坐标 、相机朝向、相机正上朝向 确定变换矩阵 Perspective Projection : 透视投影由 视野仰角、视域宽长比、投射远近平面距离 确定变换矩阵，记得在压缩后执行 “正交投影” Viewport Transformation : 在透视投影后变换至标准正方体区域 Z-Buffering 在光栅化的末尾步骤考虑，对显示区域的每个像素（简单模型可以先缩小其覆盖的 box 范围）记录其当前深度与颜色，在逐步执行模型光栅化时比较深度，若像素点深度更小则更新颜色，否则表面该模型对应的像素已经被遮挡 "},{"title":"unity游戏开发（3）","date":"2022-04-30T07:24:11.000Z","url":"/2022/04/30/Unity/unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%EF%BC%883%EF%BC%89/","tags":[["入门介绍","/tags/%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/"],["3D游戏","/tags/3D%E6%B8%B8%E6%88%8F/"]],"categories":[["Unity","/categories/Unity/"]],"content":"使用 unity 制作 3D 游戏基本上没有很大差异，因为 2D 游戏也存在 z 轴，可以体现出游戏对象相对于摄像机的远近层级；本篇仅补充 3D 项目相对于 2D 项目的差别 相对差异层级对象 Hierarchy 3D 项目的新场景内预置的除开 Main Camera 对象还有一个 Directional Light 表示场景光源 3D 模型对象 自带的几种 3D 基本模型，右击在 3D Object 选单中： Cube 立方体；Sphere 球体；Capsule 胶囊体；Cylinder 圆柱体；Plane 平面 … 平面是没有厚度的，且正面可见背面透明；其他立体模型从内部观察也是透明的 针对对象可以进行平移、旋转、缩放操作，左上角选择操纵模式（或 W、E、R 快捷键切换）或者直接修改 Transform 数值 对象的平移操作有 Global 模式和 Local 模式，前者以世界坐标系平移，后者以对象自身坐标系平移（例如旋转后），在 Scene 栏左上角切换 平移方向 right、up、forward 分别表示 x、y、z 轴向 轴心点 Pivot 在自建模型时可以指定，作为旋转操作的参考；自带几何体的轴心点就在几何中心位置；另有几何中心点模式 Center；同样在左上切换 模型属性查看 观察模式：在 Scene 栏的左上方可以选择 shading mode；任何模型表面都是由若干三角面围成（建模资源本身如此） Shaded 着色模式，显示模型的表面材质 Wireframe 线框模式，仅显示模型网格 Shaded Wireframe 线框着色模式，同时显示 材质资源：对象的 Material 属性在其 Mesh Render 组件中（可以构成数组来关联多个材质），可以自建材质资源来应用到各个对象上 一个模型总是有默认材质的，而若其材质为 None，则显示上变成纯浅紫色 Albedo 可以选择材质的纹理，或者给其指定贴图；右侧上色 导入外部模型，标准模型格式为 FBX，导入到 Unity 资源可以看到其包含 网格、材质以及单独的贴图文件 外部导入的模型，其材质资源被包含在 FBX 压缩内，可以选中资源后在 Inspector 栏进行重映射进行修改或者 Extract 来提取材质 FBX 压缩模型资源可以直接使用其网格和材质作为资源 补充：摄像机对象可以正常旋转平移等操作；先选中 Main Camera 在工具栏 GameObject-&gt;Align With View 将摄像头视角摆到当前视角上（对其他对象也可以） 3D 对象常用组件 Light 光源组件 Mesh Filter 网格过滤器 Mesh Renderer 网格渲染器 场景视图 Scene3D 场景的视图中含有几个元素： 导航器 Gizmo，表示世界坐标的方向，给出当前视角下的 XYZ 方向 按住 shift 点中间的方体可以恢复方向 分别点击某个轴向得到相应轴向的视图 栅格 Grid，表示 XZ 坐标平面，Y 轴为纵向高低 天空盒 Skybox，表示游戏世界的背景 操作视图： 旋转视图：alt + 左键拖拽（Unity 仅支持以视图中心进行旋转，如果希望以对象为中心旋转，可以选中对象然后按 F 将其置于视图中心） 缩放视图： 鼠标滚轮 alt + 右键拖拽（精细缩放） 平移视图：中键拖拽 视图模式切换： 默认使用透视模式，会有近大远小的效果，不方便物品对齐；在导航器下方的位置单击进行切换，转为正交视图，可以完全正交于一个平面观察 补充注意项： 新增对象时默认放置在当前视图的中心点坐标，而非世界坐标零点 脚本操作通常的移动操作和 2D 没有差异 粒子特效Unity 自带的粒子系统 Particle System；用于模拟一些流动的、没有形状的物质，如：液体、烟雾、火焰、爆炸、魔法效果等 粒子系统 Particle System在层级界面右击 Effects-&gt;Particle System 创建粒子特效，可以看到一个播放式的对象；此对象功能主要由 Particle System 组件实现，其主模块下有 22 个子模块，默认启用了 Emission / Shape / Render 三个模块 选中带粒子系统组件的对象即有一个预览播放窗口，可以执行播放、暂停、变速等 模块与参数 主模块 Main Module：设置粒子的基本参数，例如速度、颜色、大小等（其中能由单词确定的暂略） Duration 周期，粒子系统的工作时长 Looping 循环，粒子系统是否循环工作 Prewarm 预热，粒子系统是否先内部预热一个周期（不预热就会有从 0 开始的效果，否则一开始就有很多粒子） Start Lifetime 粒子的生命时长，默认 5 秒 Simulation Space 可选择的样式，Local 时粒子位置总是相对对象坐标；World 模式粒子释放后仅相对世界坐标 子模块 Emission ，发射的频率（禁用则不发射任何粒子） 匀速发射模式：修改前两项，Rate over Time 数值表示每秒发射 N 个粒子；Rate over Distance 表示对象每前进 1 米发射 N 个粒子（一般作为子对象时使用） 爆发发射模式：列表形式的设置，每个值可以设计五个参数 —— Time 爆炸发生的时间；Count 爆发出多少粒子；Cycles / Interval 爆炸次数和间隔（可以无限次）；Probability 爆炸的概率，0 表示不爆炸（哑弹） Shape ，粒子发生器的形状，用于限定所有粒子的运动范围 Shape 默认 Cone 表示圆锥，Mesh 可以设置网格资源，Sprite 可以设置图像资源 禁用 Shape 则仅延对象的本地 z 轴向发射 Renderer ，粒子的显示与渲染 Render Mode 表示渲染模式，默认 Billboard 广告牌模式，平面总是朝向摄像机视角（任意角度观察都是平面） Material 可以设置材质资源，修改后可见每个粒子都是一个方形的平面 粒子着色器 ：通常我们希望用于粒子特效的材质资源具有透明背景（由 PS修改）：但不理想的时候用黑色背景也可以对材质进行设置：1. 将 Shader 改为 Particle/Standard Unilt；2. Render Mode 改为 Additive；3. Color Mode 改为 Multiply；4. Albedo 改为 “指定贴图” （大概是图像掩码） 颜色相关 Color over lifetime ，随粒子生命周期颜色渐变；当同时设置 Start Color 和渐变色时，会对两个颜色进行点乘得到颜色 Size over lifetime ，大小渐变，编辑渐变曲线可双击增加控制点 速度相关 Velocity over lifetime ，速度渐变，和初始速度加法结算；结合 Circle 等形状修改 Orbital （轨道速度）可以实现环形扩散 （旋转 Rotation 略） 作用力控制 Force over lifetime ，作用力，可以分方向给常量或曲线变量 Limit velocity over lifetime ，速度衰减（介质阻力） Drag ，摩擦系数、模拟介质阻力；结合下面两项相乘结算 Noise ，噪声（来自于介质的扰动） 粒子碰撞 Collision 模块 Type 指定若干个平面用于碰撞检测（一般作为子对象并隐藏视图）；或者 World 类型可以指定各种碰撞体对象（不推荐，耗费性能） 可以针对粒子碰撞事件编写脚本，步骤如下： 添加脚本并挂载在粒子系统对象上 脚本覆写事件函数 OnParticleCollision Collision 模块中勾选 Send Collision Message 视觉效果 Trails ，实现粒子的拖尾效果 Texture Sheet Animation ，用帧动画实现粒子效果，可以调整帧率等 Lights ，让发射的粒子携带一个点光源，需要引用一个点光源预制体（或对象） Sub Emitters ，引用一个粒子发射器，可以实现当一级粒子消亡时执行二级粒子发射器等效果 "},{"title":"OpenCV功能分类链接","date":"2022-04-16T09:36:14.000Z","url":"/2022/04/16/OpenCV/OpenCV%E9%80%9F%E6%9F%A5%E8%A1%A8%E5%8F%8A%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89/","tags":[["python","/tags/python/"],["opencv","/tags/opencv/"],["short-cuts","/tags/short-cuts/"]],"categories":[["OpenCV","/categories/OpenCV/"]],"content":"按照 OpenCV 对外接口的功能分类，在此给出速查表形式的记录 图像基本操作：包括创建窗体、读写图像和视频素材等；获取到图像对象为一个 ndarray，可以执行一下几类操作 颜色通道操作：split 、merge 操作 对象拷贝：对象方法 view 和 copy 分别浅、深拷贝 边界填充： copyMakeBorder 函数扩大原图像范围，加上边框 对象运算 ：包括 ndarray 对象重载的运算符操作和 cv2 定义的函数运算；图像融合可通过加权的加法运算完成 线条文字绘制 图像自变换：针对图像自身的像素点分布和值特征做变换 图像二值化 ：设定一个阈值和类型来对图像自身执行变换 图像平滑：使用卷积核平滑处理图像像素，如清洗椒盐噪声等 图像仿射变换：包括平移、旋转、透视变换，通过数学上变换矩阵实现 图像形态学变换：包括侵蚀 erode、扩张 dilate 等操作 图像梯度计算：图像的梯度反映了像素点上值的变化趋势，一定程度上描述了物体轮廓；有 Sobel 算子、Scharr 算子、拉普拉斯算子等 边缘检测 图像金字塔：通过高斯卷积核对图像执行两倍的缩小和放大操作，做差运算获取轮廓信息 轮廓检测：捕获一般的轮廓特征和一些特殊性的轮廓特征（如拐角等）；以及轮廓近似操作 模板匹配：逐个像素滑动来比较计算相似度，返回一个目标图像大小减去匹配图像大小的对象，每个位置的值表示以此位置为左上角的区域相似度 直方图：根据像素点的值作为横轴（可能分箱）统计点个数绘制直方图；衍生出均衡算法等来提升图像表现力，如对比度 进阶算法 傅里叶变换 常用功能组前后对比识别参考别人完成的聊天窗口识别，当前后发生足够的偏差（有人发出新消息）后再执行，其中对比工作通过计算图像直方图的方差完成，大致代码如下 感觉上面的不好阅读，而且使用中没找到合适的阈值用于检测；实际上可以直接利用 numpy 的 array 运算完成 "},{"title":"OpenCV简述及接口（四）","date":"2022-04-14T05:37:47.000Z","url":"/2022/04/14/OpenCV/OpenCV%E7%AE%80%E8%BF%B0%E5%8F%8A%E6%8E%A5%E5%8F%A3%EF%BC%88%E5%9B%9B%EF%BC%89/","tags":[["python","/tags/python/"],["opencv","/tags/opencv/"]],"categories":[["OpenCV","/categories/OpenCV/"]],"content":"直方图灰度直方图 calcHist(images, channels, mask, histSize, ranges[, hist, accumulate]) 根据图片得到灰度（或颜色值）的分箱，返回 histSize × 1 的数组 images 应当以 mat 对象的列表形式给出 channels 直方图的通道的索引（灰度图传 [0]），以列表给出 mask 通常为 None 来全局统计，否则给出区域的掩码图像 histSize 表示 bin 计数，通常 [256] ranges 各像素点的取值范围 [0, 256] 直方图均衡将集中分布（像素值接近）的直方图拉伸到两端（像素值范围广）形成较均衡的直方图；通常会提高图像的对比度；对于图像像素值局限在一个区域的对象效果最好 使用一个均衡化函数将各像素值转变，因此是可逆的；原理是根据累积分布函数将图像的原始分布范围展开到 [0,255] 范围 S_k = \\sum^k_{j=0}\\frac{n_j}{n} \\space k=0,1,2,...,L-1 numpy 实现：借助掩码数组获取到映射来完成 opencv 实现：封装好函数了，直接用就行 CLAHE对比度受限的自适应直方图均衡：将图像分成多个小块然后分别进行直方图均衡（opencv 中默认 8 × 8），为了避免小范围内的噪声而加上了对比度限制 —— 若某个直方图的 bins 数超过对比度限制（默认 40） 则先裁切像素并分配到其他 bin createCLAHE([, clipLimit, tileGridSize]) 创建一个 CLANE 对象（类似卷积核），然后可调用其 apply 方法 二维直方图通常用于处理每个像素的 色相和饱和度 两个特征 仍使用 calcHist 函数计算，传入二维时做出相应的修改（或者 np 也有） 其中 色相值介于 0 到 180；饱和度介于 0 到 256 直方图反投影一个论文中给出的方法，用于图像分割或在图像中查找感兴趣的对象。其创建一个与输入图像同大小的单通道图像，每个像素位置表示该点属于目标物体的概率。与 camshift 等算法配合使用 calcBackProject(images, channels, hist, ranges, scale) 可以切片原图的一个区域来代替下例的 rose 进阶接口简述原理和调用方法，很多高效图像算法都已封装完成 傅里叶变换理论忽视时间上的顺序，仅考虑时域内的频率，构成一个频域；用于分析各种滤波器的频率特性 参考知乎链接 作用 高频表示变化剧烈的灰度分量，比如轮廓边界 低频表示变化缓慢的灰度分量，例如一片草原 滤波器 低通滤波器仅保留低频，会使图像模糊 高通滤波器仅保留高频，会使图像细节增强 Numpy 实现 np.fft.fft2(a, s=None, axes=(-2, -1), norm=None) 输入一个数组（我们使用灰度图像） s 表示输出大小，会依据大小进行填充 0 或裁切；默认 None 则和输入大小一致 OpenCV 实现传入对象需要转为至少 np.float32 格式 dtf() ：执行正向傅里叶变换，返回的结果是双通道的（实部，虚部），需要转换成图像格式 idft() ：逆向傅里叶变换 注意：得到的结果中频率为 0 的部分会在左上角，通常要转换到中心位置，通过 shift 变换来实现 模板匹配使用模板图像在目标图像中查找；可以理解为将模板图像在目标中滑动比较来得到较匹配的位置 OpenCV 中的模板匹配 matchTemplate(image, templ, method) 返回一个灰度图像，每个像素表示该像素的邻域与模板匹配的程度，结合 minMaxLoc() 来定位最匹配位置的左上角 上函数中的可选 method TM_CCOEFF TM_CCOEFF_NORMED TM_CCORR —— 效果不佳 TM_CCORR_NORMED TM_SQDIFF —— 平方误差和做损失，使用此方法时应找最低值表示最匹配 TM_SQDIFF_NORMED 多对象的模板匹配当目标图像存在多个匹配位置时，应当使用阈值化来定位 霍夫曼变换在二维坐标系上的直线可以由垂线的角度和距离表示 其中 $\\rho = x cos\\theta + y sin\\theta$ 的 θ 为垂线到横轴的逆时针角度 霍夫曼变换即是以 ρ 和 θ 两个参数来检索图像中的线条的算法，其接收的图像应当是二进制的，因此先使用阈值变换或 Canny 边缘检测 HoughLines(image, rho, theta, threshold）输出 (ρ, θ) 值对的数组 rho 和 theta 分别表示参数精度，即单位值大小 threshold 表示接受构成一条线的票数，票数由线上的点个数确定 概率霍夫曼变换基于前者的优化，采用随机的点子集来减轻计算，相应的需要放宽阈值 HoughLinesP(image, rho, theta, threshold[, lines, minLineLength, maxLineGap]) minLineLength 表示最小线长度 maxLineGap 表示线段之间允许将他们视为一条线的最大间隙 霍夫圈变换 HoughCircles(image, method, dp, minDist[, circles, param1, param2, minRadius, maxRadius]) 查找图像中的圈 图像分割与 Watershed 算法分水岭算法，类似于等高线找轮廓；对图像中的噪声或其他不规则性可能产生过度分割，因此具体实现时增加了标记方法 watershed(image, markers) （TODO：看上去蛮复杂，用到的时候看文档，用过再补充） 交互式前景提取 GrabCut 算法一种抠图算法，可以在过程中补充操作来保留或剔除部分内容 grabCut(img, mask, rect, bgdModel, fgdModel, iterCount[, mode]) 理解特征类似于一些图像中物体的边角或中心平坦区域的特征，重点在于为计算机提供一个区分的途径 哈里斯角检测Harris Corner Detection cornerHarris(src, blockSize, ksize, k、, dst, borderType]) cornerSubPix(image, corners, winSize, zeroZone, criteria) Shi-tomas 拐角检测器和易于跟踪的特征 goodFeaturesToTrack(image, maxCorners, qualityLevel, minDistance[, corners, mask, blockSize, useHarrisDetector, k]) SIFT 尺度不变特征变换例如拐角特征是旋转不变的，但对于平滑弧线形式的拐角，尺度放大之后接近一般曲线，失去拐角特征； 此算法即针对尺度变换下仍保持不变的图像特征"},{"title":"OpenCV简述及接口（三）","date":"2022-04-12T04:11:58.000Z","url":"/2022/04/12/OpenCV/OpenCV%E7%AE%80%E8%BF%B0%E5%8F%8A%E6%8E%A5%E5%8F%A3%EF%BC%88%E4%B8%89%EF%BC%89/","tags":[["python","/tags/python/"],["opencv","/tags/opencv/"]],"categories":[["OpenCV","/categories/OpenCV/"]],"content":"本篇主要摘录 OpenCV 中对 mat 的数学变换 OpenCV 数学操作仿射变换仿射变换主要描述的是旋转、缩放、平移的总称，具体的做法是通过一个矩阵和原图片坐标进行计算，得到新的坐标 图像平移 warpAffine(src, M, dsize[, flags, borderMode, borderValue]) 执行仿射变换，若希望将原来点 (x, y) 处的像素点移动至 (x + t_x, y + t_y)，实际上可以看作进行以此矩阵乘法 M ：变换矩阵，精度至少是 float32，二维 2 × 3 dsize ：输出图片的大小（注意横纵） flag ：与 resize 中的插值算法一致，INTER_… mode ：边界外推法标志 value ：填充边界值 图像旋转不同与之前的旋转（90°水平不影响像素点分布），其他角度的旋转需要旋转坐标轴，其难点在于计算变换矩阵；OpenCV 提供了计算的 API ： getRotationMatrix2D(center, angle, scale) 计算以指定中心旋转指定角度的变换矩阵 center 中心点坐标，以哪个点作为旋转时的中心点 angle 旋转的角度，按照逆时针进行旋转 scale 缩放比例，取正常数 getAffineTransform(src[], dst[]) 通过三点可以确定变换后的位置，解方程求出偏移的参数和旋转的角度；返回变换矩阵（使用上不方便直观） src 原目标的三个点 3 × 2，要取至少 float32 dst 变换后的三个点 透视变换可以理解为在一个视线内截取不同的平面投影（若取平行的平面则仅发生缩放） warpPerspective(img, M, dsize[…]) ：参数同上，执行变换的函数 对透视变换来说， M 是一个 3 × 3 的矩阵 getPerspectiveTransform(src[], dst[]) ：获取透视变换的变换矩阵，需要 4 个点，即图片的四个角（可以先展示然后配合鼠标动作来获取） 滤波器卷积图片卷积就是使用一个卷积核在图片上按照指定步长移动并进行逐元的线性运算，每一步得到一个卷积特征 步长：即每次卷积核平移的像素个数，通常用 1 来充分扫描图片，当最后不足时就到下一行去 padding：有时为了保持卷积特征的大小和原图一致，可以在原图外围填充一层 0 ；该值即为填充的层数 输入体积大小 H1 * W1 * D1 四个超参数： Filter （卷积核）数量 K 卷积核大小 F （一定是方阵） 步长 S 填充层 P 输出体积大小 H2 * W2 * D2 H2 = (H1 - F + 2P)/S + 1 W2 = (W1 - F + 2P)/S + 1 D2 = K 在步长为 1 时，要令 (N + 2P - F + 1) = N 可得到 P = (F-1)/2 卷积核大小：通常取奇数，方便计算得到整数 padding 来保持大小；同时奇数能取到卷积核中心 接口案例 filter2D(src, ddepth, kernel[, dst, anchor, delta, borderType]) 返回卷积特征矩阵 ddepth 是卷积之后图片的位深，即卷积之后图片的数据类型，一般设为 -1 来和原图保持一致 kernel 卷积核，用元组或 ndarray，必须是 float 类型 anchor 锚点，即卷积核的中心点，默认 (-1,1) delta 运算时可选地增加一个常数项偏差，默认 0 borderType 边界类型，一般不设 方盒滤波 boxFilter(src, ddepth, ksize[, dst, anchor, normalize, borderType]) 方盒滤波，相当于取单位阵乘上一个常数 a 作为卷积核 normalize = True 时 a = 1 / (Kw * Kh)，此时等价于均值滤波；否则用 Kw × Kh 大小的全一阵（别用 False） blur(src, ksize[, dst, anchor, borderType]) 均值滤波，没有位深参数 高斯滤波使用符合二维高斯分布的矩阵滤波器来进行滤波操作(通常取相同的方差且不相关情形) 要使用高斯滤波的重点在于计算符合高斯分布的卷积核（高斯模板） 通常假定中心点坐标为 (0,0) 并自行选取一个 $\\sigma$ 例如对 3 × 3 卷积核取 1.5 做标准差，代入计算得到 为了符合卷积核的概率形式需要对计算出的高斯模板归一化 接口示例 GaussianBlur(src, ksize, sigmaX[, dst, sigmaY, borderType]) ksize 高斯核的大小 sigmaX ，X 轴的标准差 sigmaY ，默认为 0，此时 sigmaY = sigmaX 当指定 sigmaX = 0 时会使用 ksize 来计算 中值滤波取卷积感受野内的中值作为卷积特征的滤波操作；对于椒盐噪音（即零散的噪声像素点，像撒盐一样）效果明显 medianBlur(src, ksize[, dst]) 中值滤波，注意此处的 ksize 用单整数 双边滤波对于图像边缘信息能够更好的保存；其原理为使用一个与空间距离相关的高斯函数，以及一个与灰度距离相关的高斯函数相乘 空间距离：当前点与中心点的欧氏距离代入空间域高斯函数，其中 sigma 为空间域标准差 灰度距离：当前点灰度与中心点灰度的差的绝对值代入，sigma 为值域标准差 大致效果即 —— 当感受野内有显著灰度差异时，仅对灰度较大区域进行高斯模糊 bilateralFilter(src, d, sigmaColor, sigmaSpace[, dst, borderType]) 双边滤波 d 是一维的卷积核尺寸 sigmaColor 是计算像素信息使用的 sigma sigmaSpace 是计算空间信息使用的 sigma 算子主要用于识别图像边缘，边缘是像素值发生跃迁的位置，是图像的显著特征之一；在图像特征提取，对象检测，模式识别等方面都有重要的作用 Sobel 算子对图像求一阶导数：因为图像的灰度值都是离散的数字，sobel 算子采用离散差分算子计算图像像素点亮度值的近似梯度 为了近似地求出一个像素点处的梯度，使用横纵向两个卷积核扫描得到两个方向上的亮度变化情况，然后综合得到梯度 分别卷积扫描（padding=1）后得到两个同大小的新矩阵；对两个分量进行均方求和或者绝对值求和来近似梯度 Sobel(src, ddepth, dx, dy[, dst, ksize, scale, delta, borderType]) ksize 设置为 -1 就得到 Scharr 算子 Scharr 算子当内核大小为 3 时，Sobel 算子误差较大；Scharr 算子针对 3 大小做了优化，使用了不同的 kernel（水平如下，纵向类似） [[-3, 0, +3],[-10, 0, +10],[-3, 0, +3]] Scharr(src, ddepth, dx, dy[, dst, scale, delta, borderType]) 不允许修改卷积核大小，仅允许 3 × 3 拉普拉斯算子寻找二阶导数为 0 的位置判断为边缘（但二阶导为 0 也可能是噪声点，可以之后结合高斯滤波处理） 拉普拉斯算子求导（卷积核为左阵，用它去点乘感受野） Laplacian(src, ddepth[, dst, ksize, scale, delta, borderType]) 同时求两个方向的边缘 对噪声敏感，一般需要结合去噪的滤波算法 边缘检测 Canny 由 John F. Canny 于 1986 年开发的多级边缘检测算法，被认为是最优的；边缘检测的三个主要评价标准： 低错误率：标识出尽可能多的实际边缘，同时尽可能的减少噪声产生 高定位性：标识出的边缘要与图像中的实际边缘尽可能接近 最小响应：图像中的边缘只能标识一次 执行算法的一般步骤 使用高斯滤波器，以平滑图像，滤除噪声 计算图像中每个像素点的梯度强度和方向：对平滑后的图像采用 sobel 算子计算梯度和方向 $G = \\sqrt {G^2_x+G^2_y}$ 为了方便一般可用绝对值 $\\theta = arctan(\\frac{G_y}{G_x})$ 梯度方向被归为四类：竖直，水平，和两个对角线方向 应用非极大值（Non-Maximum Suppression）抑制，以消除边缘检测带来的杂散响应：扫描所有计算后的像素点，检查该点是否是其梯度方向（分解成四种）上的极大值，若是则保留到下一阶段，若不是则抑制（置为0） 应用双阈值（Double-Threshold）检测来确定真实的和潜在的边缘：设置上下阈值 maxVal 和 minVal，大于上阈值必定为边缘点，小于下阈值必定非边缘，范围内的点根据连通性归类（是否与边缘点相连通） 通过抑制孤立的弱边缘最终完成边缘检测 Canny(image, threshold1, threshold2[, edges, apertureSize, L2gradient]) 调用 Canny 算法进行边缘检测 两个阈值依次为 minVal 和 maxVal apertureSize 标识过程中 Sobel 算子的核大小 L2gradient 表示计算梯度方法，默认 False 使用绝对值和 形态学转换将原始图像上区分度较高的形状执行一定变换的操作，通常在二进制图像上执行 侵蚀大致是侵蚀前景物体的边界（尽量使前景保持白色），去除图像中的一部分；大致实现是使用一个卷积核滑动，在感受野中所有实际像素为 1 的当前像素被认为是 1，否则被侵蚀为 0 —— 舍弃边缘 erode(src, kernel) 扩张与侵蚀相反，大致当感受野内存在 1 时就被认为是 1 dilate(src, kernel) 形态学 Ex 操作 morphologyEx(src, op, kernel) 其中的 op 是以 MORPH 开头的一类操作，一下取值分别有几种效果 MORPH_OPEN 开运算，相当于先侵蚀在扩张来还原；对消除噪音有帮助（对比高斯模糊） MORPH_CLOSE 闭运算，先扩张后侵蚀 MORPH_GRADIENT 形态学梯度，对比扩张和侵蚀得到的结果，看上去像求轮廓 MORPH_TOPHAT 顶帽，是原图像和开运算图像之差 MORPH_BLACKHAT 黑帽，是闭运算和原图像之差 快捷 kernel一般使用 kernel 可以自己创建 ndarray 对象，OpenCV 也提供了几个快捷的形状 getStructuringElement(shape, ksize) 返回指定形状的 ndarray ksize 为二元组 shape 可选 MORPH_RECT 全 1 填充矩形 MORPH_ELLIPSE 椭圆形填充 1 MORPH_CROSS 十字形填充 1 性能衡量和提升计时当然用 python 自带的 time 模块可以实现计时，用 OpenCV 也可以 getTickCount() 返回从参考时间（如启动计算器）到调用此函数时刻的时钟周期数 getTickFrequency() 返回时钟周期的频率或每秒的时钟周期数 使用魔术方法 %timeit &#123;code&#125; 会多次执行代码段计平均耗时 OpenCV 默认优化许多 OpenCV 函数都是使用 SSE2、AVX 等进行优化的，默认都会启用 useOptimized() 检查是否启用 setOptimized() 设置启用 "},{"title":"OpenCV简述及接口（二）","date":"2022-04-11T02:15:56.000Z","url":"/2022/04/11/OpenCV/OpenCV%E7%AE%80%E8%BF%B0%E5%8F%8A%E6%8E%A5%E5%8F%A3%EF%BC%88%E4%BA%8C%EF%BC%89/","tags":[["python","/tags/python/"],["opencv","/tags/opencv/"]],"categories":[["OpenCV","/categories/OpenCV/"]],"content":"OpenCV 内设计了一个数据结构用于更好地适配各类图片和视频数据；在 C++ 底层中使用 mat 来保存图片，而 python 中转换成了 numpy 的 ndarray OpenCv 的重要数据结构 —— Mat后续用变量 mat 来替换 img 等 其他属性： depth ：像素的位深 channels ：通道数， RGB 是 3 size ：矩阵大小 type ：dep + dt + chs CV_8UC3 但实际上在 python 中只能访问到 ndarray 的几个属性如 ：ndim、shape、dtype 等 拷贝操作 图像的分割与融合 split(mat) ：返回多个通道下值的 ndarray merge((b, g, r)) ：将通道的元组融合，返回一个 mat 单通道的 ndarray 可能相当于灰度图，只有黑白之间 为图像设置边框在图像的整体边界创建边框 copyMakeBorder(src, top, bottom, left, right, borderType[, dst, value]) top、bottom、left、right 设置边界宽度（像素数） borderType 以 BORDER 开头的边框类型 value 当类型为 BORDER_CONST 时此参数给出边框颜色 绘制图形利用 OpenCV 提供的绘制图形 API 可以轻松在图像上绘制图形，结合鼠标动作的捕获可以完成框选等 line(mat, pt1, pt2, color[, thickness, lineType, shift]) 绘制直线，中括号内参数可选 mat ：图对象 pt1, pt2 ：点坐标，（基本）二元的 color ：BGR 颜色，三元组 thickness ：整数 lineType ：线类型，必须为 2 的次幂整数（感觉越大越光滑，无锯齿） shift ：缩放比 rectangle() 参数同上，点为左上右下 circle(mat, center, radius, color[, thickness, lineType, shift]) 画圆时半径必须为整数 ellipse(mat, center, axes, angle, startAngle, endAngle, color[, thickness, lineType, shift]) axes ：二元组，两个值为长宽的一半 angle ：椭圆的长轴顺时针旋转的角度 startAngle, endAngle ：可以不画完整椭圆，也是顺时针角度 polylines(img, pts, isClosed, color[…]) 省略部分一致 pts ：多边形的点集，必须是 int32，且必须是三维的 fillPoly(img, pts, color[, lineType, shift, offset]) 填充多边形，类似上一个 putText(img, text, org, fontFace, fontScale, color[, thickness, lineType, bottomLeftOrigin]) text ：是文本内容，字符串格式，因为没有中文字体所以不支持 org ：文本左下角的坐标位置 fontFace ：字体，以 FONT 开头的枚举 fontScale ：尺寸系数，会乘以字体的基本大小 中文文本：使用 pip install pillow 然后如下 图像 Mat 的算数运算基本运算 add(src1, src2[dst, mask, dtype]) ：执行图像的加法运算，即遵循矩阵规则，要求 shape 相同；如果超过 255 会变成 255（会容易变得很亮） dst 可以指定输出到哪个变量，一般用不到 subtract(src1, src2[…])：逐元减法，小于 0 会统一变成 0 multiply(src1, src2)：逐元乘法，同 divide(src1, src2)：逐元除法（取整），同 也可以直接对 mat 对象使用 + 进行运算，此时超过 255 会取模；实际上是基于 ndarray 运算然后取模，所以减等符号也能用 组合运算即进行线性加权运算 addWeighted(src1, alpha, src2, beta, gamma) 进行矩阵线性运算 w1 * x1 + w2 * x2 + bias；然而如果几个系数都是用常数，完全可以用运算符完成 位运算（逻辑运算）对整数的 与、或、异或 都是转化成二进制数然后每一位进行的，因此与运算不会增大、或运算不会减小 bitwise_not(mat) 返回一个取反运算的 mat 对象，具体取反操作是逐位向 255 求差，相当于 255 - mat bitwise_and(src1, src2) 逐元与 bitwise_or(src1, src2) 逐元或 bitwise_xor(src1, src2) 逐元异或 图像的基本变换图像的放大与缩小 resize(src, dsize[, dst, fx, fy, interpolation]) dsize：缩放后的图片大小，元组类 fx、fy：x 轴和 y 轴的缩放比，可以写 dsize=None 然后给出缩放比例 interpolation：插值算法，放大时的填充方法，主要有以下几种 INTER_NEAREST，邻近插值，速度快，效果差 INTER_LINEAR，双线性插值，使用原图中的四个点进行插值，默认方法 INTER_CUBIC，三次插值，取 16个点 INTER_AREA，区域插值，效果最好，计算时间最长 图像的翻转与旋转 flip(src, flipCode) 返回图像翻转的对象；也可直接用 np 的切片实现 flipCode = 0 时上下翻转，&gt; 0 时左右翻转，&lt; 0 时同时上下左右翻转 rotate(src, rotateCode) 旋转操作 ROTATE_90_CLOCKWISE 顺时针旋转 90° ROTATE_180 ROTATE_90_COUNTERCLOCKWISE 逆时针 90° 图像轮廓综合轮廓可以理解为连接具有相同颜色或强度的所有连续点的曲线，是用于形状分析以及对象检测和识别的有用工具 为了获得更高的准确性，请使用二进制图像。因此，在找到轮廓之前，请应用阈值或canny边缘检测 从OpenCV 3.2开始，findContours()不再修改源图像。 在OpenCV中，找到轮廓就像从黑色背景中找到白色物体。因此请记住，要找到的对象应该是白色，背景应该是黑色。 获取及绘制轮廓 findContours(src, mode, method) 先使用该函数找到轮廓，返回值有两个 —— 等高线（图像中所有轮廓的 tuple，每个轮廓是 (x, y) 坐标的 ndarray 对象；以及层次结构 mode 轮廓检索模式，以 RETR_ 开头 method 轮廓接近方法，以 CHAINAPPROX 开头，一般用 SIMPLE 即可 drawContours(src, contours, contourIdx, color) 基于轮廓边界点绘制 contours 作为 tuple 的轮廓列表，使用 find 的第一个返回值即可 countourIdx 轮廓的索引，传入 -1 会绘制所有轮廓 层次结构捕获轮廓时可能出现某些轮廓被包围在其他轮廓中，此时把外部的称为父类，内部的称为子类；这种父子关系就是层次结构 分级表示上方的 findContours 函数返回的 hierarchy 每个表示一个轮廓的信息，是一个四元数组 —— [Next, Previous, First_Child, Parent] 其中 Next 表示同一层次的下一个轮廓（若没有则 -1） 检索模式和逼近方法 轮廓检索模式 RETR_LIST ：仅检索轮廓，不创建亲子关系；所有轮廓属于同一层级 RETR_EXTERNAL ：仅返回最外部层级的轮廓 RETR_CCOMP ：分两级 —— 顶层是各部分的外部边界，第二层是内部空洞的边界 RETR_TREE ：最完整的层次结构，完全分级 轮廓逼近方法 CHAIN_APPROX_NONE ：以 Freeman 链码的方式输出轮廓，所有其他方法输出多边形（顶点的序列） CHAIN_APPROX_SIMPLE ：压缩水平的、垂直的和斜的部分，仅保留轮廓终点部分 轮廓特征轮廓的特征包括面积、周长、质心、边界框等 列出的函数有：矩、面积、长度、近似、凸包、 moments(array) 计算数组或（灰度或二值）图像的矩 当数组为点集时，会视其为一条完整轮廓 返回一个字典得到多阶原点矩、中心距和归一化中心矩 contourArea(contour) 传入一个轮廓，返回面积，其值等同于上面的 M[&#39;m00&#39;] arcLength(contour, closed) 轮廓长度，第二个布尔参数表示是闭合图形还是曲线 approxPolyDP(curve, epsilon, closed) 轮廓近似，将原轮廓在一定的接受度下近似为较平滑的其他轮廓 考虑一个弧线，若用直线近似则弧线上有一个到直线最远的点，其距离若大于阈值则可以再分个点来近似直线；递归判断 epsilon 从轮廓到近似轮廓的最大距离，可以试试长度的一定比例 convexHull(points[, hull, clockwise, returnPoints]) 轮廓凸包，检查曲线是否存在凸凹缺陷并进行校正（看文档吧） isContourConvex(contour) 检查是否凸出，返回布尔 边界矩形：分为横纵向的矩形和考虑旋转的矩形 boundingRect(contour) 返回 四个值依次为 x, y, w, h minAreaRect(contour) 返回一个 Box2D 结构，再借助 boxPoints 函数得到四角点 minClosingCircle(points) 包含对象的最小圆，返回 x, y, r；(x, y), radius = cv2.minClosingCircle(cnt) 要注意将 x、y、r 转为 int 才能画圆 fitEllipse(points) 拟合椭圆 fitLine(points, distType, param, reps, aeps[, line]) 最小二乘拟合直线 轮廓属性坚实度、等效直径、掩模图像、平均强度等 长宽比：由 boundingRect 结果计算 范围：面积 / boundingRect 的面积 坚实度：面积与凸包面积之比，使用 convecxHull 然后计算面积 等效直径：面积与轮廓面积相同的圆的直径，由原面积计算即可 取向：物体指向的角度，由拟合椭圆推出 掩码和像素点：获取构成该对象的所有点 最大、最小值及位置：借助掩码图像得到 平均颜色或平均强度： mean_val = cv2.mean(im, mask=mask) 极端点：最顶、最底、最左、最右点的坐标：借助 ndarray 的 argmin 等即可 轮廓更多属性凸性缺陷轮廓凸包上的任何偏差都可以被认为是凸性缺陷（原图像到凸包的凹陷），使用 convexityDefects 函数得到 convexityDefects(cnt, hull) 返回一个数组，每行由此构成 —— [起点，终点，最远点，到最远点的近似距离] 点多边形测试 pointPolygonTest(contour, pt, measureDist) 返回一点到轮廓的最短距离；若点在轮廓外则为负，反之为正 measureDist 为 False 时仅返回 -1、0、1 结果，不计算距离dist = cv2.pointPolygonTest(cnt,(50,50),True) 形状匹配 matchShapes(contour1, contour2, method, parameter) 比较两个轮廓的相似度并返回度量，越小越相似（根据矩计算） "},{"title":"OpenCV简述及接口（一）","date":"2022-04-10T15:06:21.000Z","url":"/2022/04/10/OpenCV/OpenCV%E7%AE%80%E8%BF%B0%E5%8F%8A%E6%8E%A5%E5%8F%A3%EF%BC%88%E4%B8%80%EF%BC%89/","tags":[["python","/tags/python/"],["opencv","/tags/opencv/"]],"categories":[["OpenCV","/categories/OpenCV/"]],"content":"opencv 是一个开源的计算机视觉库，针对 python、c++ 等多个语言都有接口，在这里先给出 python 上的模块安装以及常用接口 安装对于 python 可以比较方便地使用 pip 进行安装，进入 python 目录下找到 Scripts 目录，开启终端执行以下命令 命令行里测试一下 import cv2 即可 代码提示据说 opencv 的代码提示经常失灵，网上给出一个方法是找到 python 目录下的 Lib/site-packages/cv2/__init__.py 修改原来的内容为 环境选择为了方便同时使用不同的 opencv 版本（其他开源模块也可以），通常借助 conda 创建多个环境来分别安装不同的模块版本 综述绪论主要的计算机视觉是负责图像的区域分割处理，例如人脸识别时以眼部为特征主要的来源，从完整图像中获取眼部区域的图像，然后使用训练好的机器学习（神经网络模型）来完成分类；其他应用有如图像合成和图像增强 概念解释计算机上图像的存储通常都可以理解为矩阵形式的像素点，每个像素点具有颜色值属性 灰度图：不同于 RGB 三色图，而用由白到黑的一个灰度值表示像素点的颜色，构成灰度图 灰度直方图：对灰度图，按灰度值由小到大统计各灰度值下像素点个数绘制得到直方图 HSV(HSB)：是 OpenCV 使用最多的色彩空间 Hue 表示色相，用角度度量，从红色开始逆时针计算，绿色为 120，蓝色为 240 Saturation 饱和度，表示颜色接近光谱色的程度，值越小越接近白色 Value(Brightness) 明度，表示颜色明亮的程度，通常为 0% ~ 100% 由 黑到白 HSL：也是一种色彩空间，只是其 Saturation 及 Lightness 有点差异 YUV：是一种颜色编码方法 掩码：图像掩码通过将纯黑色的一定区域修改成白色实现，使用该掩码与其他图像执行 bitwise_and 操作即可仅保留白色区域 交互操作简介注意：OpenCV 中用到 Mat 的尺寸时总是接收先横后纵，而用 shape 则按照 np 的顺序显示，要注意调换 图像视频的加载和显式注意：凡是创建了捕获或者写入的对象，在完成之后都要调用 release 释放资源，类似文件操作 创建和显示窗口下面略去函数前的包名 cv2 namedWindow(wd_name, cv2.WINDOW_NORMAL) ：创建一个 window_normal 对象，wd_name 传入名称字符串 resizeWindow(wd_name, 800, 600) ：按像素点重设大小 imshow(wd_name, 0) ：窗口化显示 waitKey(0) ：等待按键来终止操作，会返回按键的 ascii 值；0 表示接收任意按键，如果给其他正整数表示等待按键的时间 ms destroyAllWindows() ：关闭展示窗口，一般手动关闭会同时终止 python 进程，并不理想，使用这个配合固定按键来轻便操作 其中 ord 是返回字符 ascii 码的函数 可以使用 pandas.DataFrame 来统计不同的像素点个数 读取图片对象 imread(filename[, flags]) ：传入图片路径，以及可选的读入模式，默认 BGR 彩色；返回像素点上的 BGR 值构成的 ndarray，即实际应为三维 可以借助 matplotlib 来展示图片（但其按照 RGB 显示，会不一致） flags 可选 IMREAD_COLOR 或 IMREAD_GRAYSCALE 等彩色或灰度图 imshow(im_name, im_var) ：显示图片对象 保存图片使用 imwrite(path, img) 保存图片；通常可以同退出操作操作一样，在 show 时检测键盘输入来进行保存和关闭 读取摄像头 VideoCapture(0) ：传入摄像头编号，一般用 0，返回一个摄像头捕获对象，后续可以调用该对象的方法来进行操作；这里使用 cap 变量 cap.isOpened() ：摄像头是否打开 cap.read() ：两个返回值，前者为是否正确读取，后者为读取到的帧，用于 imshow cap.open() ：打开摄像头 cap.get(…) / cap.set(…) 可以获取和设置摄像头参数 注意：上面每两次循环中等待了 10 毫秒，相当于帧率相当高 打开视频内容类似捕获摄像头操作，VideoCapture(path) 传入视频文件的路径，其他基本一致；调整 waitKey 时间来改变帧率 视频录制 VideoWriter() ：接收四个参数，返回一个用于录制的对象 vw 输出文件路径 多媒体文件格式，由 cv2.VideoWriter_fourcc 创建 帧率，正整数 分辨率，二元 tuple 等 VedioWriter_fourcc(*‘mp4v’) 一般这么用就行，里面的 * 是 unzip 操作；几种可选格式 ‘mp4v’、’XVID’(avi 格式) vw.write(img) ：编码并写入缓存（结合时间判断可以跳跃性写入） vw.release() ：释放资源 对象控制控制鼠标OpenCV 允许我们对窗口上的鼠标动作做出响应，调用 set… 来对窗体绑定操作，可以实现框选和点击等操作 setMouseCallback(wd_name, callback, userdata) wd_name 即对应窗口体的名称 callback 是回调函数，执行相应鼠标事件后调用 userdata 是回调事件需要的一个参数，写在这里用于传入 callback(event, x, y, flags, userdata) 回调函数必须包含 5 个参数 event 是鼠标事件，例如： EVENT_MOUSEMOVE 表示鼠标移动，可以用 0 代替 EVENT_LBUTTONDOWN 1 左键点击 EVENT_RBUTTONDOWN 2 右键点击 x, y 是鼠标发生事件的坐标点 flag 主要用于组合键，同时操作时会相加编号 EVENT_FLAG_LBUTTON 1 按下左键 EVENT_FLAG_RBUTTON 2 EVENT_FLAG_MBUTTON 4 EVENT_FLAG_CTRLKEY 8 按下 ctrl 键 EVENT_FLAG_SHIFTKEY 16 EVENT_FLAG_ALTKEY 32 userdata 就是 set 中传入的 TrackBar 控件使用 TrackBar 控件可以实现鼠标拖动修改数值，然后可以获取数值来修改 RGB 颜色等操作，以及修改大小 createTrackbar(tb_name, wd_name, value, count, onChange) ：创建 TrackBar 对象，value 为 bar 的默认值，count 为最大值，最小为 0，onChange 传入一个发生修改时的回调函数，仅接收一个值；不用赋给变量，因为是绑定在 wd 上的 getTrackbarPos(tb_name, wd_name) ：获取 TrackBar 当前值 色彩空间的转换 可以查看所有可选的色彩空间 cvtColor(img, c_space) ：将图片转为指定的色彩空间，返回转换后的对象，不修改原对象，常量全部以 COLOR 开头，使用提示方便点 inRange(src, lowerb, upperb) 传入两个上下边界的颜色值，结果仅保留范围内的像素点为白色，范围外的为黑色（后续用于mask） 二值化 threshold(src, thresh, maxval, type[, dst]) 图像二值化，将像素点值大于某阈值的归为 255（白色），用于实现大致的分划 thresh 用于判断的阈值 maxval 高于阈值时赋予的新值 type 由 THRESH 开头的几种类型 THRESH_BINARY 二值化，大于阈值为 255，小于为 0 THRESH_BINARY_INV 上一条反过来 THRESH_TRUNC 大于阈值部分设为阈值，否则不修改（截断） THRESH_TOZERO 大于阈值部分不变，否则改为 0 THRESH_TOZERO_INV 上一条反过来，大于阈值的改为 0 使用 cv2.THRESH_OTSU 可以自行搜索灰度图上比较好的二值化阈值，针对双峰图像效果显著 adaptiveThreshold(src, maxValue, adaptiveMethod, thresholdType, bockSize, C[, dst]) 自适应阈值，动态选择一个区域，取该区域的均值作为阈值来划分二值 adaptiveMethod 自适应方法 ADAPTIVE_THRESH_MEAN_C ：区域内均值 ADAPTIVE_THRESH_GAUSSIAN_C ：用高斯分布加权均值 tType 赋值方法，只有 THRESH_BINARY 和 THRESH_BINART_INV blockSize 规定区域大小（正方形区域，给单值） C 常数，阈值等于均值或加权均值减去该常数 高级显示图像金字塔将同一图像按照不同分辨率堆叠排列（不是实际叠在一起，只是组合显示） 有两种图像金字塔 1）高斯金字塔 2）拉普拉斯金字塔；其中拉普拉斯金字塔由高斯金字塔形成，仅描绘边缘图像，大多数元素为 0 高斯金字塔高斯金字塔是从高分辨率（低级别）图像中删除连续行和列得到低分辨率（高级别）图像；较高级别的每个像素由基础级别的 5 个像素贡献及高斯权重形成，原始 M×N 图像变成 M/2×N/2 图像，成为一次 Octave 操作；反之亦然 一旦降低了分辨率，就会丢失信息，还原后和原图不会一样 向上采样即先每个像素填充三个 0 来放大到两倍，然后用一致于向下采样的卷积核作用得到 拉普拉斯金字塔假设列表 gl 存入逐渐高级的高斯金字塔，一个拉普拉斯金字塔由 cv2.subtract(gl[i-1], cv2.pyrUp(gl[i])) 得到，因此最高级的高斯金字塔保留原状 合成例子"},{"title":"机器学习基础-提升方法","date":"2022-04-06T04:15:53.000Z","url":"/2022/04/06/Machine-Learning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80-%E6%8F%90%E5%8D%87%E6%96%B9%E6%B3%95/","tags":[["机器学习","/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"],["boosting","/tags/boosting/"]],"categories":[["Machine-Learning","/categories/Machine-Learning/"]],"content":"boosting 为一大集成学习方法，在多种模型上都可以应用，大致思想是提升误分类样本的权重，再进行后续轮次的学习 几种比较基础的提升算法应用模型 AdaBoost：初始化样本权重，用于训练弱分类器，然后降低正确分类样本权重，提升误分类样本权重，用于同一模型进行后续训练，最终得到强分类器 提升树：迭代多棵回归树，通常采用平方误差函数，每一棵树学习之前所有树的结论和残差，形成当前的残杀回归树，最后所有树的预测结果累加 GBDT：梯度提升树。利用损失函数的负梯度作为残差近似值，当前树模型学习一个提升方向 XGBoost：从 GBDT 基础上做出较大提升，基于 C++ 通过多线程实现了回归树的并行构建，在目标函数增加了包含叶子节点个数的正则化项，每个叶子节点上输出分数的 L2 模平方和，对目标函数进行二阶泰勒展开，算法运行更快（采用 level-wise 分裂策略，每一层节点无差别分裂；使用 exact 算法） LightGBM：同水平的高质量算法模型，采用 leaf-wise 分裂策略，在当前所有叶子节点中选择分裂收益最大的，更容易过拟合；使用了基于 histogram 的决策树算法，内存和时间性能更优 XGBoost基于 Boosting 思想实现的强学习器 由 GBDT 优化衍生而来，在其后还有 LightGBM 大致建模流程： 读取数据：xgb.DMatrix() 设置参数：param=&#123;&#125; 推荐用字典在外部完成后传入 训练模型：bst = xgb.train(param) 预测结果：bst.predict() 原理GBDTGradient Boosting Decision Tree：所有树必定是回归树，整体模型串行生成回归树，当第一个树生成时对每个样本都有一定的偏差，后续的树逐步学习模型整体与样本的偏差，也即残差学习 将当前模型的预测结果和样本的真实值代入损失函数，为了生成新的一棵树，我们考虑新的树可能的预测值，构成完整的新模型，此时的新模型的损失函数可以写为 min(\\sum^N_{i=1}L(y_i,f_{m-1}(x_i)+T(x_i,\\theta_m))) \\\\ =min(\\sum^N_{i=1}(y_i-f_{m-1}(x_i)-T(x_i,\\theta_m))^2)\\\\ = min(\\sum^N_{i=1}(r_i-T(x_i,\\theta_m))^2)即为新树预测对前一步模型的残差的均方误差 残差学习：原始的 BDT 直接将真实值和当前模型预测值的差值作为新生成树的学习目标；而 GBDT 针对上面的损失函数式向每一个样本计算梯度，选取负梯度方向向量后确定一个步长系数 $\\alpha$ 来最小化损失，最后 系数 * 负梯度 即为新树的学习目标 "},{"title":"Cpp面向对象（二）","date":"2022-04-06T03:25:41.000Z","url":"/2022/04/06/C++/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%BA%8C%EF%BC%89/","tags":[["cpp","/tags/cpp/"],["代码重用","/tags/%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8/"]],"categories":[["Cpp","/categories/Cpp/"]],"content":"代码重用面向对象编程的一大目标就是更高效的代码重用 has-a 类结构在一个类中使用其他类的大致编程结构 几种继承方式的区别 特征 公有继承 保护继承 私有继承 公有成员-&gt; 子类的公有成员 子类的保护成员 子类的私有成员 保护成员-&gt; 子类保护成员 子类的保护成员 子类的私有成员 私有成员-&gt; 只能通过基类接口访问 只能通过基类接口访问 只能通过基类接口访问 能否隐式向上转换 是 是（但只能在子类中） 否 包含对象成员的类可以使用 C++ 库提供的如 string、vector 等类对象作为成员（更推荐），也可以使用自定义的类 这个直接用就行，略 私有继承 初始化基类组件 使用私有继承，基类的公有成员和保护成员都将成为子类的私有成员。写法同公有继承，使用 private 或省略默认私有 访问基类的方法 由于未进行成员声明，在初始化列表中使用类名代替，后续要调用类方法时则要使用类名和作用域解析运算符 访问基类对象 使用强制类型转换来将指向本对象的指针转换为私有继承过来的类 访问基类的友元函数 类似第三条可以显式地转换对象为基类完成，重新定义一个友元函数 注意：私有继承和包含类成员的外部使用基本一致，对编写者而言通常使用包含，更易于理解内容 保护继承继承中使用 protected 关键字；基类的公有成员和保护成员都将成为子类的保护成员 可以重新定义方法去访问保护成员的接口，也可以使用 using 来重新定义访问权限 多重继承Multi Inheritance 描述的是有多个直接基类的类 使用时主要解决两个问题：从多个不同基类继承同名方法；从多个基类继承同一个类的不同实例 暂略 类模板类似容器类可以使用泛型来定义类模板 定义类模板：使用 template &lt;class Type&gt; 来告诉编译器准备定义一个模板，其中 Type 可以替换成任意变量名 T 使用模板类：传入具体的类型来实例化对象 模板可以递归使用，如 vector&lt;vector&lt;int&gt;&gt; 可以使用多个类型参数，如 unordered_map&lt;int, int&gt; 可以设置默认类型，如 template &lt;class T1, class T2 = int&gt; 模板的具体化：使用具体的类型生成类声明 隐式实例化：声明一个或多个对象，指出所需的类型，而编译器使用通用模板提供的处方生成具体的类定义 显式实例化：使用关键字 template 指出所需类型，此时编译器会实际完成对应类的声明；template class ArrayTP&lt;string, 100&gt;; 显式具体化：为特定类型给出显式的定义，实现和模板不同的功能；template &lt;&gt; class Classname&lt;specialized-type-name&gt; &#123;...&#125;; 其余按照类定义重新编写 部分具体化：给几个类型参数指定具体的类型，部分限制模板的通用性；template &lt;class T1&gt; class Pair&lt;T1, int&gt; &#123;...&#125;; 成员模板：模板可用作结构体、类或模板类的成员 将模板用作参数：template &lt;template &lt;typename T&gt; class Thing&gt; class Crab 中需要传入一个模板类 King 来声明 Crab&lt;King&gt; legs; 模板类和友元 非模板友元 约束模板友元：即友元的类型取决于类被实例化时的类型 —— 先在类定义前声明每个模板函数；再在函数中将模板声明为友元；再为友元函数提供模板定义 非约束模板友元：即友元的所有具体化都是类的友元 —— 在类内部使用不同的模板类型参数声明模板 模板别名：即使用 typedef 来指定别名，如 typedef std::array&lt;double, 12&gt; arrd; 后续用 arrd 声明即可 友元友元是在类定义中声明，允许外部访问该类的私有部分的特性 友元类一个类能允许其友元类的所有方法访问原始类的非公有部分，也可以进一步限制仅允许特定方法成为友元 举例电视机和遥控器，并不存在继承或包含关系，但遥控器能控制电视机，应当将遥控器设置为电视机的友元 声明友元类：在原始类定义的任意部分声明均可，friend class FC; 友元方法：上例中实际上只有 set_chan 直接访问了 Tv 类的私有成员，可以仅声明该方法为友元 friend void Remote::set_chan(Tv &amp;t, int c); 但实际上会造成循环依赖的问题（Remote 类定义需要有 Tv 类，Tv 类中友元函数的声明又需要 Remote 类方法声明），因此需要使用 前向声明 其他友元关系：可以两个类互为友元，编写时注意声明顺序 共同的友元：同时作为多个类的友元 嵌套类在另一个类中声明的类被称为嵌套类（nested class）；可以避免名称冲突 包含类（外部的）中可以创建和使用被嵌套类的对象 仅当嵌套类声明位于公有部分才可以在包含类外部使用，且必须使用作用域解析运算符 访问权限嵌套类的声明位置决定了其作用域；嵌套类内也使用 public 等来控制 模板中的嵌套模板类中也可以使用嵌套，并且该嵌套可以使用泛型来作为成员等"},{"title":"Cpp面向对象（一）","date":"2022-04-02T02:45:21.000Z","url":"/2022/04/02/C++/Cpp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%80%EF%BC%89/","tags":[["cpp","/tags/cpp/"],["oop","/tags/oop/"]],"categories":[["Cpp","/categories/Cpp/"]],"content":"面向对象编程（OOP）的几个重要特性： 抽象：对外提供的抽象接口 封装和数据隐藏：将实现细节放在私有部分不公开 多态 继承 代码的可重用性 一般来说，类规范由两个部分组成： 类声明：以数据成员的方式描述数据部分，以成员函数（方法）的方式描述公有接口 类方法定义：描述如何实现类成员函数 两个同类的对象可以直接进行赋值来复制成员 类声明和方法定义C++ 程序员通常将接口（类定义）放在头文件中，并将实现（类方法的代码）放在源码文件中 可以在类定义外部使用类似命名空间的 作用域解析运算符 来追加定义类成员方法 注意：在使用上 C++ 对结构体进行了扩展，具有与类相同的特性，但结构体默认访问类型为 public，而类为 private；习惯上仅用结构体表示纯粹的数据对象 注意：同 java 也有一个隐式的 this 指针变量指向调用对象，可以在方法内使用这个指针 const 方法 当创建 const 对象时，编译器会拒绝调用一般方法，因为无法确保对象不被修改。 为了应对这种情况，在确保方法不会修改调用对象时，应当将其声明为 const，写在参数列表后面表示加在调用对象上 构造函数和析构函数构造函数由于通常我们将成员设置成私有的，在创建类对象时不能保证用户总是先调用方法设置成员，因此设计构造函数来简化；构造函数和类同名，可以没有返回值和声明类型 构造函数通常负责初始化类的成员，一种方式是在函数体内进行复制操作 另一种是直接使用初始化列表 当然两种方法可以结合使用 复制构造函数：接收一个该类的对象作为参数，返回一个复制；通常无须定义由编译器自动创建；方便在初始化列表中使用 注意：构造函数的参数名要避免和类成员名一致，通常给类成员名加个下划线后缀 注意：默认构造函数仅在未定义任何构造函数时会由编译器提供，否则需要自己补充 析构函数在构造的对象过期时（同变量作用域）自动调用的特殊成员函数，完成清理工作；析构函数名由类名前加上 ~ 确定，也可以没有返回值和声明类型，必定没有参数 若编写者未提供析构函数，编译器会隐式地声明一个默认析构函数 隐式转换函数可以用一个参数调用的构造函数会被作为从参数类型到类类型的隐式转换函数，但有时不希望进行这种转换，可以在函数原型前加上 explicit 关闭这种隐式转换 类作用域在类中定义的名称，其作用域都为整个类，仅在该类中是已知的 用 static 声明类成员可以由类的所有对象共享此静态类成员 抽象数据类型类的使用该部分内容以如下类定义为背景 运算符重载是一种形式的 C++ 多态，在类定义中用形似方法定义的语句来重载运算符操作 将上方定义中的 Sum 函数名改为 operator+ 即可重载加法运算符；运算符也视作由一个对象来调用，将第二个对象作为参数；可以仍当作类方法，或者直接用运算符来调用 重载限制运算符重载不一定要作为类方法，而可以重载一般性的变量，但为了避免冲突有几条限制 重载后必须有至少一个操作数是用户定义的类型（如不能把两个 double 的减法运算重载了） 使用运算符时不能违反运算符原来的句法规则（原来两个数不能改成一个） 不能创建新运算符 不能重载如下运算符： sizeof .：成员运算符 .*：成员指针运算符 ::：作用域解析运算符 ?:：条件运算符 typeid：一个 RTTI 运算符 const_cast：强制类型转换运算符 dynamic_cast：强制类型转换运算符 reinterpret_cast：强制类型转换运算符 static_cast：强制类型转换运算符 友元当期望访问类的私有对象时，我们并不希望直接修改为公有，为此 C++ 提供了另一种访问权限 —— 友元： 友元函数 友元类 友元成员函数 友元函数通过让函数称为类的友元，可以赋予该函数与类的成员函数相同的访问权限 在重载操作符时可以传入基本类型，视作由原对象调用方法，但反过来我们在重载操作符（如乘法）时肯定希望 double * obj 也是合法的，为此就需要另定义一个非成员函数 operator*(double, cls) ，并创建为类的友元 创建友元 将函数原型放在类声明中，并在原型声明前加上关键字 friend；friend Time operator*(double m, const Time &amp;t); 虽然在类中声明，但不是方法，不能由成员运算符来调用 不是成员函数但具有相同访问权限 编写函数定义，不要使用 Time:: 限定符和 friend 关键字 常用的友元 ：&lt;&lt;对 &lt;&lt; 运算符进行重载则可以与 cout 一起显示对象的内容（相当于 toString） 第一种重载版本 该函数针对 ostream 的对象并未访问其私有成员，不必作为 ostream 类的友元，只需要作为 Time 类的友元 第二种重载版本 因为 cout &lt;&lt; x &lt;&lt; y 可以理解为 (cout &lt;&lt; x) &lt;&lt; y 前半部分的结果仍然是一个 ostream 对象 类的自动类型转换和强制类型转换自动类型转换例如 int a = 2.33; 会在赋值中完成自动类型转换，用户自定义的类型也可以实现自动类型转换，只需要定义几个接受一个参数（可以多个参数并给后面的默认值）的构造函数作为转换函数，但有时又不希望构造函数作为转换函数，可以追加 explicit 关键字关闭 强制类型转换 为了实现上方的强制类型转换，需要在类中实现转换方法operator typeName();，其中 operator 为关键词，后面是目标类型 转换函数必须作为类方法 不能指定返回类型 不能有入参 函数体中具体返回目标类型 类和动态内存分配暂略 类继承通过继承派生出的类通常比设计新类要容易得多，继承时可以实现： 在已有类的基础上添加功能 给类添加数据成员 修改类方法的行为（覆写） 基本继承流程一个简单的基类 及其实现 派生 用冒号指出基类，上述实现了公有派生，可以直接访问公有成员和方法，而私有部分只能通过 public 或 protected 方法访问 构造方法：由于子类不能直接访问基类的私有成员，但可以访问公有的构造方法，此处借助基类的构造方法用于初始化列表（若不明确指定构造方法会先使用基类的默认构造方法） 追加成员和方法：子类可以依照需求追加成员和方法（包括新的构造方法） 基类构造-》子类构造-》使用-》子类析构-》基类析构 继承方式C++ 有三种继承方式：公有继承、保护继承和私有继承 其中公有继承（上例）最常用，建立多态模型 —— 子类的对象同时可作为基类的对象 多态公有继承使用时会有需求子类的同名方法与基类不同作用，有两种办法实现： 覆写 使用虚方法（在基类和派生类的指定方法原型上追加 virtual 声明） 如果没有 virtual 声明，程序将根据引用类型或指针类型选择方法；如果使用了，程序将根据引用或指针指向的对象的类型来选择方法 在使用中可以创建一个基类的指针数组，然后遍历调用虚方法则可以视具体对象来达成不同效果；调用非虚方法则只会调用基类的该方法 注意：要进行重载通常将基类方法声明为虚，程序会自动识别作用到子类；同时惯例上也给基类一个虚析构函数 当子类要覆写方法时，一定要注意使用作用域解析运算符区分基类的方法 静态联编和动态联编 函数名联编：将源代码中的函数调用解释为执行特定的函数代码块 静态联编：在编译过程中通过函数签名确定的联编 动态联编：针对虚函数，编译器需要在程序运行时选择正确的虚方法 访问控制：protected对外部类似于 private 不能被直接访问，而对派生类则可以直接访问 protected 成员 注意：通常基类成员都使用 private，然后设置部分 protected 方法供派生类访问成员 抽象基类 abstract base class 纯虚函数：虚函数原型在末尾加上 =0，提供一个未实现的函数，相当于 java 中的抽象方法 当类声明中包含纯虚函数时，该类成为抽象类，不能创建该类的对象；用作基类 继承和动态内存分配不懂，暂略 小结 编译器生成的成员函数 默认构造函数：无参或所有参数都有默认值，在未定义构造函数时由编译器创建 复制构造函数：接收一个对象复制一份 赋值运算符：可以重定义赋值运算符 = 或者自动按照成员赋值 其他的类方法 构造函数：自行设定参数创建对象；不会被继承，派生类总要覆写 析构函数：一定要显式定义，用于释放 new 分配的内存等 转换：一种单参数使用的构造函数（可以给默认值形成单参数），完成从参数类型到类类型的转换 按值传递对象与传递引用：推荐使用引用传递来节省复制和析构的时间 返回对象和返回引用：同上，但注意不能返回在函数中创建的临时对象的引用，因为会被析构 使用 const：确保不被修改；一个 const 对象只能调用 const 方法 公有继承的考虑因素 is-a 关系：多态的表现 什么不能被继承：构造函数（使用初始化列表）、析构函数、赋值运算符 赋值运算符： 私有成员与保护成员 虚方法：在基类中声明，区分具体对象来调用；纯虚抽象化 析构函数：基类的析构函数应当为虚 友元函数：非成员函数，不能继承 综合使用基类方法 若未覆写，则子类自动使用继承的方法 若未初始化列表，子类的构造函数自动调用基类的默认构造函数 子类方法可以使用作用域解析运算符来调用公有的和受保护的基类方法 子类的友元函数可以通过强制类型转换，将子类引用或指针转换为基类引用或指针，然后调用基类的友元函数 "},{"title":"Cpp函数综合","date":"2022-03-30T11:42:46.000Z","url":"/2022/03/30/C++/Cpp%E5%87%BD%E6%95%B0%E7%BB%BC%E5%90%88/","tags":[["cpp","/tags/cpp/"],["functional","/tags/functional/"]],"categories":[["Cpp","/categories/Cpp/"]],"content":"函数是典型的面向过程编程 函数内容 函数原型：typeName functionName(parameterList); 写在头文件中用于告诉编译器函数的定义格式 函数参数cpp 的函数默认是传递形参，及在函数体内会复制一份传入的参数来使用，进行修改不会改变函数外的变量；但传递数组时，由于数组名实际上是指向数组中第一个元素的指针，因此传入时即使复制了一份也还是一个指针，即是会修改到原数组； 在声明时对数组参数加上 const 修饰可以避免函数体内数组被修改 传入 vector 、deque 等容器对象时，其基本类似与结构体，默认是传入形参，再函数体内处理原始对象的副本 引用变量对于处理副本的函数（接收结构体或类对象做参数），我们不一定要使用指针来对原来的对象进行修改，而可以使用引用变量快速地实现 引用变量相当于对一个原有的变量取别名，他们都存储了同一个内存地址上的值 必须在声明引用变量时进行初始化 函数重载在函数定义中可以给出默认参数，在调用时可以不传入指定参数而使用默认参数；默认参数必须从右向左填充（避免位置冲突） 而函数重载即是可以允许有多个同名的函数，通常设计用于完成相同的工作，但是使用不同的参数列表（注意不能区分是否引用，但区分是否 const），返回类型要相同 函数返回即函数的返回值，可以赋值给变量获取函数结果 返回引用函数返回一个引用也可以节约复制一份变量的时间 注意：不要返回指向局部变量或临时对象的引用，因为在函数执行完毕后会消失。即不要在函数体内部创建新变量然后返回其引用 函数指针函数也有地址，是存储其机器语言代码的内存起始地址；可以编写一个函数，其将另一个函数的地址作为参数，用于实现在不同时期使用不同的函数 获取函数的地址：只要使用函数名且后面不跟参数即可 声明一个函数指针：声明应指定函数的返回类型以及函数的特征标（参数列表） 使用函数指针来调用函数 声明简化一个函数指针的声明会视被指向函数的复杂度及重复使用次数上升，但幸在 C++11 有了非常便利的方法 auto ：无论一个函数多么复杂，都可以使用 auto pf = func; 直接完成定义 typedef ：创建类型别名，方便重复使用，例如 函数模板指通用的函数描述，即使用泛型来定义函数；函数模板也可以进行重载 关键词 template 用于描述建立模板，typaname （或者其他情况用 class 代替）将类型命名为 AnyType（任意），这两个关键词必须 后续调用时直接传入两个同类型参数即可 注意：使用函数模板只是编写者能节省时间，实际运行时还是会根据使用的类型生成实际函数 显式具体化模板函数在处理一般的类或结构体时很难取得理想的效果，虽然也可以针对结构体再编写非模板函数（优先级更高），但也会降低效率，为此有显式具体化模板函数 对于给定的函数名，可以有非模板函数、模板函数和显示具体化模板函数以及它们的重载版本 显式具体化的原型和定义应以 template&lt;&gt; 开头，并通过名称来指出类型 具体化优先于常规模板，而非模板函数优先于具体化和常规模板 "},{"title":"职业概述-测试开发","date":"2022-03-29T13:03:06.000Z","url":"/2022/03/29/Career-Intro/%E8%81%8C%E4%B8%9A%E6%A6%82%E8%BF%B0-%E6%B5%8B%E8%AF%95%E5%BC%80%E5%8F%91/","tags":[["career","/tags/career/"],["测开","/tags/%E6%B5%8B%E5%BC%80/"]],"categories":[["Career-Intro","/categories/Career-Intro/"]],"content":"测试开发岗位主要针对现已开发完成或正在开发流程中的应用进行需求和功效分析，在此基础上确定测试样例和规模，并建立测试中的评估指标，从多个维度去评价功能的当前效果 常规测试方法基于测试者视角 黑盒测试：将应用功能当作完全的黑盒，外部只能访问到其提供的接口，以及功能说明上给出的接口功能，相当于从用户视角去测试产品，观察是否正确完成用户需求的功能 白盒测试：基于逻辑驱动或代码测试，直接考察代码实际接受到外部指令后执行的命令即过程中影响到的变量，观察最终是否做出正确的行为 基于被试者视角即考虑被测试功能的性能，承载能力等 功能测试：最基础的实现功能 性能测试：对系统的各项性能指标进行测试，关注fps、cpu、gpu和电量等性能标志 压力测试：主要指服务器的负载能力，能够承受同一时间多少用户的使用或是承受多少操作申请 兼容性测试：应用在各种不同平台上的显示和使用功能，如分辨率，界面布局，支付接口等 安全性测试：通过不同方法发现安全性隐患，如信息泄露，非法使用等 自动化测试：开发中，是未来 分行业简介自动驾驶算法测试开发自动驾驶作为一个若是上线将切实关联到用户群体以及参与交互的道路主体人身安全的技术领域，其功能测试必然要着重关注车辆的安全性，包括对社会车辆或其他行人的避让安全性以及在此基础上确保本车乘客的安全，而在安全性评估之外，则可以进一步考虑驾驶过程的舒适性和效率。 测试数据集自动驾驶技术的测试行为主要通过仿真系统来实现，其基于完善的高精地图来还原道路信息，再借助车端采集的数据来还原场景信息，以此进行固定场景下的算法功能对比；也可以一定程度上自定义简单的场景，人为地设计社会车的动作进行交互 自动驾驶技术的测试数据主要来自于车端的感应器采集后逐帧记录的环境数据，其融合了摄像机视觉和雷达的数据，结合车载 GPS 和传感器定位来多方面复现车辆驾驶中的场景，用于较完整地复现驾驶过程中的场景 测试指标根据具体的测试内容，通常可以从不同的角度来设计测试指标： 分母上常见的可以根据行驶里程数来累计评估，例如平均百公里擦碰次数，百公里急刹次数等（按里程来统计也是传统车企的常规评估指标）；也可以按照具体的完整场景来进行统计，例如一个完整的靠边停车场景，或是完整的会车让行场景 分子上可以统计常见的频次指标或者偏移值的指标 例子一个可供思考的实际场景：尝试建立公交或出租车在路测中停车行为的评估指标体系 根据停车行为的目标先做场景区分：车辆靠边载客（下客）场景、红绿灯处候车场景、车流交汇（等候行人）让行停车场景 在各个场景中都可以考虑到自车的几个功能模块的效果：规划、感知、定位等模块中，如感知和定位都可以设计指标评估其稳定性，例如出现连续几帧来回跳变的现象的平均比率（多个行人由于位置较近被判为一个） 靠边停车场景： 感知上需要识别出明确的车道线来确定可以驶入暂停的区域，对路边影响停车的机动车和非机动车单位的识别稳定性，对多个行人聚集时的感知准确性和稳定性，还有对物体类别地准确识别也很关键，会直接影响车辆对该物体的具体决策（主要观察静态物体是否持续地保持地图坐标，动态物体是否有发生重叠跳变） 规划上需要监控轨迹曲线（经过插值方法得到）的平滑性，如记录完整过程中最大的曲率，数值分箱来查看高曲率轨迹地比例等，还需要评估整体流程中速度变化水平的平滑程度，即根据减速停车和加速起步过程中速度曲线来估算加速度水平 候车停车场景： 感知上需要正确识别出信号灯的颜色，若条件允许还应当根据剩余时间来动态调整策略，执行提前减速或加速强行；还要正确识别出路口的车道线以及预留安全距离的停车位置（根据前车位置或横道线位置可以做差构成一个指标） 游戏测试开发一篇不错的知乎回答"},{"title":"Cpp基础","date":"2022-03-28T11:35:48.000Z","url":"/2022/03/28/C++/Cpp%E5%9F%BA%E7%A1%80/","tags":[["tips","/tags/tips/"],["cpp","/tags/cpp/"]],"categories":[["Cpp","/categories/Cpp/"]],"content":"编写习惯命名通常使用 驼峰命名法 小驼峰：在一个完整标识符中第二个单词起首字母大写，常用于函数、方法名 大驼峰：每个单词首字母大写，常用于类名、命名空间等 个人习惯：对于属性变量使用下划线命名法，私有属性在末尾再加一个下划线以作区分 编辑格式 运算符、括号 等符号总是留出空格方便阅读 代码块的左括号置于关键词或函数行末，右括号另起一行（个人习惯） 命名空间结束行位置追加注释 文件末尾留单空行 引入文件总是按首字母字典序，且库文件在前，工程文件在后 复合数据类型在基本的整型、浮点型、字符之外的复合数据类型，包括数组、字符串等 数组声明如 typeName arrName[arrSize]; ，只有在声明时可以初始化，其后只能通过赋值来操作，例句 char tlifs[4] &#123;&#39;h&#39;, &#39;i&#39;, 112, &#39;\\0&#39;&#125;; 字符串传统的 C 式字符串是 char 数组，并且在存储中严格要求以 &#39;\\0&#39; 字符作为结尾，即长度总是比字符数多一个 而封装的 string 类则可以动态调整大小，是更方便的用法 结构体 struct主要用于存储成员（变量）组合的一类对象，定义、实例化、访问如下： 共用体 union是一种数据格式，可以存储不同的数据类型，但一个对象同一时刻只能代表一种（相当于延展了对象的使用范围，但没见用过）；在声明对象的时候申请空间，按照共生体能存储的最大类型的空间申请，可以实现节约空间的效果（一个空间反复使用） 枚举 enum一种新类型，用整数值来代表符号常量（枚举常量可以转为 int 用于运算和赋值，但反之不行），具体代表的整数值可以在定义时给出，不给出则默认按顺序递增 指针和自由存储空间计算机在存储数据时必须跟踪三种基本属性： ①：信息存储的内存位置（在赋值给变量时会派生出地址，以十六进制存储） ②：存储的值 ③：存储数据表示的类型 指针即是一个存储地址作为值 ② 的变量，对于一个常规的变量如 var，通过地址运算符即可得到其地址值 &amp;var，此时又对应一个解引用符，可以将获取指针变量所存储地址上的变量 下面的例子 注意：一定要在对指针解引用之前，将指针初始化为一个确定的、适当的地址注意：*++pt 和 ++*pt 是不同的，前者是先由指针指向下一位再解引用，后者是先解引用取得值再自增；(*pt)++ 没有争议，而 *pt++ 实际上的表达式值和前者一样，但是此后会对 pt 自增（因为自增优先级更高，但是在完成表达式后执行） const 指针有两种方式将 const 关键字用于指针 指针指向一个 const 常量对象：防止指针被用于修改其指向的值，实际上并非指针指向的值为常量，并且仍然允许修改指针的指向（const 变量的地址只能赋给 const 指针，而不能给非 const 指针） 将指针本身声明为 const 常量：防止改变指针指向的位置，可以用指针去修改其指向的值 动态数组使用 new 关键字可以创建动态数组，其仅在实际使用时才创建真实数据，区别于在编译时就给数组分配内存的静态数组 注意：对于一个数组名如 arr，其实际上是指向该数组第一个元素的指针，arr[n] 相当于 *(arr + n) 也即对第一个元素移动 n 位类型长度得到的值 表达式循环体语法略 tips： do…while 循环可以用于持续接受输入判断是否符合条件 逗号表达式cpp 允许在一个语句中用逗号来同时执行多个表达式，其会严格按照顺序完成，并且整体语句的返回值为第二个表达式，例如 关键词 decltype ：可以用于声明修改变量的类型，格式如 decltype(expression) var; 能将 var 的类型设置为表达式的类型 在定义优先队列时也可以用于将自定义的排序函数作为类型传入 priority_queue&lt;T, Container, decltype(&amp;cmp)&gt; pq(cmp); 内存模型和命名空间#include 导入头文件即可 内存模型与其将结构声明加入到每一个文件中，不如将其放在头文件中，然后在每一个源代码文件中包含该头文件，通常将程序分成两个主要文件： 头文件：包含结构声明和使用这些结构的函数的原型 函数原型 使用 #define 或 const 定义的符号常量 结构声明 类声明 模板声明 内联函数 源代码文件：包含与结构有关的函数代码和其调用函数代码 注意：不要使用 #include 来包含源代码文件，会导致多重声明 预处理器编译指令#ifndef 用于避免多次定义同一个变量名，相当于预处理的条件语句 作用域 自动存储持续性变量：一般的常规变量都是在代码块内作用，且内层的代码块中定义的同名变量具有更高的优先级；若定义在代码块外部则可以被其他文件访问 静态持续变量：有三种链接性，均在整个程序执行期间存在，寿命更长 外部链接性（可在其他文件中访问）：在代码块外声明即可 内部链接性（只能在当前文件中访问）：在代码块外使用 static 限定符声明即可 无链接性（只能在当前函数或代码块中访问）：在代码块内使用 static 声明即可 说明符和限定符一些存储说明符（以及 cv-限定符）提供了其他有关存储的信息，在同一个声明中不能使用多个说明符（可以和 cv 符一起）： auto：用于自动类型推断 register：指示寄存器存储 static：静态声明 extern：引用声明，即引用在其他地方定义的变量 thread loacl：用于线程上，相当于 static 用于变量 cv-限定符： const：避免程序修改已经初始化的内存；同时将全局变量的链接性变为内部的（每个文件都可以有自己的一组常量），可以用 extern 引用其他文件的常量 volatile：用于改善编译器的优化能力 —— 一般若某个变量被多次使用，编译器会将其值缓存到寄存器中，而非多次查找；加上该关键词则不会这样 mutable：用于结构或类变量的成员，即使结构体对象为 const，用该关键词声明的成员也可以进行修改 命名空间用于控制名称的作用域 传统命名空间 声明区域(declaration region)：可以在其中进行声明的区域。例如全局变量的声明区域为整个文件 潜在作用域(potential scope)：从声明点开始到声明区域的结尾 作用域(scope)：变量对程序实际可见的范围（可能内层再套代码块而不可见） 新特性通过定义一种新的声明区域来创建命名的名称空间。可以是全局的，也可以位于另一个名称空间中，但不能位于代码块中。 命名空间是开放的，可以后续完成定义或添加内容 通常通过作用域解析运算符 :: 来访问 using 声明和 using 编译指令 using 声明：using Jack::pail; 则相当于在代码块中可用 pail 访问到 Jail 中已经声明的该变量 using 编译指令：using namespace Jack; 相当于使名称空间中所有名称都可用 异常比较经典的就是以 0 做除数的异常，需要程序员在可能出现异常的位置先进行判断并设置好异常处理的逻辑；有一下几种选择 调用 abort()位于 cstdlib 头文件的函数，其典型实现是项标准错误流 cerr 发送消息 “abnormal program termination” 然后终止程序 使用时先 #include &lt;cstdlib&gt; 然后在判断异常后直接调用该函数即可 返回错误码根据函数的返回值来指出问题，例如 istream 的 get（void） 方法通常返回下一个输入字符的 ASCII 码，但到达文件尾时将返回特殊值 EOF 自己编写时则可以新增一个指针用于传递，当发生异常时将其地址上的值改为特定的值以便检测 异常机制对异常的处理包括三个部分： 引发异常（使用 throw 关键字引发特定类型对象异常） 异常类型可以是字符串，通常为一个类 使用处理程序捕获异常（使用 catch 关键字和其后括号中的类型声明捕获特定异常） 使用 try 块 异常类型通常可以定义异常类来存储异常时的数据，以便区分不同情况下的异常并提供解决异常的信息 捕获到异常时只需要调用对象方法即可 exception 类在 exception 头文件中有该类，可以作为其他异常类的基类，方便 catch；有一个 what() 的虚函数，返回一个字符串，其特征随实现而异，可以在子类中重新定义 在捕获的时候可以统一调用 what 方法返回异常信息 C++ 库定义了很多基于 exception 的异常类型 stdexception 异常类：位于头文件 stdexception 中，派生出 logic_error 和 runtime_error 类，再各自派生出一些异常类型；都可以传入 string 构造对象，what 方法打印该 string logic_error：编写逻辑异常 domain_error：定义域异常 invalid_argument：非法参数传递 length_error：空间不足 out_of_bounds：用于指示索引错误 runtime_error：运行时异常 range_error overflow_error：计算结果超过某种类型的最大数量级 underflow_error bad_alloc 异常和 new：对于使用 new 导致的内存分配问题，C++ 的最新处理方式是让 new 引发 bad_alloc 异常 空指针和 new RTTI运行阶段类型识别（Runtime Type Identification），是新添加的特性之一，旨在为程序在运行阶段确定对象的类型提供一种标准方式 智能指针auto_ptr（不再推荐使用）、unique_ptr 和 shared_ptr 是 C++11 创建出来用于表示指针的类，因为是类从而可以方便地通过析构函数管理释放内存； 使用时需要导入 memory 头文件，几个智能指针类的构造函数都接受一个类型的指针对象（可以使用 new 创建）作为参数来构造，该构造由 explicit 声明，不支持自动转换；位于命名空间 std 中 后续使用时可以和一般指针一样，整体上对释放内存做了优化 unique_ptr 不允许两个对象指向同一个内存地址，即在编译阶段拒绝了此类操作；但是当函数返回 unique_ptr 对象时允许将其赋给新声明的对象，随后快速销毁函数返回的临时 unique_ptrshared_ptr 则允许"},{"title":"Cpp容器类","date":"2022-03-28T00:38:55.000Z","url":"/2022/03/28/C++/Cpp%E5%AE%B9%E5%99%A8%E7%B1%BB/","tags":[["cpp","/tags/cpp/"],["containers","/tags/containers/"]],"categories":[["Cpp","/categories/Cpp/"]],"content":"本来想自己分组，但是 cppreference 上已经有很完善的总结了，在此只记录一些实现原理和常用接口 前注size_tsize_t 是一些 C/C++ 标准在 stddef.h 中定义的，用来表示对象的大小，是无符号整数（而 int 是带符号数，固定四个字节），其实际类型根据操作系统有所不同： 在 32 位系统中 typedef unsigned int size_t；在 64 位系统中 typedef unsigned long size_t 在实际使用中最好完全区分开 size_t 和 int ，凡是对容器进行遍历都使用 size_t 来声明，例如 通用非成员函数 for_each ：传入区间首尾迭代器以及对每个迭代器要进行操作的函数对象，逐元完成该函数操作 random_shuffle ：传入区间首尾迭代器，随机排列该区间中的元素；要求容器支持随机访问 sort ：传入区间首尾迭代器，使用容器中类型的 &lt; 运算符来升序排序；要求容器支持随机访问；有重载方法可以再传入一个比较函数的指针（即函数名） 顺序容器主要特征有如下 其内元素按照严格的线性顺序排列，可以通过位置访问对应元素 通常实现为动态数组，允许直接通过位置访问元素 使用分配器对象来动态处理其存储需求 迭代器的非法化：指的是之前创建的迭代器由于对容器的一些其他操作而失效的现象，暂时记不住 array 数组是封装固定大小数组的容器，通常直接用 T[N] 而不需要该容器 vector 向量是封装动态数组的顺序容器，连续存储元素，空间随加入元素动态地检查扩容，平均上认为插入是常数复杂度 几个常见操作复杂度： 随机访问 —— O(1) 在末尾插入或移除元素 —— O(1) 其他插入或移除 —— O(n) 几个常用接口： [] / at() / front() / back() ：取索引和首尾元素操作 empty() / size() / clear() ：现有大小检查及清空操作 insert() / erase() ：向指定位置添加或移除 push_back() / pop_back() ：向末尾添加和移除 swap() ：交换两个容器的内容 deque 双端队列是有下标顺序数组，其内部元素非连续存储，而是多次分配固定大小的数组并用额外的信息记录数组的序列，操作复杂度略优于 vector 常用接口也和 vector 基本一致，只是多了 push_front() 和 pop_front() forward_list 前向列表是支持从容器中的任何位置快速插入和移除元素的容器，不支持快速随机访问，内部用单链表实现 几个常用接口： begin() / end() ：使用迭代器来访问元素 insert_after() / erase_after() / push_front() / pop_front() ：在指定元素后一位或总体首位进行插入、删除操作 sort() / merge() ：排序、合并两个已排序链表 reverse() ：翻转链表 unique() ：删除连续的重复元素 list 双向列表同上但是用双链表实现，接口基本一致，只是增删改为 insert() / erase() / push_back() / push_front() 关联容器能实现快速查找（O(log n)）的数据结构 set 集合是含有 Key 类型对象的已排序集，通常以红黑树（to be linked）实现 常用接口： begin() / end() ：可以使用迭代器访问元素 insert() / erase() ：插入和删除 count() / find() / contains() ：查找元素 multiset 可重复集同上但允许多个元素值相同，接口也一致 map 映射是有序键值对容器，元素的键是唯一的，通常实现是红黑树 常用接口： [] / at() ：用前者操作符可以进行访问或插入，后者只能访问 begin() / end() ：迭代器，注意 it-&gt;first 和 it-&gt;second 来获取键和值 insert() / insert_or_assign() / erase() ：进行插入或删除 count() / find() / contains() ：检索 multimap 多元映射允许多个元素有同一个键，接口一致，（不常用）一个对应多个元素的键其值以 无序关联容器元素的实际存储位置和存入顺序无关，并不以任何特别顺序排序，而是组织进桶中，由哈希检索。搜索、插入和移除都具有常数级别的复杂度 unordered_set是含有 Key 类型唯一对象集合的关联容器，不可修改容器元素 常用接口同 set，同样有 unordered_multiset unordered_map含有带唯一键的键-值 pair，三种操作平均常数时间复杂度 接口同 map，同样有 unordered_multimap 适配器基于已经实现的容器进行封装来实现常用的数据结构功能 stack 栈默认使用 deque 做内部实现，对外接口有 top() / empty() / size() / push() / pop() queue 队列默认使用 deque 实现（没啥必要使用），对外接口有 front() / back() / empty() / size() / push() / pop() priority_queue优先队列提供常数时间的（默认）最大元素查找，对数代价的插入与删除；其比较规则 Compare 提供严格弱序的比较，当第一参数在弱序中先于第二参数则返回 true，（例如默认的 less 规则，当第一参数较小时返回 true）然后优先队列输出最大元素，也即排在最后的 常用接口（对外是队列，只有进出）： top() / empty() / size() / push() / pop()"},{"title":"Linux命令速查手册速查手册","date":"2022-03-21T14:12:40.000Z","url":"/2022/03/21/Linux/Linux%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/","tags":[["tips","/tags/tips/"],["smp-cmd","/tags/smp-cmd/"],["linux","/tags/linux/"]],"categories":[["Linux","/categories/Linux/"]],"content":"Linux 的常用命令有很多，网上的速查表内容也很丰富，在此仅记录一些最常使用需要记住的命令，用的比较少的就现查好了 通用技巧参数使用 同时指定一个命令的多个参数选项时，直接用缩写写在一个 - 后面即可，如 ls -la 在用命令行执行 shell 脚本时，指定脚本后用 --param 传入参数给脚本；该脚本内部可能调用其他脚本，使用 -- -- param 可以给深层脚本传参数，是一种穿透传参方法 管道命令对于有输出的命令，都可以使用 | 后接其他命令直接处理前者的输出，形成一条管道式命令流，例如 cat mydoc.txt | grep &quot;today&quot; 找到最近启动的进程并杀死（暂未验证） 重定向同样涉及到输出内容，可以直接指向文件来完成写入 文件管理文件管理中总是牵涉到目录的定位，可以使用通配符来广泛定位 ls 列出目录下文件short for list；格式为 ls [参数] [目录]，常用参数有 -a ：显示包括以 “.” 开头的隐藏文件 -l ：长格式显示，包含一些其他信息 -t ：根据最后修改时间顺序 -R ：递归列出所有子目录（后续很多目录相关操作都可用 R 进行递归，下略） cp 复制文件和目录short for copy；格式为 cp [参数] [目录fs] [目录t] ，可以多个目录到单个目标位置，常用参数有 -f ：若目标目录存在则会覆盖 -i ：若目标目录存在则会询问（ i 通常表示交互式，即有异议的操作会询问，下略） -p ：保留源文件或目录的所有属性（如权限） -s ：目标处建立软连接 -v ：详细显示 cp 命令执行的过程（用于默认看不到的命令，可以看到过程，下略） mkdir 创建目录short for make directories；mkdir [参数] [目录s] ，可同时创建多个，若已有重名会提示且不创建 -p ：递归创建多级目录，若不加则必须父目录存在 -m ：创建的同时设置目录权限，在参数后用 三个整数 指定，如 -m 700 touch 创建空文件对应的创建文件的命令为 touch，实际上是访问文件，若不存在则创建 ln 创建连接文件用于为某一个文件在另一个位置创建同步的连接而无需复制一份；格式为 ln [参数] [dfs] [dfs]，具体连接形式分为软链接和硬链接 软链接： 以路径的形式存在，类似于快捷方式 可以跨文件系统 可以对一个不存在的文件名进行链接 可以对目录进行链接 硬链接： 以文件副本形式存在，但不占用实际空间 不允许对目录创建 只能在同一个文件系统中 命令参数： -b ：覆盖之前建立的链接 -i ：交互，若存在则询问是否替换 -s ：创建软链接 mv 移动或改名short for move；mv [参数] [目录f] [目录t] -b ：当文件存在时，覆盖前为其创建一个备份 pwd 显示当前路径略，直接用就行 find 文件检索格式为 find [path] [参数] 若不传入 path 则在当前目录下检索；具体使用时参数非常多，仅列出几个比较常用的 -amin n ：在过去 n 分钟内被读取过的文件，对应有 -cmin n 表示过去 n 分钟内被修改过，下同 -anewer file ：比 file 更晚被读取过地文件 -atime n ：过去 n 天内被读取过的文件 -name str、-iname str ：按照正则字符串匹配文件名，后者忽略大小写 rm 删除操作用于删除目录或文件，要谨慎定位删除的目标； -f ：强制删除 -i ：删除每个文件前询问 -r ：递归删除 文档编辑浏览较大文件内容时 Ctrl + S 可以暂停滚屏，再按 Ctrl + Q 回复 cat 获取内容获取文件的所有内容，用于浏览小文件；cat [参数] [文件] -n ：输出同时对行编号，每个空行算一个，其他还有不同的空行处理如 -s、-b -E ：每行结束处显示 $ 符号 结合重定向有较多的操作 head、tail 分别显示头部和末尾默认显示 10 行；若指定多个文件会对每个文件用名称标题 -c &lt;N&gt; ：输出文件尾部的 N 个字节内容 -n &lt;N&gt; ：输出末 N 行内容 more、less 分别按页显示文本文件略 echo 输出内容可以用于输出字符串或变量内容；echo [参数] [字符串]，输出变量内容时要 $var 来调用，否则不认为是一个变量（在命令行中使用时仅处理系统全局变量如 $PATH ，更多的在 shell 脚本中使用） -e ：字符串中允许转义，如 “\\n” 换行，”\\b” 删除前一个字符 -E ：禁止转义 grep 文本检索“global search regular expression and print out the line”；全面搜索正则表达式并打印输出，grep [参数] [匹配符] [文件s] [目录] 可以从指定目录下的文件中打印出包含内容的行；或者结合管道命令使用 -i : 忽略大小写 -c ：只输出匹配行的数量 -w ：有匹配词就输出行 -x ：要求整行匹配才输出 sort 排序输出将文本的行排序，默认以行首字符的 ASCII 码升序，参数比较多 -b ：忽略每行前面的空格字符 -d ：仅处理字母、数字及空格，其他字符忽略 -f ：将小写字母视为大写 -n ：依照数值大小排序 -o &lt;tf&gt; ：将结果输出到指定文件 -r ：逆序排列 -t &lt;dc&gt; ：指定每列的分割字符 +&lt;l&gt;-&lt;r&gt; ：指定用于排序的列范围，左闭右开 -k &lt;N+&gt; ：指定几列来排序（从 1 开始计数） 系统管理top用于实时显示 process 的动态，会持续更新至手动终止或预设时间；格式 top [参数] -n &lt;N&gt; ：进行 N 次更新后结束 -d &lt;N&gt; ：设置更新周期为 N 秒 -p &lt;proc&gt; ：监控指定进程号的进程 psshort for process status，用于显示当前进程的状态；ps [-options] -A ：列出所有的进程 -au ：显示较详细的资讯 -aux ：显示所有包含其他使用者的进程 输出格式 USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMAND -e ：显示当前运行的每一个进程信息 -f ：显示一个完整的列表 kill用于终止执行中的进程，指定信息编号和进程号等，常用三种信息编号 1 (HUP) ：重新加载进程 9 (KILL) ：强制杀死一个进程 15(TERM) ：正常停止一个进程 杀死指定用户所有进程 alias在一次登录周期内设定指令的别名；若要持续作用则可在 .profile 或 .cshrc 中设定；可以把一些较危险的命令给改掉 alias lx=ls ：则 lx 现在和 ls 等效 其他常用tar 压缩及解压虽然 linux 上也可以使用 zip 格式压缩文件，但实际上更多地接触 tar 格式压缩文件，其根据具体压缩方法有三种分类：.tar、.tar.gz、.tar.bz2；使用格式为：tar [参数] [dfs] [dfs] -c ：进行归档，左侧目录归档至右侧目录下，单参数不进行压缩 -x ：解压缩 -z ：以 gzip 形式压缩，要结合 -c -j ：以 bzip2 形式压缩 -v ：显示过程 -f ：使用档名 "},{"title":"Python网络爬虫（1）","date":"2022-03-20T01:17:19.000Z","url":"/2022/03/20/Web-Crawler/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%EF%BC%881%EF%BC%89/","tags":[["https","/tags/https/"],["python","/tags/python/"]],"categories":[["Web-Crawler","/categories/Web-Crawler/"]],"content":"所谓爬虫就是用代码去模拟真人浏览网页的过程，向公开网站发起 request 并获取到网站的返回信息，加以一定的提取最终得到我们所关注的；通常爬虫获取到的信息包括前端展示的完整静态页面和后端允许通过身份验证获取到的信息。 综上，学习爬虫技术需要对 网络协议、前端编码、python 编程 有一定的了解，本篇先大致记录 协议 以及初等的 request 模块使用 http 协议是服务器与客户端进行数据交互的一种形式，规范了双方进行交互的格式和一些遵循的规则 常用响应头 User-Agent：请求载体的身份标识 Connection：请求完毕后，是断开连接还是保持连接 常用请求头 Content-Type：服务器响应回客户端的数据类型 https 即是加上一条 Security，其采用证书密钥加密来确保安全性 requests 模块python 中原生的一款基于网络请求的模块，可以模拟浏览器发起请求，使用流程为： 指定 url 地址 调用方法发起请求 获取响应数据存储到变量 持久化存储到本地文本 "},{"title":"unity游戏开发（2）","date":"2022-03-16T15:56:00.000Z","url":"/2022/03/16/Unity/unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%EF%BC%882%EF%BC%89/","tags":[["入门介绍","/tags/%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/"],["游戏脚本","/tags/%E6%B8%B8%E6%88%8F%E8%84%9A%E6%9C%AC/"]],"categories":[["Unity","/categories/Unity/"]],"content":"区分于游戏的基本元素，所有的动态交互行为都由脚本负责完成 推荐在 Assets 资源目录下创建 Scripts 目录专门保存脚本，根据功能不同还可以继续深入目录层级 脚本 API 脚本使用醒目注意 Unity 中一般使用 float 而非 double，在脚本中指定参数时要使用 f 结尾，如 0.8f 脚本也是对象的一个组件，因此一个脚本文件中的 this 总是指向该组件，要获取实际的对象使用 this.gameObject 脚本构成创建一个 脚本文件 后会自动继承 MonoBehaviour 父类（规定所有脚本都需要），其中会自带一些必须要覆写的事件方法 void Start() : 脚本初始化（在第一帧更新之前）时会执行一次 void Update() : 每一帧都会调用一次，Unity 会尽可能快地刷新游戏，但帧率基本不固定 public 属性可以在外部访问，在其上一行追加 [ Tooltip(&quot;tip paragraphs&quot;) ] 可以补充注解以便外部理解变量 脚本挂载选中对象后在其 Inspector 中增加组件可以挂载脚本；或者直接拖拽完成；同一个脚本可以挂载到多个对象 脚本中的 public 属性可以直接在 Inspector 内修改其值；private 属性则不能访问 属性可以设置为数组，如 public AudioClip[] songs;，在外部可增删内容 属性可以设置为图片资源、游戏对象等引用类型，并且也在此处修改；可以在 Editor 中拖拽赋值 一个挂载好的脚本也是一个组件（类对象），可以同组件的方法访问和操作 脚本调试可以使用 Visual Studio 的断点调试，连接到 unity 进程实现运行过程中的调试，步骤如下 在 VS 中添加断点，然后在上方选择附加到（Attach） Unity 进程 在 Unity 中运行，由该进程执行脚本调用 在 VS 中逐步调试；完成后点击停止调试（Detach）可以断开连接，Unity 仍正常运行 脚本常用命令因为 C# 的语法也像 C++ 一样有命名空间，在此用这个分组来记录常用功能，对应功能的使用需要在变量名前加上或者在文件头部加上 using ...; 对象获取及修改操作挂载对象this 变量总是指向该脚本挂载的对象，也像类内部编写一样可以在无歧义时省略，可以调用其 GetComponent 方法来获取并实例化其组件，其中涉及到泛型，例如 创建对象：一般基于绑定预制体调用 Instantiate 函数创建 销毁对象：GameObject.Destroy(this.gameObject); 传入一个对象来销毁 获取任意对象 按照名字来获取对象： 获取当前的父、子对象由于 Unity 中与位置有关的操作都是相对于一个父对象的（默认画布对象），因此获取父子对象都在 transform 中实现 坐标与旋转UnityEngine 模块中有数据类型 Vector3 用于表示一个三维向量 一个对象的坐标存储在 position 中，Euler Angles 是三维欧拉角度（界面内的 rotation 是四维的，比较复杂）；欧拉角度各个维的值表示以相应轴逆时针旋转角度 以上修改都是世界坐标；本地坐标则是以父节点中心展开坐标系来计算，变量以 local 开头：transform.localPosition; 补充：transform.LookAt 可以直接转向某一个物体的方向，实际是让物体的 z 轴指向目标 调用 transform.Rotate 方法也可实现旋转，传入三个方向上所需的旋转角度值以及可以选的参考系；其中角度可以由向量运算 以上的旋转都是物体自转；而对一个父对象自转 物体运动调用 transform 组件的 Translate 方法；通用地传入三值坐标以及可选的参考坐标系 事件处理鼠标事件处理所有的 Unity 脚本都是继承自 Monobegaviour 类，而需要绑定对鼠标事件响应的功能时，可以覆写几个函数完成；部分事件的触发随 3D 和 2D 有所区别： OnMouseEnter：鼠标移入 GUI 控件或者碰撞体时调用 OnMouseOver：鼠标停留在 GUI 控件或者碰撞体时每帧调用 OnMouseExit：鼠标离开 GUI 控件或碰撞体时调用 OnMouseDown：鼠标在 GUI 或碰撞器上按键按下时调用 OnMouseUp：鼠标按键释放时调用 OnMouseDrag：当鼠标在 GUI 或碰撞器上按下并保持拖拽时每帧调用 OnMouseUpAsButton：仅当在同一 GUI 或碰撞体上按下鼠标然后松开按键时调用 补充：另外可以使用 Input 类来捕获外部的输入，其中就包括捕获鼠标、键盘输入，此内容在 Unity Engine 中简述 键盘事件处理参考下方 Input 类内容 通用脚本事件系统主动调用的事件函数： Awake()：初始化时调用；即使脚本组件被禁用也仍会调用 Start()：初始化时调用；被禁用时不会调用 Update() FixedUpdated() 余下的都在具体事件发生时回调，可以分为脚本文件本身的事件和脚本绑定对象的事件 脚本本身： OnDestroy：脚本销毁时调用 绑定对象： OnBecameVisible：对于任意一个相机可见时调用 OnBecameInvisible：对于任意一个相机不可见时调用 OnEnable：每当对象启用或者激活时调用一次 OnDisable：对象禁用或者取消激活时调用 延迟调用Invoke 相关函数实现延迟调用函数，是 MonoBehaviour 已经实现的方法，可以直接执行 Invoke(func, secs) ：传入函数名字符串，要求至少有一个无参的重载；第二个参数是等待的时间 InvokeRepeating(func, wait, gap) ：等待后重复调用 IsInvoking(func) ：检查是否已经在延迟调用；用于避免重复 CancleInvoking(func) ：若不传参数则取消全部 碰撞检测有两种碰撞检测：1. 物理学的碰撞检测 Dynamic 刚体；2. 运动学的碰撞检测 Kinematic 刚体（例如设置为自机） 一般需要为对象的 RigidBody 组件勾选 Kinematic 并为 Collider 组件勾选 Trigger 来启用 挂载脚本覆写 OnTriggerEnter / Stay / Exit(Collider obj) 来编写响应逻辑（对 2D 游戏有专门的 OnTriggerEnter2D 和 Collider2D 类） obj.GameObject 等属性可以访问到发生碰撞的对象 补充：通常对场景中的不同对象在 Inspector 中添加 Tag 来实现分组，方便如碰撞检测时执行不同的操作 常用模块UnityEngine核心类（MonoBehaviour 和 GameObject）MonoBehaviour 是所有 Unity 脚本的父类，其大多数方法用于覆写来提供给引擎调用 Invoke：用于延迟调用方法，传入方法名的字符串和等待的秒数；相关的还有 IsInvoking、InvokeRepeating 等 GameObject 则是 Unity 场景中所有实体的基类，在脚本中访问其他对象以及其组件都可以经过该类 操控游戏主控对象：通常可以创建一个不带其他资源的对象来记录游戏得分、时间线等信息，此时使用一个脚本来保存和修改各个属性；调用脚本类的方法有两种（推荐后者） 获取到脚本组件然后调用公开方法 调用 GameObject 实例的 SendMessage 方法，实现消息调用 SendMessage 方法查找目标方法并执行：1. 遍历该对象上所有的 MonoBehaviour 组件； 2. 检查该组件上是否有目标方法； 3. 如果有此方法则执行（没找到则报错） 内置类 向量类对象：包括 Vector2、Vector3 等 new Vector3(0, 0, 0); 创建对象 x、y、z 直接访问属性；magnitude 长度属性 normalized 返回归一化对象 Vector3.up、right、forward 创建指定方向的静态常量对象，分别 y、x、z 轴向；可以在计算旋转角度时使用 重载了 + - 和标量 * / ；另有 Dot 、Cross 静态运算方法 静态方法 SignedAngle 和 Angle 计算旋转角度 屏幕对象： Screen Screen.width 和 height 返回整型的像素值 获取相对屏幕的坐标（左下角为 0,0） 输入捕获对象： Input 鼠标动作捕获（静态）方法，通常接受整型参数 0 表示左键、1 表示右键、2 表示中键 GetMouseButton() 对应按键处于按下状态持续为 true GetMouseButtonDown() 对应按键按下单帧为 true GetMouseButtonUp() 松开对应按键时单帧为 true 键盘动作捕获方法：其中的 key 有如 KeyCode.LeftArrow 等，用到时智能补全即可 GetKeyDown(key) 按下帧触发一次 GetKeyUp(key) 抬起帧出发一次 GetKey(key) 处于按下状态时持续触发 游戏对象： GameObject activeSelf 检查当前对象是否处于激活状态的属性；SetActive(bool) 进行修改 Application全局变量 targetFrameRate : 给出固定值则全局尽可能以此帧率 Time time ：当前游戏时间，从 0 开始计 deltaTime ：显示距前一次执行的时间差 Random Range(left, right) ：随机数 "},{"title":"面试知识点-数学","date":"2022-03-15T08:11:32.000Z","url":"/2022/03/15/Interview/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9-%E6%95%B0%E5%AD%A6/","tags":[["interview","/tags/interview/"],["mathematics","/tags/mathematics/"]],"categories":[["Interview","/categories/Interview/"]],"content":"统计知识条件概率 P(B|A) = \\frac{P(AB)}{P(A)}全概率公式：对一组互斥事件 Bj 满足其和构成全空间（事件构成分划），有 P(A) = \\sum^n_{i=1} P(B_i)P(A|B_i)贝叶斯公式：同样是一组分划 Bj，结合上面两个公式有 P(B_i|A) = \\frac{P(AB_i)}{P(A)} = \\frac{P(B_i)P(A|B_i)}{\\sum_i P(B_i)P(A|B_i)}假设检验统计模型 数据统计模型：数据分类或评估 回归模型：即连续变量预测问题 主成分分析：通过线性变换整合相似分布的样本特征，也是一种常用的特征降维方法 因子分析 层次分析法（AHP）：不了解 系统聚类分析：也即聚类方法，将样本按照特征相似性聚类 分类模型：多分类问题，可以由二分类衍生，或者如决策树、神经网络等天生多分类 判别分析：即二分类模型，从样本特征和所属类别中构建判别函数 时间序列：假定事物的过去趋势会延申到未来；通常规律有 长期趋势、季节周期、循环周期、不规则变动 凸优化问题一类在凸空间上求目标凸函数的最值问题，可以认为是最简单的最优化问题，其中定义有： 凸空间：任意空间中两点 x、y 均有 t*x + (1-t)*y 仍为空间中的点，其中 t 在 (0,1) 范围取值 凸函数：严格凸函数要求 $f(tx+(1-t)y) \\lessequal tf(x) + (1-t)f(y)$ ，即函数在区间中间的取值总是不大于区间端点值的加权均值；非严格（几乎凸）函数则仅要求 $f(z) \\lessequal \\max{f(x), f(y)}$ 常用的求解方法 对于凸函数可微情况，通常使用 梯度下降法 或 牛顿法 牛顿法：对 f(x) = 0 近似地求根，确定一个初始值 $x0$ ，在函数该点处做切线 $L:y=f(x_0)+f’(x_0)(x-x_0)$，取切线与 x 轴的交点 $x_1$ 即为下一轮的迭代值；总体迭代公式为 $$x{n+1} = x_n - \\frac{f(x_n)}{f’(x_n)}$$ 对于不可微情况，可以考虑 次梯度法 或 内点法 次梯度法：核心是类似梯度下降的迭代方法 $x^{(k+1)} = x^{(k)} - \\alphak g^{(k)}$，当目标函数可微时即退化成一般的梯度下降法；当不可微时可能采用一系列的辅助来追踪目标函数的极小值点，即 $f^{(k)}{best} = \\min{f^{(k-1)}_{best}, f(x^{(k)})}$ 步长选择：为了确保收敛性，通常有几种步长的选择方法 —— 恒定步长、恒定更新间隔、步长平方可加（平方和收敛）但步长不可加、步长不可加但步长递减、间隔不可加但间隔递减 计算几何线性代数 特征值：对 n 阶矩阵 A 其特征值计算方式为求解 $Ax = \\lambda x$ ，其中 x 为非零向量 计算方法：转为 $(\\lambda E - A)x = 0$ 为齐次线性方程组，解出特征值并对应特征向量，构成基础解系 奇异性：可逆方阵也称非奇异矩阵；矩阵非奇异当且仅当行列式不为零；矩阵非奇异当且仅当其线性变换是一个自同构 正定性：矩阵正定当且仅当其每个特征值都为正；半正定当且仅当特征值非负 数学建模流程：模型准备、模型假设、模型建立、模型求解、模型验证、模型应用 实际操作中，第一阶段主要明确问题目标和相关约束，即模型应当解决什么问题，且不能违背什么条件；第二阶段主要进行数值和表达式的构建，形成所有表达式之间的关系网；第三阶段寻求有效的方法来求解优化目标或其他目标；然后验证效果、应用结果"},{"title":"Numpy-Intro","date":"2022-03-11T08:48:18.000Z","url":"/2022/03/11/Data/Numpy-Intro/","tags":[["Pre-Process","/tags/Pre-Process/"],["Numpy","/tags/Numpy/"],["数据分析","/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"]],"categories":[["Data","/categories/Data/"]],"content":"虽然说是 intro ，但是准备把常用指令都存进来并且后续应该懒得补充深入的内容了 核心功能 ndarray，一个具有矢量算术运算和复杂广播能力的快速且节省空间的多维数组。 用于对整组数据进行快速运算的标准数学函数（无需编写循环）。 用于读写磁盘数据的工具以及用于操作内存映射文件的工具。 线性代数、随机数生成以及傅里叶变换功能。 N 维数组 ndarray一个 numpy 内最重要的类，具有更快的计算速度和更多的操作；能匹配列表的索引、切片，还有其他的方法 创建 np.array(li) ：将列表变量转为 ndarray 对象 np.zeros(size) / np.empty(size) ：用零值或任意值填充初始化，还有 np.ones() / np.full() np.arange() ：用法同原来的 range，只是返回 ndarray 对象 np.eye(n) / np.identity(n) ：对角单位阵 对象属性 data ：返回数据地址，是一个指针（虽然没有指针类型） ndim ：几维 size ：总元素个数 shape ：数组大小，返回有几个数就是几维 dtype ：存储数据类型，是 numpy 中描述的类型，如 float64 T ：返回转置 类方法 取索引的递进索引和矩阵索引是等价的，即 arr[0][2] 和 arr[0,2] 等价 布尔索引：传入一个和数组的轴长度一致的布尔数组来进行索引，如 data[names == &#39;Bob&#39;]，可以配合数值索引、切片来递进实现定位，在传入的布尔数组前加上 ~ 取反，还能结合 &amp; 和 | 取与、或 花式索引：传入一个整数数组可以取出数组中对应索引的轴向子数组 astype() ：转换存值类型 reshape() ：变换尺寸，如 np.arange(15).reshape((3,5)) 运算 np.sqrt() ：开根号，传入数组自动广播 np.exp() ：求指数 np.maximum(x, y) ：各元比较后返回较大值的数组 np.dot(arr.T, arr) ：进行矩阵乘法运算 随机数有关随机数的基本都在 np.random 中，如 np.random.randn(2,3)"},{"title":"Python-Tricks","date":"2022-03-11T07:49:11.000Z","url":"/2022/03/11/Python/Python-Tricks/","tags":[["tips","/tags/tips/"]],"categories":[["Python","/categories/Python/"]],"content":"一些小细节浮点数 写法如：1.23e9、1.2e-5表示科学计数法 除法 / 永远得到浮点数，希望得到整数只能用地板除 // 字符串操作 strip() ：默认返回原串移除两端空格后的复制，若传入字符参数则会移除每个匹配的字符 元组 元组是不可变的对象（实际上是指向不可变），但可以对其存储的可变对象进行修改 变量拆分：在进行变量赋值时 python 可以识别出左侧变量的数量来对右侧的类数组变量拆分赋值，还能用 *a 结合普通变量来接收多个值变成列表 使用 .count(v) 来返回计数 列表 列表允许内部元素不同 插入操作用 .insert(idx, var) 实现，插入的元素索引为 idx .pop() 默认移除末尾，可以传入索引；.remove(v) 找到第一个元素移除 用 + 运算符或 .extend() 方法可以前后拼接列表 .sort() 方法原地排序 字典 作为 字典键 的对象必须是不可变对象，如字符串、整数、元组 key1 in dic 可以判断是否有键避免报错，或者用 dic.get(key1, 0) 取值或默认值 .update() 方法可以更新（合并）字典 .pop(key1) 可以删除键值对 集合 增删 adc / remove 及取交、并 &amp; / | 方法如 union / intersection / difference / issubset 等 random 模块函数import random as rd rd.random() ：浮点数 0&lt;=n&lt;1 rd.uniform(a,b) ：浮点数左右闭 rd.randint(a,b) ：整数左右闭 rd.randrange([start], stop[,step]) ：构建一个有步长的序列再随机取一个 rd.choice(seq) ：从序列中随机取一个，和上一条类似 rd.shuffle(x[,random]) ：洗牌 rd.sample(seq,k) ：抽样（应该是不放回） 函数综合可以不传入的参数对于调用时可以不传入的参数，必须要写在函数定义中参数组合的末尾，避免占用位置参数 默认参数：函数定义的时候可以在最后定义默认参数，最好使用不变对象，因为并非每次调用都重新创建默认参数的变量，而是创建一次后持续使用 可变参数：定义时使用 *args 可以接受多个参数传入，或者接受一个 list 或 tuple 对象但是加上 前缀，如 `func(nums)` 关键字参数：定义时 **kw，调用时可以直接传入键值对 func(city=&quot;Tokyo&quot;) 或者前缀 ** 传入字典对象 func(**dic)，在函数体内是使用一个字典 kw[&#39;city&#39;] 命名关键字参数：对于上面的关键字参数本身未限制数量，但可以如下定义来限制仅传入几个关键字 def func(a, b, *, city=&quot;ZJ&quot;, job) ，在 * 后面的参数属于关键字参数，可以预设省缺值 "},{"title":"Matplot-Intro","date":"2022-03-07T13:47:05.000Z","url":"/2022/03/07/Data/Matplot-Intro/","tags":[["Pre-Process","/tags/Pre-Process/"],["数据分析","/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"],["Matplotlib","/tags/Matplotlib/"]],"categories":[["Data","/categories/Data/"]],"content":"移植自 matlab 的绘图包，其他的大多数 python 绘图包操作都基本和此包类似，在此简要摘录一些经常会用到的功能，以及补充不时遇到的需求 以下内容均 常用功能图表属性内容边框和刻度 子图绘制通常会期望将几个图相邻而非重叠显示，使用创建子图来实现 plt.subplot(xyi) 指定 x、y 表示创建尺寸为 x，y 的二维图数组，编号为 i （从 1 开始） subplots 函数顺序返回了画布和子图数组对象，通常用两个变量存值 subplot2grid 函数可以按照需求给出子图布局，将一部分的子图连起来，传入画布整体的尺寸和子图的索引位置 补充说明在图上补充一些标题、图例等。从子图绘制的逻辑可以发现，在 plot 后会指向一个绘制出的子图对象，此时调用 plt.xlabel 等函数也即对该子图对象进行标签补充，具体常用的补充函数如下： xlim 、 ylim ：指定坐标轴的范围，可以限定显示范围 xticks 、yticks ：指定坐标轴的刻度 plt.xlabel(‘x axis value’) plt.ylabel(‘y axis value’) plt.title(‘graph title’) 指定轴名称和图名称 plt.text(x, y, ‘text in graph’) 在图内指定坐标位置加入文本 plt.grid(True) 显示网格，具体网格大小应该还有细化参数 plt.annotate() 添加箭头，感觉影响观看，不加最好 plt.legend(loc=’best’) 根据绘制时的 label 添加图例 图表风格 线性绘制平滑点线基础绘制 调用 plt 的函数 plot() 来实现最容易的绘制，传入 x, y 参数等长度实现线性绘制，可用参数包括： color=&#39;green&#39;, marker=&#39;o&#39;, linestyle=&#39;dashed&#39;, linewidth=2, markersize=12 plt.plot(x, y, &#39;ro--&#39;) 相当于 红色、圆点标、虚线绘制，其他简写可以类似地实现 数据源绘制 plt.plot(&#39;xlabel&#39;, &#39;ylabel&#39;, data=obj) 指定数据源（如 DataFrame ）传入 x、y 为标签名 条形图绘制通常可以用于观察不同分组下的数据分布情况 基础绘制定位到单个图对象调用 bar() 或 barh() 方法分别绘制竖直和水平条形图，两个方法会返回绘制出的每个直方体图对象，可以遍历来各自设置 可用功能：条形图绘图完成后对超过某个值的直方体用其他颜色突出 可用功能：补充水平或竖直线来表示阈值分割 ax.axhline(val, color…) 可用功能：基于压缩循环可以在每个条形的上方用 ax.text 加上数值或比例注释 参考示例 参数补充 width ：每个条形的宽度 xerr, yerr ：传入相同 size 的 arr-like 对象，表示方差范围 盒图（箱线图）绘制一种显示数据的中位数和左右两个四分位数的图表，以四分位数为两端构成矩形，再往外虚线衍生至两个离群边界打上短横线，有几个相关的描述术语 极差 IQR：两个四分位数的差的绝对值 离群边界：如 75% 分位数加上 1.5 IQR 或 25% 分位数减去 1.5 IQR 类似的有 violinplot() 图，可显示中位数（均值等可选）和数据实际边界，并且宽度随数据的密集程度变化 基础绘制调用 boxplot(data, notch=False, sym=&#39;s&#39;, vert=True) 函数进行绘制，自行统计 notch ：盒子形状，一般不要改，比较丑 sym ：表示离群点（若有）用什么表示，指定 ‘s’ 表示用方框 square vert ：表示是否竖直绘制 参考示例 直方图绘制将大致连续的数据分线统计数量的条形图，用 plt.hist(data, bins) 绘制，其中 bins 可以用 np.arange(l, r, step) 来实现 参考示例 散点图传入相同大小的 x、y 坐标，用 plt.scatter() 绘制 参考示例 饼图使用 plt.pie() 传入各个比例构成的数组或者由接口自行计算比例（其实不推荐，因为感知上对角度的辨识本身就弱于长度） 参考示例 其他功能Color Map按照数据分布渐变地生成颜色 嵌套图实现如大图上堆叠显微图的绘制，在画布对象上调用 add_axes 方法指定四个边界位置来获取新的子图对象 3D 图表需要创建画布对象并调用函数转换成 3D 画布 结合 pandas 使用对于 pandas 的 Series 对象，直接当作 arr-like 对象使用绘图即可，而对于 DataFrame 对象，则可以适配 plot 方法来实现 mpl 的绘图功能 注意先将 df 处理成适当的格式，即仅保留需要绘图的数据 "},{"title":"排序算法整理","date":"2022-03-05T11:32:51.000Z","url":"/2022/03/05/Alg-Tricks/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/","tags":[["面试","/tags/%E9%9D%A2%E8%AF%95/"],["算法","/tags/%E7%AE%97%E6%B3%95/"],["折磨","/tags/%E6%8A%98%E7%A3%A8/"]],"categories":[["Alg-Tricks","/categories/Alg-Tricks/"]],"content":"排序是一类广受讨论的常见算法问题，性质为将一组数据按照指定的顺序排列好，最常见的排序即对数组进行递增排序。 冒泡排序快速排序一种递归式的排序方法： 给出一个数组和要排序部分的左右边界，从中任意选一个中枢数（一般写法取第一个或最后一个数） 左右两侧指针靠近，直到左指针遇到大于中枢的数，右指针遇到小于中枢的数，然后左右指针的指交换； 直到两指针相遇时，排序区间的左侧都小于中枢，右侧都大于中枢，将中枢值放到指针处，递归地排序左右两侧区间 快速排序的效率很大程度上受到选取 pivot 的影响，例如固定选择第一个数作为 pivot 时，对降序的数组则进行了 O(n^2) 水平的排序；因此考虑到平均效率，通常都会随机生成一个中间索引，和第一个值交换后开始快排 代码示例： 要取随机数可以使用 rand() 产生一个 0 到最大随机数的任意整数，最大随机数通常是系统给的固定较大值 随机选取示例： 归并排序也是一种典型的递归排序法，将数组分为较均的两侧，分别排序后合并，其中被划分的两侧数组递归地调用排序函数即可，具体流程可思考 Carl 的递归（回溯）三部曲: 确定输出和参数：通常需要另一个数组用于在合并的时候比较填入，可以做一个与原数组等长的临时数组全局变量用于填充，或者作为返回参数在每一层递归合并返回的数组 确定终止条件：显然当数组长度不大于 1 时即可结束拆分直接进行合并 完成合并操作：这个没什么好说的，两个指针分别跑，对比填入 代码示例： 上一版借助了足够长的临时数组来用于合并操作；也可以在归并过程中每次复制数组 vector&lt;int&gt; left(nums.begin() + l, nums.begin() + mid + 1); 然后合并返回"},{"title":"算法八股文","date":"2022-03-04T06:34:53.000Z","url":"/2022/03/04/Interview/%E7%AE%97%E6%B3%95%E5%85%AB%E8%82%A1%E6%96%87/","tags":[["eight ass text","/tags/eight-ass-text/"]],"categories":[["Interview","/categories/Interview/"]],"content":"机器学习相关模型问题 CRF 模型对 HMM 和 MEMM 模型的优势有：特征灵活、可容纳较多上下文信息、全局最优 多元线性回归中，极大似然法和最小二乘法： 无明显优劣；仅极大似然有先验假设；极大似然可看作简单的贝叶斯估计 特征降维方法：Lasso、PCA、SVD、局部线性嵌入LLE 数据挖掘 AprioriAll算法和GSP算法都属于Apriori类算法，都要产生大量的候选序列 FreeSpan算法和PrefixSpan算法不生成大量的候选序列以及不需要反复扫描元数据库 和AprioriAll相比，GSP的执行效率比较高 神经网络 卷积大小公式：1 + ( input_size + 2*padding - kernel_size ) / stride = output_size 通常向下取整 padding 指为了保留边缘数据，在输入的四周向外扩张一定的空排用于卷积 kernel_size 即为卷积核大小 stride 步长，一次卷积运算后移动的长度 LSTM 长短记忆网络： 存在三种门结构：forget gate、input gate、output gate 门机制用于控制特征的流通和损失，缓解长期依赖问题 特征选择/降维 常用特征选择方法如：卡方、信息增益、互信息、期望交叉熵 PCA 中将数据转换成零均值得到 SVD 一样的投射 统计知识 Box-Cox 转换是尝试将非正态分布数据转换成正态，不一定得到理想正态结果 大数据组件Spark 任务 Stage 阶段的 Task 数量由 Partition 决定 Hive 框架 sort by 在 mapreduce 的 reducer 阶段进行 计算字段的分位数函数有： percentile(col, p) 函数：严格要求 int 类型字段 percentile_approx(col, p) ：数值类似型均可 数据库设计 数据库模型三范式 1NF：属性具有原子性，不可以再分割（一个字段仅存储一项信息） 2NF：记录的唯一性，要求记录有唯一标识，即实体的唯一性（属性完全依赖于主键） 3NF：要求字段没有冗余，不存在传递依赖，任何字段不能由其他字段派生出来 主键：一个表中可以有 0 或 1 个，主键值不可为空，不可重复 其他杂项Excel 相关 数据透视表：包含筛选字段、数值字段、行字段 VLOOKUP(lookup_value,table_array,col_index_num,[range_lookup]) lookup_value：要查找的值 table_array：查找区域，如 A1:D5 col_index_num：从区域第几列找，小于 1 时返回 #VALUE!；大于总列数时返回 #REF! range_lookup：是否模糊匹配，默认 False，找不到时返回 #N/A；若为 True 则找不到时返回找到的小于目标的最大值 最终返回目标值（找到）或异常值（其他） HLOOKUP 和这个类似，按行查找 "},{"title":"unity游戏开发（1）","date":"2022-03-03T15:34:23.000Z","url":"/2022/03/03/Unity/unity%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%EF%BC%881%EF%BC%89/","tags":[["入门介绍","/tags/%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/"],["基本元素","/tags/%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0/"]],"categories":[["Unity","/categories/Unity/"]],"content":"运行顺序：创建各种资源对象-&gt;生成对象的各种组件（Sprite、Script 等）-&gt;实例化脚本的对象-&gt;调用脚本对象方法 编辑界面： Toolbar 工具栏：修改各类设置以及调用工具 Hierarchy 层级面板：以树状形式显示游戏中的对象 Game 游戏视图：对游戏进行播放预览 Scene 场景视图：以可视化的形式展示游戏内容 Overlays 场景视图辅助工具 Inspector 属性面板：显示资源和游戏对象的属性 Project 项目面板：项目内的资源文件 Console 控制台：用于游戏代码的打印输出调试 Assets 资源目录： Scenes 可以创建场景用于切换 图片、音频、脚本等资源可以直接拖拽进来，或者右击 Import New Assets 对象概念游戏中所有可交互内容都应当做成一个对象，后续通过脚本操作在执行某些键盘按键或交互动作时对游戏对象的参数进行修改，甚至是对象的删除和创建 对象操作： 从资源文件夹内可以拖动置入对象到游戏图层中，不处于摄像机范围内的对象不会被玩家观测到，但应该是占用内存的 左上角可以以不同形式选中对象，用于执行如移动、旋转、缩放等操作 对象的存储并不会黏附到 scene 上，而是存储一些参数和路径指向其资源位置 对象的重命名和删除都可以在 Hierarchy 界面右击来进行，而在游戏进程中则要通过脚本来实现 对象层叠背景图片也是一个对象，因此可以调整层级来掩盖或避免掩盖其他对象，修改对象的层级可以通过两个值的修改实现 order in layer ：越小的值处于越下层 z 值 ：对于 2d 游戏可以直接增大 z 值来远离摄像机，实现降低层级 对象轴心修改对象位置及旋转是在都是以对象轴心做参照，默认轴心点通常都取导入对象图片的几何中心，而对一些扇形对象我们通常不期望这样 修改轴心：选中对象，Inspector -&gt; Sprite Editor 手动修改 / 或者修改 pivot 为 Custom 指定 x、y 的比例（脚本可以这样改） 对象父子关系可以实现修改父对象时同步修改子对象，而修改子对象时则不会变动父对象 Hierarchy 区域拖动对象可实现父子关系定义 对象的坐标及旋转总是相对父对象的坐标来定义的，无父对象的可以当成以完整画布为父对象 空对象可以作为父节点来方便同时对几个平级的对象组织和管理；也可以用于标记位置 摄像机操作：在左侧选中 Main Camera 对象可以在右侧 Inspecor 中修改属性，其中 background 表示范围内没有对象图层时使用什么填充 位置：对于 2d 游戏通常会将摄像头的 z 轴值稍微调值 负值，表示高于当前图层（负值更靠近玩家） 显示尺寸：从 Scene 切到 Game 后修改 Free Aspect 能固定尺寸显示（通常 16：9），否则会根据窗口大小动态调整；配合调整 size 参数来显示不同像素大小的视角 图片素材通常使用 jpg 作为背景素材，使用周边透明的 png 作为对象素材 图片切割偶尔会获取到一张图片上有多个子素材可以使用，此时需要进行分割 选中素材，将 Sprite Mode 修改为 Multiple 打开 Sprite Editor，执行 Slice 切割后 Apply 应用 使用 Sprite 素材 图片渲染Sprite Renderer 本质上是对象的一个 功能组件，负责对象的显示内容，可以直接进行拖拽修改 组件右击 Scene 可以选择新建空对象然后添加功能组件，或者直接置入素材来形成一个预设的带组件的对象； 选中对象后可以在 Inspector 中加挂/移除组件 交互界面 UIUser Interface 用户交互界面 ；Unity 中的 UI 称为 UGUI GUI 技术都是类似的：标准控件、布局、事件响应、自定义控件、控件的更新等 与 UI 相关的对象都可以在 Hierarchy 中右击的 UI 选单中选择并创建 添加 Canvas 画布选择 Canvas，会创建一个画布对象和一个 EventSystem 对象 位置选择：一般修改 RenderMode 为 Screen Space - Camera 并将主摄像机添加到 Render Camera 中，实现 UI 总是在摄像机镜头内 画布元素：后续的如说明文本、按钮等都应当添加到画布的子对象，这样方便一次性激活和隐藏画布来完成 UI 变化 画布常用元素 Text 文本元素：可以修改字体、颜色等；勾选 BestFit 可根据矩形自动调整字体大小；字体资源支持 ttf 和 otf，同音画资源 Image 图片元素：创建对象然后绑定图片资源来完成显示（一定先创建画布的子对象） 填充类型：Simple 拉伸、Sliced 九宫格（限制仅拉伸中心区域）、Tiled 平铺、Filled 充满 Button 按钮元素：可以设置如鼠标悬停时的图像资源显示 InputField 输入域元素：支持用户进行文本输入 Panel 面板：相当于画布上的子图 UI 事件处理 使用 Button 组件：通常创建一个空对象来挂载脚本，脚本中自定义完整的空参数函数，然后对一个按钮对象，找到其 OnClick 部分增添一段，将创建的对象引用后再选择需要调用的方法 使用其他元素：需要挂载脚本并继承某一类接口，如 IPointerDownHandler 然后覆写相应的方法 OnPointerDown；此方法可以用于挂载多个不同事件的响应，只要继承多个接口并覆写方法即可 UI 界面布局基本上 UI 元素都持有 Rect Transform 组件，其是一般对象的 Transform 组件的子类； 元素位置默认相对于 Canvas 的中心，修改那个方框即可；实际上相对位置是修改 Anchors 完成的，但是操作上可以直接由视觉定位来完成，具体数值由 Unity 修改 音频资源游戏中的声音一般分成几类： 音乐：例如场景下的背景音乐 音效：例如碰撞、爆炸、奔跑等音效 配音：角色台词配音等 播放模式也有 2D 和 3D 的区别，其中 3D 音效有空间感，像是近大远小 支持的音频素材格式有 mp3 / wav / ogg / aiff 音频组件Unity 中音频资源的播放与接收都是通过对象组件实现的：AudioSource 表示声音源；AudioListener 表示声音接收者，在 mainCamera 对象上默认有一个，游戏场景下所有的 AudioSource 都会被监听到，然后根据距离来合成（一般不用再自行添加） AudioSource 组件：将资源添加到 AudioClip，然后下方选择播放模式 脚本控制：获取到 AudioSource 组件然后调用如播放、循环等 API 即可 Play() ：播放当前 AS 的资源，重复调用会中断当前播放来重开一个 PlayOneShot(clip) ：传入一个音频资源，每次调用另开一段播放该音频资源 预制体Prefab 是一类相同属性的对象，通常在游戏中需要反复创建消除，而每次创建都是相同的，因此设计了预制体；相当于一个用于创建对象的模板 创建预制体 在场景 Scene 中创建任意一个对象（可以绑定资源） 将对象拖入 Project 中则会创建预制体 编辑预制体（有几种方法），在修改预制体之后每一个由其创建的实例都会更新 在 Project 窗口双击资源 在 Inspector 窗口点击 Open Prefab 在 Hierarchy 窗口找到预制体的实例，点击右侧的箭头 编辑预制体对象：在场景里可以针对单个对象进行修改，然后使用 Apply all 来将此修改应用到其所属预制体；若需要解除预制体关联可以右击对象然后 Unpack 动态创建实例 将预制体作为引用属性添加到一个对象脚本上 public GameObject myPrefab; 并绑定需要的预制体资源 脚本中使用 Instantiate 创建一个新对象 GameObject bullet = Instantiate(myPrefab);；其中 Instantiate 是 Object 类的静态方法 物理系统实现牛顿运动定律（力、质量、速度）的系统 刚体 RigidBody：指物理系统中的物体，为游戏对象添加一个刚体组件来构成刚体；刚体有三种类型 Dynamic 是普通的刚体，有质量和速度 Static 静态的刚体，质量无穷大、无速度（适用于建筑物、地面等固定不动的物体）；一般不加 RigidBody 仅添加 Collider 即可 Kinematic 运动学刚体，无质量（忽略物理规律的刚体，一般用于碰撞检测）；勾选设置，可以由脚本控制移动；设置为自机可以检测是否撞单或撞敌机 刚体的碰撞 Collider：碰撞体，同样为游戏对象添加一个组件来完成；一般有 Box（方形）、Circle（圆形）、Edge（多线段）、Capsule（胶囊形）等；当把碰撞体范围改到图像素材更大时，就像形成了空气墙；小了则会穿模 刚体弹性：需要在 Project 中创建 Physics Material 并修改其摩擦系数和弹性系数；然后将该材料设置为对象刚体组件内的 material 属性即可 对象层级 LayerEdit -&gt; Project Settings -&gt; Tags and Layers 可以安排层级，然后每个对象的 Inspector 窗口内修改 Tag 和 Layer 作用 规避物理交互：同样在 Project Settings 中的 Physics (2D) 可以通过勾选矩阵来规定是否启用层级间对象的物理交互；不启用时可以直接在 CPU 层面节约计算时间，无需在脚本中处理 "},{"title":"算法题自刷总结","date":"2022-03-03T02:19:03.000Z","url":"/2022/03/03/Alg-Tricks/%E7%AE%97%E6%B3%95%E9%A2%98%E8%87%AA%E5%88%B7%E6%80%BB%E7%BB%93/","tags":[["面试","/tags/%E9%9D%A2%E8%AF%95/"],["算法","/tags/%E7%AE%97%E6%B3%95/"],["折磨","/tags/%E6%8A%98%E7%A3%A8/"]],"categories":[["Alg-Tricks","/categories/Alg-Tricks/"]],"content":"常用提示遍历索引遍历就不写了，C++ 和 Java 都有 for each 遍历 C++：for (char c : str) 或 for (string str : strs) Java：for (int num : nums) 常量在遍历求最值时经常使用 C++：INT_MAX，INT_MIN Java：Integer.Max，Integer.Min 大小比较 C++：max(val_1, val_2) Java：Math.max(val_1, val_2) 列表排序 C++：sort(vec.begin(), vec.end()) 排序 vector 容器 Java：Arrays.sort(arr) 排序数组 动规数组创建 C++：vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n)); Java： int[][] dp = new int[m][n]; 容器类栈 C++：stack&lt;int&gt; st st.push() / st.top() / st.pop() / st.empty() Java: Stack&lt;Integer&gt; st = new Stack&lt;Integer&gt;(); st.add() / st.peek() / st.pop() / st.isEmpty() 队列（通常都直接用双端队列代替） C++：deque(vec.begin(), vec.end()) / deque(size, val) / deque&lt;T&gt; dq; dq.push_back() / dq.push_front() 、 dq.insert(dq.begin()+n, len, val) dq.pop_back() / dq.pop_front() 、 dq.erase(dq.begin(), dq.end()) / dq.clear() dq.front() / dq.back() 、 dq.at(i) / dq[i] dq.empty() / dq.size() / dq.resize(n) Java：Deque&lt;Integer&gt; dq = new LinkedList&lt;Integer&gt;(); dq.addLast() / dq.addFirst() dq.removeLast() / dq.removeFirst() dq.peekLast() / dq.peekFirst() dq.size() 优先队列内部用堆结构存储，可以自定义优先级用于排序，总是最高优先级的在堆顶 C++：先要 #include &lt;queue&gt; 创建格式 priority_queue&lt;T, Container, Functional&gt; 用于自定义数据类型，使用基本类型则不需要； priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; c; 创建小顶堆，或者传入 less&lt;int&gt; 创建大顶堆（不传默认大顶） 方法：top() / empty() / size() / push(v) / emplace(v) / pop() / swap(v1, v2) Java：在 java.util.* 内，使用 new PriorityQueue&lt;T&gt;() 默认创建小顶堆，而大顶堆则要传入相反的 Comparator 方法：add(e) 返回 boolean、peek() 返回堆顶但不删除、poll() 获取并删除、size() 返回大小、remove(o) 指定移除、能从 大小 或 peek 检查是否为空 哈希见 哈希表算法整理 题类递归 合并两个有序链表：递归完成 合并 K 个升序链表：一个由升序链表构成的列表，将所有链表合并并返回头节点 解法：基于合并 2 个升序链表得到几个解法 写一个合并双链表的方法，然后遍历逐次合并两个链表 归并合并 优先队列维护未合并链表中头节点元素最小的 二分法 搜索旋转排序数组：有序数组平移过，主要的二分思想在于区分 mid 位于哪一段，先分 mid 为两种情况再考虑移动 l r 指针即可 在升序有重复数组中找目标值，返回左右索引：两次二分，仍为 O(log n) 奇异思路题 下一个排列：整数数组（每个元素为单个值）可视作一个十进制整数比较大小，原地修改数组使得其变成下一个更大的数，若已经最大则变成最小 解法： 从后往前找到第一个索引 i 使得 nums[i] &lt; nums[i+1] 再从后往前在 (i, n) 中找到最后面的 j 使得 nums[i] &lt; nums[j]，交换两个值 双指针颠倒 (i, n) 部分，左右开区间 最长有效括号：字符串仅包含 ‘(‘ 和 ‘)’，求最长有效（匹配且连续）括号子串的长度 解法： 动规，由于要求连续，数组的定义采用结尾处，因此也仅需考虑以 ‘)’ 结尾的；转移规则比较复杂 栈，用于记录最后一个未匹配的 ‘)’ 的索引，初始丢一个 -1 进去方便操作 双计数器，顺序遍历分别记录 左、右括号数，当右括号数大于左括号数时，当前位置可以截断了，先更新最大长度然后计数归零；由于顺序遍历可能出现 “(()” 情况，在进行一次逆序遍历统计即可 数学逻辑 给出一个三角形三个点的坐标，写一个函数可以输出三角形内随机一个点： 确定一个顶点出发的两个边向量，各乘一个随机数然后两个向量随机比例相加就行 牛顿迭代法求函数近似值：给出一个函数 f(x) 并期望求其根的近似值，例如 f(x) = x^2 - a，则 a 的平方根即为函数的一个根，牛顿迭代法任取一个起始点 k， 计算在 k 处的导数，取切线和 x 轴的交点作为下一轮的 k，最后当 k 值更新量较小时结束 由切线表达式 q(x) = f’(k)(x-k) + f(k) 得到切线和 x 轴的交点横坐标为 k1 = k - f(k)/f’(k) 给出矩形坐标和一个圆心加半径，判断是否有重叠： 先把圆根据矩形的长款中线翻转到第一象限内 取两个向量分别为矩形中心到圆心和矩形中心到矩形顶点 v 和 h 计算向量 u = v - h 且对负值取 0，负值即表示相应轴向和矩形重合 计算 u 的模与 r 比较即可 差分数组差分数组记录了一个数组中当前值和前一个值的差值，凡是对于一个长数组要反复取其中连续的一段子数组进行统一操作的都可以考虑差分数组；例如一个长数组多次输出两个左右边界和数值 x，进行边界内所有数都加上 x，使用差分数组只需要修改左右边界处的值，再累加还原即可"},{"title":"机器学习基础-优化算法","date":"2022-03-02T13:36:36.000Z","url":"/2022/03/02/Machine-Learning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80-%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/","tags":[["机器学习","/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"],["优化算法","/tags/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"]],"categories":[["Machine-Learning","/categories/Machine-Learning/"]],"content":"最优化算法是数学上一类用于求解函数极值的算法总称，通常用于解决无法直接求导确定极值点的多元关系式，对于以均方误差为损失的回归类问题尤为重要，而对于分类问题也可以经过一定的转换得到连续可导的损失函数式（如 LogisticRegression） 适用最优化问题的模型一般形式为 \\min f(x) \\\\ s.t. c_{i}(x)=0, i=1,2, \\ldots, m,\\\\ c_{i}(x) \\geq 0, i=m+1, \\ldots, p其中的约束函数通常可经过如拉格朗日乘子法（支持向量机中使用）等方法转化为无约束优化问题，从而回归到一般性的无约束优化问题，因此主要的研究针对于无约束优化算法 无约束优化基本流程： 确定初始迭代点 $x_0$，设置初始迭代数 k = 0 （初始点可多次随机确定来避免陷入局部最优） 设立终止条件，如最大迭代次数或最小优化目标函数值等（当更新后函数的优化较小时停止） 直到终止条件前不断迭代 计算梯度下降方向，通过目标函数对参数求导确定负导数方向 $d_k$ 根据学习步长更新参数 $x{k+1}=x{k}+\\alpha{k} d{k}$，记为一次迭代 上述过程中的主要影响因子有几方面，并针对这些影响因子有不同的算法变化： 初始迭代点 —— 随机生成用同策略迭代，最后结果取最优值 学习步长 —— 较低迭代次数时步长较大，迭代次数较大时步长较小 参数更新式 —— 添加动量的二次项等变化项形成不同的更新模式 注意：以下的求导内容都是对模型的参数求导来确定参数的更新方向，因此每一次求导都要有一个样本值代入损失函数表达式中 梯度下降法（BGD）此方法中基本会对所有的样本都代入来求参数的导数，最后贡献更新向量 最简单的无约束优化方法，对目标函数 Taylor 展开 f(x) = f(x_k)+g^T_k(x-x_k)+o(||x-x_k||)用更新后的参数 x=x_k+\\alpha d_k代入得到 f(x_k+\\alpha d_k)=f(x_k)+\\alpha g^T_kd_k+o(||\\alpha d_k||)由此取 $d_k = -g_k$ 时能使函数值减小量最大，也即负梯度方向 随机梯度下降法（SGD）基于梯度下降衍生而来，当样本个数过多时计算量太大，此时考虑随机抽取单个样本计算参数的梯度用于更新； 通常认为足够数量的样本服从正态分布，因此大多数随机抽取到的样本都符合样本总体特征，对其计算出的梯度也能正确地贡献给参数的更新方向，此方法省下的遍历样本的时间复杂度非常关键，而其损失在较多的迭代次数下也并不困扰 批量随机梯度下降法（MSGD）进一步衍生，抽单个样本可能不可靠，因此这里随机抽取一定量样本用于各自计算梯度然后综合 作为折中方法是最常采用的一种梯度下降法 Momentum 动量法由于单纯的梯度下降法在接近局部极小值时计算得到的梯度很小，从而导致其更新量几乎不可能跳出局部极小值，"},{"title":"单调栈算法整理","date":"2022-03-02T09:00:44.000Z","url":"/2022/03/02/Alg-Tricks/%E5%8D%95%E8%B0%83%E6%A0%88%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/","tags":[["面试","/tags/%E9%9D%A2%E8%AF%95/"],["算法","/tags/%E7%AE%97%E6%B3%95/"],["折磨","/tags/%E6%8A%98%E7%A3%A8/"]],"categories":[["Alg-Tricks","/categories/Alg-Tricks/"]],"content":"注：主要编题顺序及算法模板来自公众号「代码随想录」，强推！ 栈是一种早期学习的经典数据结构，而单调栈则是在保留栈性质的基础上稍加限制，在填充元素时先做判断的数据结构，相应的也有单调队列在队列整理中用到过 通常是一维数组，要寻找任一个元素的右边或左边第一个比自己大或小的元素位置 要找后面更大的元素，就应该持续把更小的元素入栈，做成从栈底到顶递减；要找更小元素则把更大元素入栈 通常入栈都是存下标，因为从下标可以很容易获取其在数组里的值，反之则不行 题组 每日温度：请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。 即找到每个点右侧第一个比它大的值，记录索引差 解法：用单调递减栈（指新放入元素目标值比栈顶小时正常放入），比较时比较数值，存入栈时存索引可以随时获取数值Java C++ 下一个更大元素Ⅰ：给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。 先做一个映射从 nums1 的元素映射到索引，然后同上用单调栈处理 nums2 ，在弹出元素时检查是否在映射中，若在则存入结果Java C++ 下一个更大元素Ⅱ：循环数组（末尾接到首位）输出每个元素的下一个更大元素 解法：循环两遍怎么都找到了，同上使用单调栈 接雨水：给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 解法一：遍历数组，每次往左右双指针找最高的柱子，取较小者即为当前格的水位高度，减去当前格的柱子高度再取非负部分即可（时间较复杂） 解法二：动态规划，先两次遍历得到每个位置左侧的最高柱子高度数组（和右侧的），然后再遍历一次进行计算 解法三：单调递减栈 柱状图中最大的矩形：给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。 解法：找两侧第一个更小的元素，画图理解一下，前面要插入一个 0 ，这样才能考虑到横跨数组的矩形（可能被截断） "},{"title":"动态规划算法整理（二）","date":"2022-03-02T04:26:16.000Z","url":"/2022/03/02/Alg-Tricks/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/","tags":[["面试","/tags/%E9%9D%A2%E8%AF%95/"],["算法","/tags/%E7%AE%97%E6%B3%95/"],["折磨","/tags/%E6%8A%98%E7%A3%A8/"]],"categories":[["Alg-Tricks","/categories/Alg-Tricks/"]],"content":"注：主要编题顺序及算法模板来自公众号「代码随想录 」，强推！ 动规的类型比较多，这里记录其他部分 分类 树形 dp ：如打家劫舍Ⅲ，在树上（后序）遍历时进行 dp 公式的推导 买卖股票：根据是否持有或第几次持有（若有交易次数约束）将每天分状态，然后写好转移公式 对比子序列：两个序列或字符串比较求特定的公共子序列或子串，若要求连续则规定 dp[i][j] 表示以 A 串的 i 位置和 B 串的 [j] 位置结尾的连续公共子序列；不要求连续则按照一般的二维动规 编辑距离：重点在于将一步编辑行为转化为子串之间的差距（例如理解增删等价性） 回文子串：单序列的子串可以尝试转化为矩阵更新上半角阵 题组 打家劫舍：一组 nums 去盗窃，不能偷相邻的，求最大和 解法：dp 记录前 i 家的最优值；转移 dp[i] = max(dp[i-1], dp[i-2]+nums[i]) 打家劫舍Ⅱ：上题成环 解法：分别剔除第一家和最后一家，退化成两个无环问题，然后取较大值 打家劫舍Ⅲ：偷二叉树结构 解法：必定进行后序遍历 日期状态题组 买卖股票的最佳时机：已知每天价格 prices 只进行一次交易，求最大收益 抽象：prices 大小的二维 dp 数组，每个元素为二元数组，分别记录当天持有和不持有股票的现金财产 买卖股票的最佳时机II：可以多次交易，但必须先卖出再买入 解法：主要是转移上有不同 买卖股票的最佳时机III：最多进行 2 次交易 解法：每天分成五种状态 —— 0. 没有操作 1. 第一次持有期间 2. 第一次卖出后 3. 第二次持有期间 4. 第二次卖出后只用到了前一天，可以降为一维数组更新 买卖股票的最佳时机IV：最多进行 k 次交易，方法同上 最佳买卖股票时机含冷冻期：无次数限制，但卖出后第二天暂不能买入 分状态 ——一、持有；二、二天前卖出，未持有；三、今天卖出，未持有；四、昨天卖出，冷冻期 -714. 买卖股票的最佳时机含手续费：无限次交易，但完成一次完整交易有手续费 fee 子序列题组 最长递增子序列：整数数组找到最长严格递增子序列的长度 dp[i] 描述到下标 i 处的最长递增子序列，遍历时从所有之前更新的之中取最大值 最长连续递增序列：同上但要连续 因为要求连续反而可以直接遍历判断；而用 dp 则定义 dp[i] 以下标 i 结尾的最长连续递增序列，只要当前数值不大于前一个数值就更新为 1，否则 +1 最长重复子数组：两个整数数组 A 和 B，求最长公共连续子数组 解法：用 dp[i][j] 表示以 A 数组的 i-1 和 B 数组的 j-1 处为结尾的最长公共连续子数组 最长公共子序列：两个字符串的公共子序列（保留前后顺序无须连续） 解法：不用连续则可直接定义 dp 然后更新，若两字符不相同则从左和上取较大者 不相交的线：等价于找最长公共子序列（不连续） 编辑距离 判断子序列：判断 s 是否为 t 的子序列（不用连续） 解法：类比最长公共子序列，但字符不相同时不用比较取而直接取长串 -1 的值 不同的子序列：计算 t 在所有 s 的子序列中出现的个数 解法：改变 dp 的定义和转移规则 两个字符串的删除操作：word1 和 word2，每步可从一个中删除一个字符，求使得两者相同的最小步数 注意字符不相等时三种情况判断（仅判断左和上也过了，为啥 —— 左或上的值不可能比左上的值大超过 1） 编辑距离：两个单词 word1 和 word2，允许操作 —— 1. 插入一个字符；2. 删除一个字符；3. 替换一个字符；求将 word1 转换成 word2 的最小操作次数 应该注意到对一个字符串添加元素等价于对另一个字符串删除一个元素，而将一个字符替换也是一次操作，因此 —— 左、上 和 左上都仅差一步操作，比较取最小即可 布尔标记 回文子串：计算字符串中有多少个回文子串（连续），只要起始或结束位置不同就当作不同的子串 解法：用布尔数组 dp[i][j] 表示从 [i,j] 的闭区间为回文串，此时若两边界的字符不同，则显然不是回文串；若相同则考虑长度，长度大于 2 则需要由 [i+1,j-1] 判断，因此需要对 i 从后往前遍历，而 j 从前往后遍历 也可用中心扩散法，分别取单字符和双字符为中心向两边扩散检查，省下空间 最长回文子序列：子序列不必连续，同上用上三角矩阵完成 "},{"title":"动态规划算法整理","date":"2022-03-01T11:46:01.000Z","url":"/2022/03/01/Alg-Tricks/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/","tags":[["面试","/tags/%E9%9D%A2%E8%AF%95/"],["算法","/tags/%E7%AE%97%E6%B3%95/"],["折磨","/tags/%E6%8A%98%E7%A3%A8/"]],"categories":[["Alg-Tricks","/categories/Alg-Tricks/"]],"content":"注：主要编题顺序及算法模板来自公众号「代码随想录 」，强推！ 动态规划，Dynamic Programming ，如果某一问题有很多重叠子问题，使用动态规划是最有效的。 动态规划中每一个状态一定是由上一个状态推导出来的 取或不取得问题通常可以抽象成 0-1 背包问题，明确各物品的价值和取物品的容量 阶段分类 位置转移：包括在已知转移花费时确定总花费、已知位置时确定路径数等 取舍问题：典型的背包问题延申，注意抽象化成背包问题的取舍 价值最大化：取舍的价值最大化通常由已搜出的结果单值转移（474重量约束为二维，可以看看） 组合数搜索：搜索目标容量的组合数通常要对所有已搜出的结果累加 完全背包：物品无限取，首先即是对容量的遍历要改为从小到大 求组合数：必须外层遍历物品，内层遍历容量 求排列数：必须外层遍历容量，内层遍历物品 求组合的最小元素数：遍历顺序不影响，但要注意初始化 关于完全背包的组合和排列问题的解释纯个人理解，可能有偏差 求组合个数则需要外层物品内层背包；求排列数（不同排列但数相同视为两种）则需要外层背包内层物品；而仅考虑所有组合中的最小组时则不在意顺序 对于求组合的问题 —— 尝试考虑物品重量组合 [1,3] 外层处理 1 重量物品时，无论容量如何都只能有计数 一 外层处理 3 重量物品时，仅会在容量达到 4、7 等值发生 +1 计数，而无关物品顺序 对于求排列的问题 —— 尝试思考物品重量组合 [1,3] 当外层达到容量 3. 时，毫无争议地有 [1,1,1] 和 [3] 两种组合 当外层达到容量 4. 时，先考虑 1 重量物品，则由 3. 容量的两种组合得到同样计数 二，再考虑 3 重量物品得到计数 一，此时总共的组合有 [1,1,1,1], [3,1], [1,3]，已经可以初见端弥 当外层容量达到 5. 时，显然对 1 重量物品有计数 三 [1,1,1,1,1], [3,1,1], [1,3,1]，而对 3 重量物品有计数 一 [1,1,3]，排列性质由此体现 解题步骤 确定 dp 数组内容及下标的含义 确定递推公式 dp 数组如何初始化 确定遍历顺序 举例推导 dp 数组 注意点原本的 0-1 背包用二维数组求解，随后发现 i+1 维的数组更新时仅依赖于 i 维数组的已更新值，因此可以用一维的 dp 数组逐次更新，此时要注意内循环要反向来确保物品只取用一次 不同的二叉搜索树：转移公式考虑以各个数做根能如何组合 背包题组位置转移 斐波那契数：略 爬楼梯：略 使用最小花费爬楼梯：每个阶梯有 cost[i]，花费体力后可以向上一个或两个，初始可选 0 或 1，求最小花费 解法：i 处由 dp[i-1] + cost[i-1] 和 dp[i-2] + cost[i-2] 的较小者确定 不同路径：从 m*n 网格左上角，每次只能向下一格或向右一格，有几种路径到右下角 解法：从右下角往回动态规划，两条边初始化都为 1 不同路径Ⅱ：中间有障碍物在数组中用 1 标记 解法：保证障碍物格对应解始终为 0，注意障碍物在边上的情况 整数拆分：给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。如 10 = 3 + 3 + 4 解法：dp[i] 表示数字 i 可拆分后的最大乘积，则 dp[i] = max(dp[i],max(dp[i-k]k,(i-k)k)) 需要遍历所有小于 i 的 k 得到 不同的二叉搜索树：给定一个整数 n，求以 1…n 为节点组成的二叉搜索树有多少种 解法：dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量 元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量 元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量 元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量 有2个元素的搜索树数量就是dp[2]。 有1个元素的搜索树数量就是dp[1]。 有0个元素的搜索树数量就是dp[0]。 0-1 背包问题 物品重量和价值，单物品最多取一次，求定容下最大价值 解法： 定义数组：用 dp[i][j] 表示从 [0-i] 号物品中取，容量为 j 时的最大价值 转移规则：对每个 i 物品，若不将 i 放入背包则等价于 dp[i-1][j] ，若将 i 放入背包则等价于 value[i] + dp[i-1][j-weight[i]]；从而确定递推公式 dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i]) 初始化：j = 0 时显然对任意 i 都为 0；当 j &lt; weight[0] 时都有 dp[0][j] = 0 —— 初始边际行列初始化完毕 确定遍历顺序：从物品遍历和从重量遍历都可以 举例推导：自己动手打草稿试试 最好固定先遍历物品，在遍历重量 用一维数组时要严格先遍历物品，且重量要从后往前遍历 分割等和子集：非空数组仅包含正整数，是否可以分割成两个和相同的子集 解法：回溯用一个整数统计取到的和，只要找到和为 sum/2 的组合即有解（超时了）； 抽象成 0-1 背包问题，每个元素仅允许一次放入，背包容量 sum/2 最后一块石头的重量Ⅱ：有一堆石头，每块石头的重量都是正整数。每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。 最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。 解法：尽量将石头分成重量相同（或相近）的两堆 目标和：给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。返回可以使最终数组和为目标数 S 的所有添加符号的方法数。 解法：回溯法超时；抽象成 0-1 背包，分两组 left - right = target = left - (sum - left) =&gt; left = (sum + target) / 2 ；这里的 left 即应当分为正组的和 抽象步骤： 明确数组：dp[j] 表示要达成和为 j 有 dp[j] 种组合方法 递推公式：dp[j] += dp[j-nums[i]]，即对所有不大于 j 的 nums[i]，都可由 dp[j-nums[i]] 对应一种组合，从而要全部累加 初始化：dp[0] 表示达成和为 0 的正数组合，不取正数即得到，因此为 1 确定遍历顺序：nums 在外，target 在内且倒序 举例实验 一和零：一个二进制字符串数组 strs 和两个整数 m、n；从 strs 中取子集，使得子集中最多有 m 个 0 和 n 个 1，求最大的子集大小 解法：认为是关于容量有两条约束的 0-1 背包，每个字符串元素取或不取 抽象： dp[i][j] : i 为 0 容量，j 为 1 容量，存值表示最大子集大小 用 zero[k], one[k] 表示元素包含的 0， 1 数量，则转移规则 dp[i][j] = max(dp[i][j], dp[i-zero[k]][j-one[k]]+1) —— 可以遍历时单个统计而非一开始先统计好 物品价值可抽象为每个字符串元素对子集大小的贡献，恒定为 1 ，故初始化为 0 遍历顺序 举例实验 完全背包 每种物品有无限个的背包问题，和 0-1 背包的主要区别在于遍历顺序：之前都是在内层对容量逆序遍历，为了确保物品仅添加一次，现在改为正序遍历，当遍历时容量足够仍可能加上已经放入过的物品；初始化也有一点不同，即第一层可以重复放入物品 i = 0；实际上在第一层循环就进行了重复放入 零钱兑换Ⅱ：不同面额硬币和总金额，求达成总金额的组合数 解法：完全背包，注意初始化（dp[0] = 1）和转移（因为是求组合数所以累加）；循环顺序严格要物品在外，确保不重复组合 组合总和Ⅳ：给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。（数字可重复，相同数字不同排列视为不同） 解法：排序后同上 零钱兑换：面值 coins 和金额 amount，求组合的最少硬币个数，不能组合则返回 -1 解法：容易想到贪心；用完全背包做时，由于考虑个数，其转移为取最小值，因此无关排序或组合，遍历顺序没有影响，初始化时则要全部取最大值 完全平方数：给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, …）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。 解法：容量为 n，而物品为顺序排列的完全平方数 单词拆分：给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 解法：将字符串看作背包，单词为物品，可以重复取用，尽量装满背包 多重背包在完全背包和 0-1 背包之间加上了物品个数约束，可以从 0-1 背包衍生而来，对物品个数遍历 "},{"title":"贪心算法整理","date":"2022-03-01T05:58:13.000Z","url":"/2022/03/01/Alg-Tricks/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/","tags":[["面试","/tags/%E9%9D%A2%E8%AF%95/"],["算法","/tags/%E7%AE%97%E6%B3%95/"],["折磨","/tags/%E6%8A%98%E7%A3%A8/"]],"categories":[["Alg-Tricks","/categories/Alg-Tricks/"]],"content":"注：主要编题顺序及算法模板来自公众号「代码随想录」，强推！ 贪心算法即选择每一阶段的局部最优，从而达到全局最优，一般分为如下四个步骤： 分解为若干个子问题 找出适合的贪心策略 求解每一个子问题的最优解 将局部最优解堆叠成全局最优解 自定义排序由于用到的比较多，在这里标上，下方都是递增排序 C++：第一个参数要排在第二个参数前时返回 true Java 由于是继承自 Comparable 接口覆写 compareTo 方法，所以实际上的比较总是符合 x.compareTo(y) 的规则，即返回正表示 x 比 y 大，此时会把 x 放在 y 的后面（列表或优先队列都这样） 注意题 根据身高重建队列：一个二维数组表示已经排好的队列被打乱了，每个元素第一个值为该成员的身高，第二个元素表示原队列中在他前方有 ki 个身高不小于他的人；目标还原队列顺序 解法：先按照身高降序排列，然后遍历按照 ki 插入新队列，插入操作 vec.insert(pos, val) 同字符串的插入 多为数组排序题： 区间排序：例如 452. 用最少数量的箭引爆气球；435. 无重叠区间；二维数组每个元素表示一个区间，此类问题通常要求尽可能重叠或不重叠 尽可能重叠：通常按照同侧排序和遍历起始，即如 按左边界排序，从左到右遍历 尽可能不重叠：通常相反，因为右边界越小，留给其他区间的可用空间就越大，即如 按右边界排序，从左到右遍历 监控二叉树：好难，有空再说 基础题 分发饼干：假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 解法：优先用最小的饼干分给最容易满足的孩子即可，先排序孩子再排序饼干，有无法满足的孩子可以剪枝提前结束 摆动序列：如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。 解法：动态规划更好， 最大子序和：一个整数数组 nums，找到一个具有最大和的连续子数组，返回其最大和 解法：for 循环遍历时若当前和非正则直接舍弃前面一段的和计算其后 买卖股票的最佳时机：给定数组表示股票各天价格，可以多次交易，计算最大利润 解法：只要下一次下降就在当此卖出，下一次上升就在当此买入 跳跃游戏：数组每个元素表示当前位置可以跳跃的最大长度，初始位于 0 索引处，判断能否到达最后一个位置 解法：最大长度说明此前的都可以达到，循环更新最大长度判断是否覆盖总长 跳跃游戏Ⅱ：同上，但使用最少次数跳跃到最后位置（size - 1 索引处） 解法：仅在当前位置达到最大距离时，更新次数和最大距离 K 次取反后最大化的数组和：整数数组 A 严格执行 k 次单元素取反，求最大和 解法：尽可能把绝对值大的负数取反，若次数多余则最后把小的取反 加油站：环路上 N 个加油站提供 gas[i] 燃油，从 i 到 i + 1 消耗 cost[i] 燃油，初始为空且无上限，求能绕行一周的点（解唯一） 解法：顺序遍历计算每个点余油量和，只要出现负数就只能取到下一个点作为起点，继续更新 分发糖果：N 个孩子有评分 nums，要求 —— 每个孩子最少 1 个糖果，相邻孩子中评分高者必须分更多糖果 解法：贪心更新，左右遍历两次，仅第二次更新时需要比较取较大者（先确定一个方向的顺序，再根据另一个顺序修改） 柠檬水找零：一杯 5 元，顾客逐个到来，付账 5、10、20，初始没有零钱，判断是否总能找零 解法：记录已有的 5 和 10 面值个数，遇到 20 先用大面值 根据身高重建队列：一群人排列被打乱 people 数组，每个元素为二元的 [hi, ki] 分别为 身高 和 前面正好有 ki 个身高不小于 hi 的人，重构数组 解法：一定要先确定一个维度，这里先按照身高降序排列，然后顺序遍历，按照 ki 的值插入 用最少数量的箭引爆气球：二维数组，每个元素是一个气球的左右边界，重叠时可以一起射爆，求总共最少所需射箭数 解法：只要重叠就都一起射即可，按照左边界排序再从左到右（或按右边界排序再从右到左），遍历时记录右边界来考虑重叠，不重叠时再更新右边界并增加数量 无重叠区间：给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。 解法：按照左或右边界排序，然后反向遍历 —— 因为如右边界越小，其右侧余下给其他区间不重叠的空间越大，依次选择补充点的区间，没选上的就移除 划分字母区间：小写字母构成字符串 S，尽可能多划分使得同一字母最多出现在一个片段中。 解法：先遍历一次得到每个字符的最后出现位置；第二次遍历时逐步加入字符更新最远位置，若当前位置达到该最远位置则应当进行一次分割 合并区间：给出一个区间的集合，合并所有重叠的区间 解法：排序后一次尽可能合并即可（取到重叠的最大右边界） 买卖股票的最佳时机含手续费：数组 prices 和手续费 fee 仅在完成交易（持有到卖出）时支付一次，求最大利润 解法： 监控二叉树：给定一个二叉树，我们在树的节点上安装摄像头。节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。计算监控树的所有节点所需的最小摄像头数量。 解法：尽量放在叶子节点的父节点上，从下往上搜索 "},{"title":"哈希表算法整理","date":"2022-03-01T02:57:01.000Z","url":"/2022/03/01/Alg-Tricks/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/","tags":[["面试","/tags/%E9%9D%A2%E8%AF%95/"],["算法","/tags/%E7%AE%97%E6%B3%95/"],["折磨","/tags/%E6%8A%98%E7%A3%A8/"]],"categories":[["Alg-Tricks","/categories/Alg-Tricks/"]],"content":"注：主要编题顺序及算法模板来自公众号「代码随想录」，强推！ 用法HashMap散列表，根据关键码的值直接进行访问的数据结构（数组也可以看作索引到元素的哈希表，所以后续使用以整数为键的哈希表时可以直接用数组） C++ 初始化：unordered_map&lt;int, int&gt; umap 赋值：umap[key1] = val1 也可用于修改；umap.insert(&#123;key, val1&#125;) 用 insert 可以插入 pair 对象或者一维、二维元素（二维要两层大括号） 删除：umap.erase(key1) 移除元素 检查：umap.count(key1) 或者 umap.find(key1) 未找到返回尾指针 遍历：要创建 iter 指针对象然后遍历 umordered_map&lt;int, int&gt;::iterator it; for (it = umap.begin(); it != umap.end(); it++ &#123;int key = it-&gt;first; int val = it-&gt;second;&#125; Java 初始化：Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;() 存入：map.put(key1, val1) 删除：remove(Object key) 获取：map.get(key1) 或 map.getOrDefault(key1, dfv) 检查：map.containsKey(key1) 和 containsValue(val1) 空检查：isEmpty() 和 size() 遍历：for (var key : map.keySet()) 实际是 .keySet 返回一个 Set 对象 HashSet哈希集合，重复存入元素仅保留一个 C++ 初始化：unordered_set&lt;int&gt; hash_set 空 带元素初始化：unordered_set&lt;int&gt; num_set(nums.begin(), nums.end()) 查找：hash_set.find(val) != hash_set.end() 插入：hash_set.insert(val) 或者 emplace(val) 更高效 移除：hash_set.erase(val) 遍历：for (auto el : hash_set) 或者用 iter 更好 空检查：.empty() Java 初始化：Set&lt;Integer = new HashSet&lt;Integer&gt;(); 添加：set.add(val); 删除：remove(Object o) 查找：set.contains(val); 大小：set.size(); 和 isEmpty() 基础题 有效的字母异位词：两个字符串 s 和 t，判断 t 是否是 s 的字母异位词 解法：（假设仅包含小写字母）用数组统计各字母个数即可，注意遍历 t 可以在原数组上减 两个数组的交集：返回结果中每个元素唯一 解法：用 unordered_set 存储数值分散，跨度较大的哈希值情况（java 用 HashSet() 快乐数：正整数 n 反复对各位取平方求和，若最终为 1 则是快乐数 解法：上述操作只会得到 1 或者无限循环，用 unordered_set 记录出现过的，若重复则循环了，否则得到 1 返回 true 两数之和：整数数组 nums 和目标 target，找到和为目标的两个数并返回下标（假定必有唯一解） 解法：一次遍历，把当前值和 target 的差做 key，索引做 val，后面数组中若在 hash 中有 key 则得到解 （用unordered_map） 四数相加Ⅱ：四个等长数组，计算有多少个索引元组使得四个数和为 0 解法： 首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。 定义int变量count，用来统计 a+b+c+d = 0 出现的次数。4.在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。 最后返回统计值 count 就可以了 赎金信：字符串 s1 和 s2，判断 s1 是否可由 s2 中字符拼成 解法：统计个数即可 三数之和：含 n 个元素的数组 nums，判断是否存在三个元素和为 0，要求结果的三元组不重复 解法：先排序方便跳过相同元素，然后单层 for 循环内用双指针在 i 后面左右逼近 四数之和：同上但要四个元素 解法：排序，两层 for 循环内用双指针 "},{"title":"链表算法整理","date":"2022-03-01T02:56:47.000Z","url":"/2022/03/01/Alg-Tricks/%E9%93%BE%E8%A1%A8%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/","tags":[["面试","/tags/%E9%9D%A2%E8%AF%95/"],["算法","/tags/%E7%AE%97%E6%B3%95/"],["折磨","/tags/%E6%8A%98%E7%A3%A8/"]],"categories":[["Alg-Tricks","/categories/Alg-Tricks/"]],"content":"注：主要编题顺序及算法模板来自公众号「代码随想录」，强推！ 链表是一种通过指针串联在一起的线性结构，当前节点只能知道下一个（或双链表知道上一个），不能预先知道链表长度 链表非连续存储，而是用指针指向下一个节点的地址; 链表的增删都通过改变指向实现 C++ 在取消节点的指向后 delete node 释放节点内存 常用操作 建一个虚拟指针指向 head 前后指针和临时指针之间的交换 左右指针间隔同步移动 快慢指针移动 结构定义 C++ Java 基础题 移除链表元素：删除链表中等于 val 的节点 解法：建一个虚拟节点指向 head，然后遍历 node-&gt;next 来修改 设计链表：设计一个链表类实现 —— get(idx)、addAtHead(val)、addAtTail(val)、addAtindex(index,val)、deleteAtIndex(index) 反转链表：反转一个单链表 解法：移动两个指针来交换即可 两两交换链表中的节点：每两个节点交换 解法：从虚拟节点开始换后面两个 删除链表的倒数第 N 个节点 解法：左右指针相差 n 个同步移动 面试题02.07.链表相交：有两个头节点，返回相交节点或 null 解法：先各自遍历确定长度，然后左右指针相差定长同步移动 环形链表Ⅱ：给定链表，返回开始入环的第一个节点，或者 null 解法：快慢指针，若会相交则有环；相交后再从 head 发出一个慢指针，两个慢指针再相交则为环入口 "},{"title":"数组算法整理","date":"2022-03-01T02:54:42.000Z","url":"/2022/03/01/Alg-Tricks/%E6%95%B0%E7%BB%84%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/","tags":[["面试","/tags/%E9%9D%A2%E8%AF%95/"],["算法","/tags/%E7%AE%97%E6%B3%95/"],["折磨","/tags/%E6%8A%98%E7%A3%A8/"]],"categories":[["Alg-Tricks","/categories/Alg-Tricks/"]],"content":"注：主要编题顺序及算法模板来自公众号「代码随想录」，强推！ 数组可以说在所有编程语言中都是最基础的一个数据结构，是存放在连续内存空间上的相同类型数据的集合 输入数组是以引用方式传递的，在函数中改变数组也会改变原来的变量 数组创建写一些常用的 C++若指定 size 则后面的初始化只能少不能多 一维：int arr[2] = &#123;0,1&#125; 二维：int arr[2][3] = &#123;&#123;0,1,2&#125;,&#123;3,4,5&#125;&#125; vector 容器： 空声明：vector&lt;int&gt; v1 复制副本：vector&lt;int&gt; v1(v2) 多重复元：vector&lt;int&gt; v1(n, val) 重复初始化：vector&lt;int&gt; v1(n) 默认填 0 定值初始化：vector&lt;int&gt; v1&#123;1,2,3&#125; 或 vector&lt;int&gt; v1 = &#123;1,2,3&#125; 直接 sort(arr) 来排序 Java 动态初始化：int[] nums = new int[n] 后续索引赋值 静态初始化：int[] nums = new int[]&#123;1,2,3&#125; 或 int[] nums = &#123;1,2,3&#125; 多维： 动态：int[][] matrics = new int[3][4] 静态：int[][] mat = new int[][]&#123;&#123;1,2&#125;,&#123;3,4&#125;&#125; 使用 Arrays.sort(arr) 来递增排序，使用 Arrays.fill(arr, 1) 来填充 基础题 二分查找：n 元升序整型数组，找目标值，返回下标或 -1 移除元素：给出数组 nums 和值 val，原地移除所有等于 val 的元素，返回新长度 解法：左右指针法，右指针遍历时把非 val 值移到左指针处 有序数组的平方：非递减 nums（可能有负数），返回所有数平方后的非递减新数组 解法：原数组左右双指针靠拢，新数组从后往前填充 长度最小的子数组：n 个正整数的 nums 和正整数 s，找出和不小于 s 的最小连续子数组长度，不存在则 0 解法：左右指针记录其间的和，不足 s 时右指针右移，超过时记录并左指针左移 螺旋矩阵Ⅱ：正整数 n 生成 n * n 大小的二维数组（矩阵），数组顺时针排序 解法：模拟 "},{"title":"回溯算法整理","date":"2022-02-27T08:50:33.000Z","url":"/2022/02/27/Alg-Tricks/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/","tags":[["面试","/tags/%E9%9D%A2%E8%AF%95/"],["算法","/tags/%E7%AE%97%E6%B3%95/"],["折磨","/tags/%E6%8A%98%E7%A3%A8/"]],"categories":[["Alg-Tricks","/categories/Alg-Tricks/"]],"content":"注：主要编题顺序及算法模板来自公众号「代码随想录」，强推！ 回溯法又称回溯搜索法，是一种递归过程中回溯观测者状态的算法，只要使用回溯必定是在递归函数中 回溯法一般可以解决以下几种问题： 组合问题：N 个数中按一定规律找出 k 个数的集合（剪枝通常在 for 循环处；去重通常排序后标记） 切割问题：一个字符串按一定规则有几种切割方式（回文串和 IP，注意终止条件） 子集问题：一个 N 个数的集合里有多少符合条件的子集（去重方法） 排列问题：N 个数按一定规则全排列，有几种排列方式（标记方法，其去重也略有不同） 棋盘问题：N 皇后，解数独等 （经典题类，可以说回溯就是此类问题诞生的） 结果去重着重看一下 组合总和Ⅱ 和 子集Ⅱ 和 递增子序列 关于理解 for 循环横向遍历，即其在代码块中进行了 加入元素 递归 回溯 所以每次 for 循环都相当于在同级别处理不同元素 而递归深入一层后则是进入了不同级别，上面列出的前两道题即因为排序后，要取子集肯定会在得到第一个数的层级进入递归完成全部 涉及到去重，因为递归写在 for 循环内，因此永远是深度优先，从而对重复的结果仅保留第一次搜索的树枝 注意点通常在一个数组中回溯时，为了避免取到之前的递归中已经执行过的内容，要借助一个 startIndex 界定范围 回溯问题通常可以抽象成树结构，模板中用 for 循环横向遍历，递归纵向遍历 有时要用布尔数组标记已经获取过的（如排序问题），其创建 cpp 中 vector&lt;bool&gt; used(nums.size(),false)， java 中 boolean[] used = new boolean[nums.length] 注意难点题 递增子序列：由于需要考虑原来数组的顺序，不允许排序；数组中相同的数不一定连续排列，因此回溯时要考虑去重 —— 在一层递归中使用哈希记录是否已经排入过元素，后续再遍历到已经存入的元素时即可跳过 解数独，注意如何设置返回值和最后的结束条件，因为当找到最后一位，也即 i， j 循环到最后值时通过，因此将 return true 写在回溯函数末尾即可 通常模板： 题组 组合：给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合 解法：可以早停（剪枝） 组合总和Ⅲ：找出所有相加之和为 n 的 k 个数的组合，组合中数从 1 - 9 中不重复地取 思考：如果循环中用 i &lt;= n 终止，前面 n 用逐减，是否正确地剪枝了 电话号码的字母组合：给定一个字符串仅包含 2-9 的数字组合，每个数字在九键上能代表几个字母，返回所有可能的字母组合字符串列表 组合总和：一个无重复数组 candidates 和目标数 target，找出前者中所有使数字和为 target 的组合（前者中数字可以重复取，所有数都为正整数） 组合总和Ⅱ：数组 candidates 和目标数 target，同上但数组有重复数，最后结果不要重复组合 解法：先排序，然后重复的会相邻 分割回文串：给定字符串 s，将其分割成一些回文子串，返回所有分割方案（全分割是一种） 复原 IP 地址：给出只包含数字的字符串，复原并返回所有可能的 IP 地址（由四个 0-255 闭整数间隔 ‘.’ 组成） 解法：严格要求四段，终止条件不同，用 pointNum 记录打点数 子集：不重复整数数组，给出所有子集的集合 解法：二进制运算；或者回溯，但终止条件仅考虑跑完数组，也可以认为无需补充终止条件 子集Ⅱ：可能重复的nums求子集 解法：排序后类似组合总和 递增子序列：整数数组找到所有递增子序列，各长度至少为 2 全排列：一个没有重复数字的序列，返回所有可能的全排列 解法：用一个布尔数组标记分支上取过的，回溯时取消标记 全排列：给定一个可包含重复数字的序列 nums，按任意顺序返回不重复的全排列 解法：涉及结果去重，排序后用上面方法（干脆记住） 重新安排行程：给定一个机票的字符串二维数组 [from, to]，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。 解法：没看懂 N 皇后：将 n 个皇后放在 n * n 棋盘上，彼此互相不能攻击，返回所有方案（不同行，不同列，不同对角斜线） 解法：由于不能同行，可以选择按照每行深入递归，递归的一层遍历行内每列（行列对换也行） 解数独：9*9 宫格解数独，可以假设只有唯一解 解法：二维递归 "},{"title":"二叉树算法整理","date":"2022-02-26T03:09:54.000Z","url":"/2022/02/26/Alg-Tricks/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/","tags":[["面试","/tags/%E9%9D%A2%E8%AF%95/"],["算法","/tags/%E7%AE%97%E6%B3%95/"],["折磨","/tags/%E6%8A%98%E7%A3%A8/"]],"categories":[["Alg-Tricks","/categories/Alg-Tricks/"]],"content":"注：主要编题顺序及算法模板来自公众号「代码随想录」，强推！ 递归法总体思路流程： 递归的入参和返回如果要遍历整棵树，则不能有返回值；遍历某一条固定路线则一定要有返回值 如果要搜索整棵树且不用处理递归返回值，则不需要 return 值 如果需要搜索整棵树且要处理返回值，则需要 如果要搜索一条符合条件的路径，则一定要返回值 遍历选择 涉及二叉树的构造，通常都是用前序遍历，先完成父节点再递归实现左右子树 涉及二叉树的属性（如最大值等）一般用后序，递归地在中节点整合两侧的数据情况 涉及二叉搜索树一般直接上中序，因为有序性很顶 层序遍历借助队列实现，没啥困扰的，后续会考虑到对已经遍历过的标记以避免重复 题整理树结构是一种比较有趣且有效率的数据结构，通常使用并考察二叉树，其中有满二叉树（只有 0 度和 2 度节点）、完全二叉树（层序编号）、二叉搜索树（左小右大的有序树 —— 中序遍历得到有序数列）、平衡二叉搜索树（进一步左右度差不大于1） 二叉树的遍历实际上是深度优先和广度优先的区别，其中深度优先的三种序遍历可以用中节点的顺序来区分： 前序遍历：中左右 中序遍历：左中右 后序遍历：左右中 深度优先遍历通常可以递归地实现，也即可以借助栈来实现；而广度优先遍历则借助队列（先进先出） 深度优先遍历 递归方法：明确终止条件 —— 当前节点为空，明确调用顺序 —— 根据哪种遍历，设置存值和递归调用的顺序 迭代方法：借用栈实现，每种都有一点不同 前序遍历：由于前序遍历先输出中节点，而一般的访问顺序也总是中节点，因此比较简单；先根节点入栈，再循环取出栈顶，将其右、左节点依次压入，值取出 中序遍历：先将所有可能有右节点的入栈，用指针处理栈顶元素并指向右边（之前想不明白的点是在 while 中分类处理） 后序遍历：左右中，先按照前序遍历改成 中右左 再颠倒即可 广度优先遍历借助队列将每一抽象层的节点遍历，下一层的存入 翻转二叉树：每个节点的左右子节点对换 解法：确保每个节点仅反转一次即可 对称二叉树：检查一个二叉树是否对称 解法：用递归或迭代均可，其中递归可以写 compare(TreeNode* l, TreeNode* r) 递归调用；迭代可以用一个栈按照左右的确定顺序遍历 二叉树的最大深度：给定根节点，找出返回最大深度 解法：递归遍历或层序遍历迭代 二叉树的最小深度：略 解法：类似最大深度，但要注意不能单纯取 min ，因为仅当左右子树都为空才得到 0 （即要注意转移条件）；或层序遍历发现叶子节点即可结束 完全二叉树的节点个数：给出一个完全二叉树，求节点个数 解法：可正常同上的迭代方法；或结合完全二叉树性质，每次迭代先比较最左和最右深度，若相等则此节点下是满二叉树，否则继续迭代 平衡二叉树：判断二叉树是否高度平衡（任意左右子树高度差不大于 1） 解法：递归求左右子树高度，比较后若不平衡则退出，否则进入下一次递归 二叉树的所有路径：返回所有从根节点到叶子节点的路径 解法：没太懂，先记着；回溯的删除节点过程一定要和一次递归深入对应，即执行一次递归深入就执行回溯删除 左叶子之和：计算二叉树的所有左叶子之和（首先是叶子，其次是左边的） 解法：只能在父节点处判断是否是左叶子，递归完成 找树左下角的值：在树的最后一行找到最左边的值 解法：层序遍历记录最左侧值，若还有下一层则更新；或者前序遍历，第一次深度增加的节点一定是当前深度最右侧的节点 路径总和：二叉树和一个目标值，判断是否存在根到叶子的路径和等于目标值（就是路径求和，可以相等了早停） 解法：递归遍历，求目标和可以改成以目标和为起点逐路径相减 路径总和Ⅱ：找到所有路径总和等于目标值的路径 解法：类似上面但不返回 从中序与后续遍历构造二叉树：已知中序遍历和后序遍历结果，构建二叉树，（假定所有值唯一） 解法：每次找后序列的末尾，其一定是中间节点，以此节点分割中序列，基于分为左右的中序列将后序列也分为左右（可以根据分割后的中序数组大小来确定），递归处理 最大二叉树：从一个不重复数组构建最大二叉树 —— 根节点是最大元素，左子树由最大元素左侧所有元素构成的最大二叉树 解法：递归构建 合并二叉树：将两个二叉树覆盖，都有节点的值相加，否则保留有节点的 解法：同时递归两个树 二叉搜索树中的搜索：有根和值，找到目标节点或 NULL 解法：类似二分地递归搜索 验证二叉搜索树：给定二叉树，判断其是否是一个有效的二叉搜索树 —— 节点的左子树只包含小于当前节点的数，左子树也是二叉搜索树；右同 解法：中序遍历得到有序数列 二叉搜索树的最小绝对差：节点非负的二叉搜索树，返回任意两节点的差的绝对值最小值 解法：中序遍历得数组最简单；在遍历中比较的方法如下，记录前一个节点即可 二叉搜索树中的众数：非严格的单调关系树 解法：仍是中序遍历，但记录连续的出现次数 二叉树的最近公共祖先：给定两个节点，找到最近公共祖先 解法：后序遍历 二叉搜索树的最近公共祖先：同上，但是搜索树 解法：从上到下遍历时，只要当前节点值在 [p,q] 之间即得 二叉搜索树的插入操作 解法：同上从上到下搜索到叶子即可；或者替换根把根节点向下？ 删除二叉搜索树中的节点：要保证搜索树性质不变 解法：主要考虑如何删除，当目标节点左右都非空时，找到右子树的最左叶子，把左子树移过去即可 修剪二叉搜索树：给定上下边界 L、R，修建二叉搜索树使得所有节点在其中（可能要改变根节点） 将有序数组转换为二叉搜索树：即每个节点左右子树高度差不大于1 解法：递归每次尽可能取数组中间的值作为父节点 把二叉搜索树转换为累加树：给定根节点，值各不相同，转为累加树 —— 节点值变为所有不小于该值的节点值之和 解法：反中序遍历，即右中左的顺序 "},{"title":"栈与队列算法整理","date":"2022-02-25T11:59:11.000Z","url":"/2022/02/25/Alg-Tricks/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/","tags":[["面试","/tags/%E9%9D%A2%E8%AF%95/"],["算法","/tags/%E7%AE%97%E6%B3%95/"],["折磨","/tags/%E6%8A%98%E7%A3%A8/"]],"categories":[["Alg-Tricks","/categories/Alg-Tricks/"]],"content":"注：主要编题顺序及算法模板来自公众号「代码随想录」，强推！ 栈和队列分别是后进先出和先进先出的数据结构，在 c++ 中可以使用 std::stack&lt;int&gt; 实例化栈对象，其内部默认使用 deque 作为数据容器，也可以指定 vector 或 ist ，对外提供接口 push() / pop() / top() 都为 O(1) 复杂度，注意其 pop() 是 void 方法，所以取值先用 top()；在 java 中通常使用 java.util.Deque 类实现，调用 addFirst(e) / removeFirst() / getFirst() 方法来实现功能，实例化 Deque&lt;Integer&gt; stk = new LinkedList&lt;Integer&gt;(); Java 也可以直接用 Stack&lt;Integer&gt; st = new Stack&lt;&gt;(); 并调用 .add() / .peek() / .pop() / .isEmpty() 方法 通常想到递归就和栈有关，想到广搜和滑窗就可以尝试队列（一些数组滑窗用双指针也可以） 用栈实现队列：实现队列的 push() / pop()/ peek() / empty()方法 解法：模拟实现，用两个栈，要取出时倒进另一个即可，代码略 用队列实现栈：实现栈的 push() / pop()/ top() / empty()方法 解法：用两个队列互相转存，每次要取顶部元素就把其中一个队列内元素导入另一个队列至剩一个，即为结果，代码略 有效的括号：一个仅包含左右大中小括号的字符串，判断字符串是否有效，要求左右括号正确顺序匹配 解法：遍历字符，遇左括号入栈，遇右括号与栈顶对比，不匹配则非法；最后栈内非空也非法 删除字符串中的所有相邻重复项：小写字母字符串 s 中相邻重复项删除直到不存在，返回结果（此题一次仅删除两个） 解法：用栈思想直接实现，若一次删除多个需要考虑一些标记 逆波兰表达式求值：后缀表达式字符串列表求值 解法：顺序遍历，遇数字入栈，遇运算符取栈顶两个元素运算再入栈；注意 c++ 中字符串转整型由 stoi(str) 完成，而 java 中由 Integer.parseInt(str) 完成 滑动窗口最大值：有数组 nums 和大小为 k 的滑动窗口从数组最左侧向右移动，每次移动一个，仅能观察到滑动窗口内的元素，返回每次滑动窗口的最大值数组 解法：挺难的，记住思路 —— 维护一个单调递减队列（不同题目不同写法），其 push 操作若加入元素比队尾元素大，则持续排出再加入，其排出操作可以在窗口移除队首元素时执行，具体可以仅比较数值大小（因为相等的元素会一起进入排在队首）；从第一个滑动窗口开始，后续每次仅需要判断处理两个元素，时间复杂度 O(n) 前 k 个高频元素：给定一个非空整数数组，返回其中出现频率前 k 高的元素，可以假定总是合理，结果唯一 解法：使用优先队列 "},{"title":"双指针算法整理","date":"2022-02-24T14:55:40.000Z","url":"/2022/02/24/Alg-Tricks/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/","tags":[["面试","/tags/%E9%9D%A2%E8%AF%95/"],["算法","/tags/%E7%AE%97%E6%B3%95/"],["折磨","/tags/%E6%8A%98%E7%A3%A8/"]],"categories":[["Alg-Tricks","/categories/Alg-Tricks/"]],"content":"注：主要编题顺序及算法模板来自公众号「代码随想录」，强推！ 双指针算法经常用于处理链表或字符串问题，用于匹配或定位操作 移除元素：给定数组 nums 和值 val，原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度 解法：快慢双指针，慢指针遇到等于 val 的停下，和快指针的非 val 值交换（其实不用交换，把快指针指向的值赋过来即可） 反转字符串：将输入的 char[] 反转过来 解法：左右指针交换后靠拢，代码略 剑指Offer 05. 替换空格：把字符串 s 中每个空格替换成 “%20”（不申请额外空间） 解法：先遍历，每有一个空格扩容 2 格 （s.resize(n)）；双指针从后往前将非空格字符正常填充，空格字符用 “%20” 填充 反转字符串里的单词，前面见过 解法：此处考虑空间 O(1) 的解法，先处理字符串中的空格，再反转整串后翻转各单词；注意 c++ 中擦除字符的 s.erase() 单次操作就要至少 O(n) 的复杂度，不推荐使用，而应该用双指针移到前面 反转链表：反转链表的指向，返回反转后的头节点 解法：注意替换顺序即可 删除链表的倒数第 N 个节点 解法：用间隔 N 的快慢指针即可，为了方便删除可以 fast 先走 n+1 步，但此时要注意 n 等于链表长的情况，所以可以在头节点上加上一个不考虑的 虚节点 dummyHead 面试题 02.07. 链表相交：给出两个单链表头节点，返回两个链表相交的节点或 NULL 解法：常规思路知道两个链表的长度然后用有差的两个指针分别跑即可，遍历一次和遍历两次是一样的。。。 环形链表Ⅱ：返回链表开始入环的第一个节点，若无环则 NULL；注意题目形式，链表本身不形成环，但用 pos 值表示末节点指向的下一个节点索引位置，若指向 -1 表示无环（就离谱） 解法：判断环可以用 2 步长的快指针和 1 步长的慢指针，设从头到环的入口节点长度为 x，环入口到相遇点的长度为 y，相遇点再到环入口的长度为 z，容易知环长为 y+z；当相遇时，慢指针运动了 x+y，快指针运动了 x+y+n(y+z)，由于快指针是慢指针的 2 倍速，代入消元得到 x = n(y+z) - y = (n-1)(y+z)+z 此时考虑新的等步长节点分别从 head 和相遇点出发，则一定在环入口相遇 三数之和：给出数组 nums 含 n 个整数，判断是否存在三个元素和为 0，找出所有的元素组合（不是索引组合，可以排序后找） 解法：先排序，在遍历过程中对每个 i 移动两个指针求和，注意如何去重（对 i 指针上的去重和对后续双指针上的去重） 四数之和：同上，找出元素组合且去重 解法：同上，多套用一层 for 循环 "},{"title":"机器学习基础-线性回归","date":"2022-02-24T04:41:25.000Z","url":"/2022/02/24/Machine-Learning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/","tags":[["机器学习","/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"],["线性回归","/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"]],"categories":[["Machine-Learning","/categories/Machine-Learning/"]],"content":"最简单的回归模型，基于矩阵运算和最小二乘优化实现 原理假设目标值和特征之间线性相关，建立线性关系式： \\widehat{y}=w x+b作为回归问题采用均方误差作为损失： L=\\frac{1}{n} \\sum_{i=1}^{n}\\left(\\hat{y}_{i}-y_{i}\\right)^{2}采用最小二乘法或梯度下降法来求解损失最小的参数或调整参数更新（其实都是求导），具体导数表达式 \\begin{gathered} \\frac{\\partial L}{\\partial w}=2\\left(w \\sum_{i=1}^{n} x^{2}-\\sum_{i=1}^{n} x_{i}\\left(y_{i}-b\\right)\\right) \\\\ \\frac{\\partial L}{\\partial b}=2\\left(n b-\\sum_{i=1}^{n}\\left(y_{i}-w x_{i}\\right)\\right) \\end{gathered}衍生的岭回归和 Lasso 即对参数执行了 L2 和 L1 正则化 位于 sklearn.linear_model 中 类/函数 含义 LinearRegression 最小二乘法回归 Ridge 岭回归，加上了 L2 正则化 Lasso 加上了 L1 正则化 岭回归和 Lasso 都可以一定程度缓解多重共线性造成的困扰 创建 岭回归加上了 L2 正则项 \\min _{w}\\|\\boldsymbol{X} \\boldsymbol{w}-\\boldsymbol{y}\\|_{2}^{2}+\\alpha\\|\\boldsymbol{w}\\|_{2}^{2}求导结果 \\left(\\boldsymbol{X}^{\\boldsymbol{T}} \\boldsymbol{X}+\\alpha \\boldsymbol{I}\\right) w=\\boldsymbol{X}^{\\boldsymbol{T}} \\boldsymbol{y}当左边的项可逆时有解，通常适度增大 \\alpha 会增大模型偏移，缓解多重共线性 多了的参数 参数 含义 alpha 惩罚项系数 max_iter None，最大迭代次数 tol 迭代最小降差 solver ‘auto’ 即可 rendom_state "},{"title":"机器学习基础-支持向量机","date":"2022-02-24T00:45:09.000Z","url":"/2022/02/24/Machine-Learning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/","tags":[["机器学习","/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"],["支持向量机","/tags/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"]],"categories":[["Machine-Learning","/categories/Machine-Learning/"]],"content":"支持向量机被认为是最强大的传统机器学习算法，一般对数据尝试随机森林，支持向量机，xgboost，lgbm 即可 操作 显示概率SVM 对样本分类可以返回样本到决策边界的距离，用此距离评估样本分类概率 绘制 ROC 曲线 原理最初是作为分类器，其目标在于找出一个超平面来划分数据集，使得分类误差尽可能小，进一步的启发式的在泛化数据上误差少（并不知道泛化数据分布，因此还是基于已知数据集来学习） 决策边界：找到的一个超平面划分归类数据集 边际：算法会计算决策边界到两类数据集样本最近的距离并取相等的情况作为决策边界，此时的2 * 最近距离即称为边际，也即两个最近样本的超平面法向距离，启发式地最大化边际实现泛化性能 假定二分类样本的标签取值 (-1,1)，特征构成向量 $x_i$ ，在此特征空间上的超平面表示形式有： w^{T} \\boldsymbol{x}+b=0容易发现对该超平面上任意两点都有 w^{T} *\\left(x_{a}-x_{b}\\right)=0也即此处的 $w$ 向量即垂直于超平面，任取超平面一侧的样本点，均可得到一致的正负性，由此来表示二分类，具体哪一边为正并没有大影响 优化目标最小化边际，从边界两侧的支持向量中各取一个点容易发现（等比缩放即可） \\boldsymbol{w} \\cdot \\boldsymbol{x}_{p}+b=1, \\quad \\boldsymbol{w} \\cdot \\boldsymbol{x}_{r}+b=-1从而可以由解析几何求 w 方向分量得到边际的表达式 \\begin{aligned} \\frac{w \\cdot\\left(x_{p}-x_{r}\\right)}{\\|w\\|} &=\\frac{2}{\\|w\\|} \\\\ \\therefore d &=\\frac{2}{\\|w\\|} \\end{aligned}因此也就转化为求解最小值： f(w)=\\frac{\\|w\\|^{2}}{2}此时与具体哪些样本被分为支持向量没有关系，其他约束仅有样本分类约束，称为函数间隔 y_{i}\\left(\\boldsymbol{w} \\cdot \\boldsymbol{x}_{i}+b\\right) \\geq 1, i=1,2 \\ldots N综合得到整体的损失函数： \\min _{w, b} \\frac{\\|\\boldsymbol{w}\\|^{2}}{2}\\\\ subject\\space to\\space y_{i}\\left(\\boldsymbol{w} \\cdot \\boldsymbol{x}_{i}+b\\right) \\geq 1, \\quad i=1,2, \\ldots N具体可以理解为在满足下方的不等式约束条件下最小化上方的函数，引入拉格朗日对偶函数来求解 拉格朗日乘子法针对凸优化问题，均可以尝试采用拉格朗日乘子法将其转化为包含约束的可导式，在此处具体可写为 L(w, b, \\alpha)=\\frac{1}{2}\\|w\\|^{2}-\\sum_{i=1}^{N} \\alpha_{i}\\left(y_{i}\\left(\\boldsymbol{w} \\cdot \\boldsymbol{x}_{i}+b\\right)-1\\right) \\quad\\left(\\alpha_{i} \\geq 0\\right)关于后面的累加式，考虑分类正确和错误的样本对应的 $\\alpha_i$ 即可确定最大化目标下理想的取值 关于此式的具体优化目标为 \\min _{w, b} \\max _{\\alpha_{i} \\geq 0} L(w, b, \\alpha) \\quad\\left(\\alpha_{i} \\geq 0\\right)看到此目标式的最小化目标，很自然地想到求导获取极值点，导一下看看： \\begin{aligned} L(w, b, \\alpha) &=\\frac{1}{2}\\|w\\|^{2}-\\sum_{i=1}^{N} \\alpha_{i}\\left(y_{i}\\left(\\boldsymbol{w} \\cdot \\boldsymbol{x}_{i}+b\\right)-1\\right) \\\\ &=\\frac{1}{2}\\|w\\|^{2}-\\sum_{i=1}^{N}\\left(\\alpha_{i} y_{i} \\boldsymbol{w} \\cdot \\boldsymbol{x}_{i}+\\alpha_{i} y_{i} b-\\alpha_{i}\\right) \\\\ &=\\frac{1}{2}\\|w\\|^{2}-\\sum_{i=1}^{N}\\left(\\alpha_{i} y_{i} \\boldsymbol{w} \\cdot \\boldsymbol{x}_{i}\\right)-\\sum_{i=1}^{N} \\alpha_{i} y_{i} b+\\sum_{i=1}^{N} \\alpha_{i} \\\\ &=\\frac{1}{2}\\left(\\boldsymbol{w}^{\\boldsymbol{T}} \\boldsymbol{w}\\right)^{\\frac{1}{2}} * 2-\\sum_{i=1}^{N}\\left(\\alpha_{i} y_{i} \\boldsymbol{w} \\cdot \\boldsymbol{x}_{i}\\right)-\\sum_{i=1}^{N} \\alpha_{i} y_{i} b+\\sum_{i=1}^{N} \\alpha_{i} \\\\ &=\\frac{1}{2} \\boldsymbol{w}^{T} \\boldsymbol{w}-\\sum_{i=1}^{N}\\left(\\alpha_{i} y_{i} \\boldsymbol{w} \\cdot \\boldsymbol{x}_{i}\\right)-\\sum_{i=1}^{N} \\alpha_{i} y_{i} b+\\sum_{i=1}^{N} \\alpha_{i} \\\\ \\frac{\\partial L(\\boldsymbol{w}, b, \\alpha)}{\\partial \\boldsymbol{w}} &=\\frac{1}{2} * 2 \\boldsymbol{w}-\\sum_{i=1}^{N} \\alpha_{i} y_{i} \\boldsymbol{x}_{i} \\\\ &=\\boldsymbol{w}-\\sum_{i=1}^{N} \\alpha_{i} y_{i} \\boldsymbol{x}_{i}=0 \\rightarrow \\boldsymbol{w}=\\sum_{i=1}^{N} \\alpha_{i} y_{i} \\boldsymbol{x}_{i} \\\\ \\frac{\\partial L(\\boldsymbol{w}, b, \\alpha)}{\\partial b} &=\\sum_{i=1}^{N} \\alpha_{i} y_{i}=0 \\rightarrow \\sum_{i=1}^{N} \\alpha_{i} y_{i}=0 \\end{aligned}经过对偶函数的约束和转换过程，最终的目标函数变化为： \\max _{\\alpha_{i} \\geq 0}\\left(\\sum_{i=1}^{N} \\alpha_{i}-\\frac{1}{2} \\sum_{i, j=1}^{N} \\alpha_{i} \\alpha_{j} y_{i} y_{j} \\boldsymbol{x}_{i} \\cdot \\boldsymbol{x}_{j}\\right)核函数相当于检索出一类特征升维空间，在此类空间中向量的点积等价于原特征空间中向量经过指定映射后的点积 —— 虽然核函数用这个向量函数来表示，但可以理解为其对应了这样一类映射空间 K(u, v)=\\Phi(u) \\cdot \\Phi(v)此时的损失函数 \\begin{aligned} L(w, b, \\alpha) &=\\frac{1}{2}\\|w\\|^{2}-\\sum_{i=1}^{N} \\alpha_{i}\\left(y_{i}\\left(\\boldsymbol{w} \\cdot \\boldsymbol{\\Phi}\\left(\\boldsymbol{x}_{i}\\right)+b\\right)-1\\right) \\\\ L_{d} &=\\sum_{i=1}^{N} \\alpha_{i}-\\frac{1}{2} \\sum_{i, j} \\alpha_{i} \\alpha_{j} y_{i} y_{j} \\boldsymbol{\\Phi}\\left(\\boldsymbol{x}_{i}\\right) \\boldsymbol{\\Phi}\\left(\\boldsymbol{x}_{j}\\right) \\end{aligned}可选核函数 输入 含义 针对类型 表达式 “linear” 线性核 线性 原点积 “ploy” 多项式核 偏线性 (\\gamma(x \\cdot y)+r)^{d} “sigmoid” 双曲正切核 非线性 \\tanh (\\gamma(x \\cdot y)+r) “rbf” 高斯径向基 偏非线性 e^{-\\gamma\\ x-y\\ ^{2}}, \\gamma&gt;0 软间隔当两组数据几乎完全线性可分，但决策边界在训练集上存在较小的训练误差，则称为存在“软间隔” 为了将这些被分类错误的样本重新分类正确，先考虑引入松弛系数来放宽不等式约束，回忆最初的约束严格要求样本点到决策边界的距离不小于一定值，对每个样本放宽此距离约束来使得分类正确： \\begin{aligned} &\\boldsymbol{w} \\cdot \\boldsymbol{x}_{i}+b \\geq 1-\\zeta_{i} \\text { if } y_{i}=1 \\\\ &\\boldsymbol{w} \\cdot \\boldsymbol{x}_{i}+b \\leq-1+\\zeta_{i} \\text { if } y_{i}=-1 \\\\ \\zeta_i > 0 \\end{aligned}原本就正确分类的样本对应的 松弛系数 即为 0，而错误越严重的样本其系数越大 最终加上软间隔的损失函数为 \\begin{aligned} &\\min _{w, b, \\zeta} \\frac{\\|\\boldsymbol{w}\\|^{2}}{2}+C \\sum_{i=1}^{n} \\zeta_{i} \\\\ &\\text { subject to } \\quad y_{i}\\left(\\boldsymbol{w} \\cdot \\boldsymbol{\\Phi}\\left(\\boldsymbol{x}_{i}\\right)+b \\geq 1-\\zeta_{i}\\right) \\\\ &\\zeta_{i} \\geq 0 \\\\ &i=1,2, \\ldots N \\end{aligned}同样转化为 \\begin{gathered} L_{D}=\\sum_{i=1}^{N} \\alpha_{i}-\\frac{1}{2} \\sum_{i, j} \\alpha_{i} \\alpha_{j} y_{i} y_{j} \\Phi\\left(x_{i}\\right) \\Phi\\left(x_{j}\\right) \\\\ \\text { subject to } C \\geq \\alpha_{i} \\geq 0 \\end{gathered}惩罚系数 C对松弛系数的惩罚项系数 C，在创建 svc 实例时指定，默认 0，取值非负"},{"title":"机器学习基础-聚类算法","date":"2022-02-23T08:21:00.000Z","url":"/2022/02/23/Machine-Learning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80-%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/","tags":[["机器学习","/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"],["聚类","/tags/%E8%81%9A%E7%B1%BB/"]],"categories":[["Machine-Learning","/categories/Machine-Learning/"]],"content":"聚类是一种典型的无监督学习，每一个样本都没有一个标准的所属类判断（无人为监督） K-Means 聚类可以认为是最简单的聚类，甚至是最简单的机器学习算法 K-Means 聚类具体流程： 随机抽取 K 个样本作为最初的质心 循环，每轮遍历所有的样本： 每个样本点分配到距离最近的一个质心，生成 K 个族 对每个族，计算所有被分到该族的样本点的平均值作为新的质心 质心不再变化时停止迭代，得到聚类结果 聚类效果认为同一个族中数据是相似的，不同族则应该差异明显，通常采用距离大小衡量两个样本点的相似度，有几种可选的距离度量： 欧几里得距离: d(x, \\mu)=\\sqrt{\\sum_{i=1}^{n}\\left(x_{i}-\\mu_{i}\\right)^{2}}\\\\ 曼哈顿距离: d(x, \\mu)=\\sum_{i=1}^{n}\\left(\\left|x_{i}-\\mu\\right|\\right)\\\\ 余弦距离: \\cos \\theta=\\frac{\\sum_{1}^{n}\\left(x_{i} * \\mu\\right)}{\\sqrt{\\sum_{1}^{n}\\left(x_{i}\\right)^{2}} * \\sqrt{\\sum_{1}^{n}(\\mu)^{2}}}确定一个距离度量（在聚类前就确定了）后可以计算 簇内平方和（cluster Sum of Square）又称为 Inertia \\text { Cluster Sum of Square }(C S S)=\\sum_{j=0}^{m} \\sum_{i=1}^{n}\\left(x_{i}-\\mu_{i}\\right)^{2}=\\sum^m_{j=0}d^2(x,\\mu)进而有整体平方和（Total Cluster Sum of Square）为簇内平方和的和 轮廓系数使用 inertia 有几个缺点，不是很适合用于评估聚类结果： 取值无界，不确定当前是否以达到聚类的极限 计算受到特征数目的影响 受到聚类数 K 的影响，显然聚类越多该数值越小，但模型并不变好 对数据分布有凸分布要求 而轮廓系数则较为合适，其用两个指标来评估聚类效果： 样本与其所在的簇中的其他样本的相似度 a，等于样本与同一簇中所有其他点之间的平均距离 样本与其他簇中的样本的相似度 b，等于样本与下一个最近的簇中的所有点之间的平均距离 一般期望 b - a 越大越好，单个样本的轮廓系数如下 s=\\frac{b-a}{\\max (a, b)}= \\begin{cases}1-a / b, & \\text { if } ab\\end{cases} 用法 初始化与早停K-Means++ 是一个比较好的初始化质心的方法，会尽可能选择差异更大的几个点作为初始质心开始循环，用 init=&#39;k-means++&#39; 来指定（是默认值） 最大迭代次数用于控制计算时间，而聚类事实上总是能收敛的： max_iter：整数，默认 300 tol：浮点数，默认 1e-4，两次迭代间 Inertia 减小量若小于此值则停止迭代 "},{"title":"机器学习基础-逻辑回归","date":"2022-02-23T06:57:46.000Z","url":"/2022/02/23/Machine-Learning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/","tags":[["机器学习","/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"],["逻辑回归","/tags/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"]],"categories":[["Machine-Learning","/categories/Machine-Learning/"]],"content":"原理基于线性回归 z=\\theta_{0}+\\theta_{1} x_{1}+\\theta_{2} x_{2}+\\ldots+\\theta_{n} x_{n}=\\boldsymbol{\\theta}^{T} \\boldsymbol{x} \\quad\\left(x_{0}=1\\right)采用最小二乘法来求解上方的参数 传统线性回归的结果是连续的预测值 y_pred，为了处理分类问题，考虑将实数空间上的值映射到 [0,1] 区间上的 Sigmoid 函数： g(z)=\\frac{1}{1+e^{-z}}将线性回归的预测值代入函数得到： g(z)=y(x)=\\frac{1}{1+e^{-\\boldsymbol{\\theta}^{T} \\boldsymbol{x}}}计算 y(x) 的形似几率取对数得到： \\ln \\frac{y(x)}{1-y(x)}=\\boldsymbol{\\theta}^{T} \\boldsymbol{x}实际上逻辑回归处理了分类问题，用以上 sigmoid 函数将连续特征变换到 [0,1] 区间上，以此反映经过模型对当前特征真实标签的拟合程度，如真实标签为 1，则经过模型尽可能将值靠近 1. 因此逻辑回归模型的损失函数为 J(\\theta)=-\\sum_{i=1}^{m}\\left(y_{i} * \\log \\left(y_{\\theta}\\left(x_{i}\\right)\\right)+\\left(1-y_{i}\\right) * \\log \\left(1-y_{\\theta}\\left(x_{i}\\right)\\right)\\right)其中 $yi$ 为样本真实标签 0 或 1，相应的求和项中某一项即为 0；$y\\theta(x_i)$ 为样本经过模型预测的结果，在 (0,1) 范围内。 采用梯度下降或者拟牛顿法来最小化交叉熵误差值，等价于最大似然估计 对损失函数有正则化方法来避免参数 $\\theta$ 过于复杂发生过拟合， \\begin{gathered} J(\\theta)_{L 1}=C * J(\\theta)+\\sum_{j=1}^{n}\\left|\\theta_{j}\\right|(j \\geq 1) \\\\ J(\\theta)_{L 2}=C * J(\\theta)+\\sqrt{\\sum_{j=1}^{n}\\left(\\theta_{j}\\right)^{2}}(j \\geq 1) \\end{gathered}L1 正则化采用参数分量的绝对值，因此在最小化损失中会尽可能地将 $\\theta_j$ 降至 0，达成一定程度的特征选择作用； C 是正则化强度的倒数，默认 1.0，越小时约注重优化正则项。 用法 一般选取哪种正则化方法不会有很大差异，后续可以绘制与 C 相关的曲线确定合适的正则化参数"},{"title":"机器学习基础-降维算法","date":"2022-02-23T06:08:41.000Z","url":"/2022/02/23/Machine-Learning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80-%E9%99%8D%E7%BB%B4%E7%AE%97%E6%B3%95/","tags":[["机器学习","/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"],["降维","/tags/%E9%99%8D%E7%BB%B4/"]],"categories":[["Machine-Learning","/categories/Machine-Learning/"]],"content":"不同于基于方差和相关程度的特征选择，特征降维可以通过矩阵分解的方法将特征之间的共同作用也提取出来，并尽可能保留他们的分布，最终得到维数降低而方差变化不大的新特征组合，新特征通常是原特征的线性组合，一般不具有解释性。 关于降维算法使用 主成分分析 PCA 通常就够，再进一步可以尝试 奇异值分解 SVD 主成分分析 PCA 确认目标维数几种方法取其一即可 绘制累积可解释方差贡献率曲线，选取达到足够贡献率的前 k 个即可 最大似然估计方法 根据信息量占卜选超参数，输入所需最少信息量 其中 svd_solver 参数通常就选择 ‘auto’ 逆变换由于 PCA 方法实际上是进行矩阵的运算随后选取其中重要性最高的几个维度，因此可以认为逆变换能保留大部分的原数据信息，而被舍弃的信息则无法由逆变换还原 原理思考方向大致思维方向可以从 1. 最大化方差 或 2. 最小化降维损失（即样本信息损失） 其中最大化方差理论即认为信息具有较大的方差，而噪声具有较小的方差；因此最好的 k 维特征是投影后样本在每一维度上的方差都尽可能大的特征组合 特征值分解 A= Q\\Sigma Q^{-1}对于矩阵 A，可以找到其特征向量进行正交化单位化得到正交向量矩阵 Q，使得上式成立，其中的 $\\Sigma$ 即为特征值构成的对角阵 奇异值分解任意矩阵总是存在一个奇异值分解 $A=U\\Sigma V^T$ 其中假设 A 的大小为 m*n ，则 U 的大小 m*m ，其正交向量被称为左奇异向量；$\\Sigma$ 大小为 m*n ，且仅对角线上元素非零，； V 的大小为 n*n ，其正交向量被称为右奇异向量 考虑其计算方法 A=U\\Sigma V^T \\rightarrow A^T=V\\Sigma^T U^T \\rightarrow A^T A = V\\Sigma^T U^T U\\Sigma V^T = V\\Sigma^2 V^T矩阵乘法的时间复杂度为 O(n^3) 使用在使用中通常计算协方差矩阵 $\\frac{1}{n}AA^T$ 然后使用特征值分解方法得到协方差阵的特征值和特征向量，对特征值从大到小排序取前 k 个即为降维目标空间的基向量，构成特征向量矩阵 P，原样本转换后即为 $B = PA$"},{"title":"机器学习基础-预处理","date":"2022-02-23T00:47:52.000Z","url":"/2022/02/23/Machine-Learning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80-%E9%A2%84%E5%A4%84%E7%90%86/","tags":[["机器学习","/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"],["预处理","/tags/%E9%A2%84%E5%A4%84%E7%90%86/"]],"categories":[["Machine-Learning","/categories/Machine-Learning/"]],"content":"数据不完善（噪声、缺失、偏态），再高级的算法都得不到好的效果 一下数据预处理方法基本都可以独立使用再组合，因此每处将介绍并补充操作方法。 数据预处理sklearn.preprocessing 模块基本包含所有的数据预处理内容 数据无量纲化不同量纲下计量的数据其分布可能由较大的差异，如 m 和 km 计量下的方差差距很大；或者计算特征下欧式距离时也会由量纲不合适的特征影响过大 线性的无量纲化：中心化、缩放 在使用中，fit 时都会略过空值 Nan，而 transform 时保留 缩放 MinMaxScaler即将数据按照差值比例缩放到指定范围内（默认[0,1]） x^{*}=\\frac{x-\\min (x)}{\\max (x)-\\min (x)}sklearn 会自动将各列（即一个特征）进行缩放返回 中心化 StandardScaler当作正态分布来中心化 x^{*}=\\frac{x-\\mu}{\\sigma}即是统计该特征下所有样本的均值和样本方差进行中心化 其他 MaxAbsScaler：按最大值的绝对值压缩至[-1,1]，不改变 0 值 RobustScaler：按照分位数压缩 缺失值处理一般的缺失值填充（均值、中位数填充）用 pandas 的 fillna() 方法即可处理，也可以用 sklearn 的内置类来处理 参数 含义&amp;输入 missing_values 描述数据中什么认为是空值，默认 np.nan strategy 默认均值填充；可选 “mean”,”median”,”most_frequent”,”constant” fill_value 当用常数填充时指定这个常数，常用 0 copy 是否返回副本，默认 True （最好不要修改到原数据） 分类型特征处理大多数算法只能处理数值型数据，通常将文字分类型特征转为数值型或哑变量，也即独热编码 标签编码 特征编码特征可能是有级别先后的关系，也可能是名义上的分类，互相之间没有比较关系 单纯数值转换按照可取的值分配整数，可能产生出并不符合实际的数值关系 对象的 classes_ 属性查看具体哪些标签转换 独热编码转换 连续型特征处理二值化和分箱，即按照一些值将连续性转换为几个组实现分类，后续再独热编码或其他操作 二值化可以认为是将数值转化为是否的特征 分箱可以指定数来分区间（不好确定），或者按照数据分布的分位数或样本数量的分位数 参数 含义&amp;输入 n_bins 每个特征的分箱数，默认 5 encode 编码方式，默认 “onehot”，返回稀疏矩阵；可选”ordinal”编码为整数；”onehot-dense”哑变量返回密集数组 strategy 定义箱宽方式，默认”quantile”：样本数等位分箱；”uniform”：数值分布等宽分箱；”kmeans”：按聚类分箱 特征工程第一步是理解数据，大致判断哪些数据对要判断的结果有较强的关联，此时通常将关联性较弱的特征舍弃，将关联性强的特征可以适当拓展 Filter 过滤法根据一些统计检验的指标来选择特征 方差过滤按照特征本身的样本方差来过滤，方差低说明变化很小，与样本类别关系不大 相关性过滤通过检查特征与标签的相关性来考虑过滤条件 卡方过滤基于卡方检验来评估特征与标签地相关性的方法，其中简单介绍卡方检验： 首先明确卡方检验通常用于离散变量，即要求至少标签为分类变量（否则分箱） 原假设 $H_0$ ：特征的分布与离散分布 F(x) 独立，此处的 F(x) 由标签的频率近似，设标签有 k 个取值，共 n 个样本，各标签含 $n * p_i$ 个样本 将特征分成 k 个箱，每个有频数 $f_i$ ，从而有统计量 \\chi^2=\\sum^k_{i=1}\\frac{(f_i-np_i)^2}{np_i}在原假设成立情况下服从自由度 k-1 的卡方分布 如何确定 k可以绘制曲线比较交叉验证效果（不推荐） 实际卡方检验推断两组数据分布的差异，返回卡方值和 P 值，通常基于 P 值判断是否相互独立 P 值 &lt;=0.05 或 0.01 &gt;0.05 或 0.01 数据差异 差异不是自然形成的 差异是样本误差 相关性 数据相关 独立 原假设 拒绝原假设 接受原假设 F 检验又称方差齐性检验，寻找数据之间的线性关系，可以用于分类和回归，分别用feature_selection.f_classif 和 feature_selection.f_regression 适合处理正态分布数据（可以先标准化）,根据 p 值确定保留多少特征，再结合 SeletKBest 来过滤 互信息法可以捕获线性和非线性关系，用于回归和分类，分别由类 feature_selection.mutual_info_classif 和 feature_selection.mutual_info_regression 完成，返回每个特征与目标之间的互信息量的估计，在 [0,1] 取值，0 表示独立，1 表示完全相关 Embedded 嵌入法暂略 Wrapper 包装法"},{"title":"机器学习基础-随机森林","date":"2022-02-22T10:41:36.000Z","url":"/2022/02/22/Machine-Learning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80-%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/","tags":[["机器学习","/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"],["随机森林","/tags/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/"]],"categories":[["Machine-Learning","/categories/Machine-Learning/"]],"content":"简单介绍一下集成学习的思想和随机森林在 sklearn 中的用法 用法集成算法相关主要在 sklearn.ensemble 模块中 观察 决策树数目 的学习曲线 指定 random_state 参数可以控制每次生成一组固定的树，但这些树互相也是不同的； 一般认为，生成各个树的随机性越大，随机森林的效果越好 rfc.estimators 返回训练后的各个决策树对象列表，可以取索引定位到对象 集成算法比较经典的继承方法大致分为 bagging 和 boosting，还有 stacking，其核心在于以多个有差异的学习器来处理数据，汇总得到一个综合的结果，期望获取比单个模型更好的回归或分类表现。其中 bagging ：核心是构建多个相互独立的学习器（比如修改超参或随机种子），然后对预测结果平均或投票（随机森林） boosting ：学习器按照顺序构建，对单次难以评估的样本提高学习权重进行深入的训练（GBDT、XGBoost） stacking ：也是一种集成算法，以分类器为例，第一阶段用多个强学习器对训练样本分类，得到各个学习器的预测结果，然后以这些预测结果作为新的样本特征 x，保留样本真实标签作为 y 传入较弱（避免过拟合）的学习器得到最终预测 "},{"title":"机器学习基础-综述","date":"2022-02-22T07:24:26.000Z","url":"/2022/02/22/Machine-Learning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80-%E7%BB%BC%E8%BF%B0/","tags":[["机器学习","/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"],["综述","/tags/%E7%BB%BC%E8%BF%B0/"]],"categories":[["Machine-Learning","/categories/Machine-Learning/"]],"content":"综述一些机器学习思想和 sklearn 中常用的命令形式 工程流程 获取数据，明确判断目标（分类、回归等），查看特征的缺失情况和统计分布 train.info() \\ train.describe() （维度较低或一定程度可解释时）绘制条形图或散点图来观察特征与标签的关系，如分类问题绘制条形图等 数据预处理，特征选择 将名义变量进行编码，离差较大的连续型变量进行离散化，适中的连续型变量进行缩放或中心化；适当地处理缺失值（填充或放弃特征），先尝试一些通用模型查看基础效果 根据特征量确定是否要过滤，若要过滤则推荐先方差过滤，然后根据互信息过滤，并再过滤过程中观察交叉验证比较平均效果 模型性质最近邻 KNN，决策树，支持向量机 SVM，神经网络，回归算法，都需要遍历特征或升维来进行运算，此类算法在应用前的特征选择尤为重要 常用命令sklearn 的训练和测试基本遵循一个流程： 从模型对应的子模块下实例化（指定一些模型超参） 用实例化对象学习训练数据集（.fit(trainX,trainY)） 观察当前训练结果在测试集上的表现（.score(testX,testY)） 直至感觉对了后用于模型预测或其他（.predict(realX,realY)） 评分指标可以查看所有可用于评估模型效果的指标 在交叉验证中用 scoring=... 传入 数据划分对于监督学习，通常我们拥有一部分已经标注完成的数据，希望从此处学习到一些特征性来预测未进行标注的新数据，而为了评估学习器的成果，我们也只能在已经标注好的数据中取部分来评估，因此在最终预测前总是在和已标注数据玩儿 手动划分通常也需要进行多次不同的划分来取平均的结果，因此可以采用交叉验证来快速实现 按照传入的交叉验证次数 n 随机均分数据集，每次取其中一份作为测试集，其余为训练集来学习，最终返回各次在测试集上的得分，此处若不指定 scoring 参数则会按照模型自己的评分来给出 交叉验证也可以用于选择合适的超参数，若在当前组的交叉验证结果都比较相近，说明模型的效果不依赖于样本的划分，可以具有较好的泛化性能，此时若测试效果可以接受，则能一定程度上接纳超参数 超参数确定基本所有的模型超参数以及一些随机数种子都在实例化时候指定，为了搜索合适的超参数通常都是在一定值的范围内去控制变量将结果绘图 在一般时期（理解不深，时间充裕）情况下可以采用遍历绘图或网格搜索来检索测试集上最优的参数；而对模型参数有较深理解后，可以根据当前的模型表现来平衡偏差和方差 网格搜索。。。 偏差方差平衡 E(f ; D)=\\operatorname{bias}^{2}(x)+\\operatorname{var}(x)+\\varepsilon^{2} 偏差：模型的预测值与真实值之间的差异，过拟合时通常偏差较低，此时方差接近数据本身分布情况 方差：模型预测结果与该次预测平均的误差水平（解释的不如不解释），欠拟合的时候容易方差较低（比如唯一值预测） 偏差大 偏差小 方差大 模型对此数据不合适，换模型 过拟合；模型太复杂； 方差小 欠拟合；模型太简单；预测稳定但很不准确 非常理想的模型适配 评估指标通常对监督学习中的分类问题和回归问题，各有一套常用指标评估模型效果 分类问题分类问题直觉上即有一些评估指标衡量分类的准确性，具体如下 预测1 预测0 真实1 11 10 总真实1：11+10 真实0 01 00 总真实0：01+00 预测1：11+01 预测0：10+00 通用指标准确率 Accuracy：预测正确的样本占总样本比例 \\text { Accuracy }=\\frac{11+00}{11+10+01+00}捕捉少数类水平 精确度 Precision：真正为 1 样本占预测为 1 的样本比例，越低越反映误伤了 0 \\text { Precision }=\\frac{11}{11+01} 召回率 Recall：对真样本预测正确的样本占所有真样本的比例，当期望尽可能找出少数类时重视更高的召回率 \\text { Recall }=\\frac{11}{11+10} F1 measure：由于召回率和精确度此消彼长，因此追求平衡产生了综合指标，追求较高的该度量能使得其中两个指标都比较高 F-\\text { measure }=\\frac{2}{\\frac{1}{\\text { Precision }}+\\frac{1}{\\text { Recall }}}=\\frac{2 * \\text { Precision } * \\text { Recall }}{\\text { Precision }+\\text { Recall }}判断多数类的考量 特异度 Specificity：对 0 样本预测正确的样本占所有 0 样本的比例，衡量了模型将多数类判断正确的能力 \\text { Specificity }=\\frac{00}{01+00} 假正率 False positive rate：1 - 特异度，衡量模型将多数类判断错误的能力 F P R=\\frac{01}{01+00}用法度量基本都在 sklearn.metrics 中 类 含义 confusion_matrix 混淆矩阵 accuracy_score 准确率 precision_score 精确度 recall_score 召回率 precision_recall_curve 精确度-召回率平衡曲线 f1_socre F1 measure 绘制 ROC 曲线，计算 AUC 面积ROC 曲线以 FPR 为横坐标，Recall 为纵坐标绘制曲线，下方面积越大越优，取对角线切点为最优点 sklearn,metrics.roc_curve(y_true,y_score,pos_label=None,sample_weight=None,drop_intermediate=True) y_true：数组，形状=[n_samples]，真实标签 y_score：数组，置信度分数，可以是正类样本的概率值，或置信度分数（如SVM 的 decision_function 返回的距离 pos_label：整数或字符串，默认 None，描述正类样本 sample_weight：形如 [n_samples] 样本权重 drop_intermediate：默认 True，会舍弃一些 ROC 曲线上不显示的阈值点 返回三个值：FPR、Recall、阈值（视输入为概率阈值或距离阈值） "},{"title":"机器学习基础-决策树","date":"2022-02-22T06:40:25.000Z","url":"/2022/02/22/Machine-Learning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80-%E5%86%B3%E7%AD%96%E6%A0%91/","tags":[["机器学习","/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"],["决策树","/tags/%E5%86%B3%E7%AD%96%E6%A0%91/"]],"categories":[["Machine-Learning","/categories/Machine-Learning/"]],"content":"简单介绍一下决策树原理（目标自己理解为主）和 sklearn 中的用法 分类树用法 搜索合适的超参数 max_depth 严格限制深度，建议从 3 开始 min_samples_leaf &amp; min_samples_split 前者限制分枝后的叶子含样本数（不满足则不分枝）；后者限制分之前的节点样本数，小则不分支 max_feature &amp; min_impurity_decrease 前者限制分支使用的总特征数（比较玄学），后者限制进行分支的增益下限 class_weight &amp; min_weight_fraction_leaf 处理样本不平衡，用到再查 可视化可以看到树的结构，不过帮助不大 分类树原理通常有分类树和回归树，主要原理基本一致，分类树为在每一个层级选择信息增益最大的属性作为划分属性形成分支 核心优化目标决策树的每一次分支主要核心在于尽可能最大化信息增益（ID.3 或 C4.5决策树）、或者最小化基尼系数（CART决策树） 信息熵对一组样本集合 D，已知其分类有 k 类（有监督），各类所占比例为 $p_k$，则有其信息熵为 Entropy(D) = -\\sum p_k\\log_2p_k同时，若样本的属性 A 具有 v 个取值（A 为离散属性或连续属性按区间划分），对 D 采用属性 A 划分后的下一层每一组设有 $D^v$ 作为子样本集，此时可以计算每个 $D^v$ 的信息熵，最终得到信息增益： Gain(D,A)=Entropy(D) - \\sum^v\\frac{|D^v|}{|D|}Entropy(D^v)ID.3 决策树即选择最大化信息增益来作为分支标准； 类似的有增益率： Gain-ratio(D,A)=\\frac{Gain(D,A)}{IV(A)}\\\\ 其中IV(A)=-\\sum^v\\frac{\\abs {D^v}}{\\abs {D}}\\log_2\\frac{\\abs {D^v}}{\\abs {D}}由属性A确定基尼系数同样在样本集 D 下有 k 个分类，此时基尼系数为 Gini(D)=\\sum_k\\sum_{k'\\neq k}p_kp_{k'}=1-\\sum p_k^2回归树用法 实例化并进行交叉验证，返回交叉验证 10 次的 均方误差，观察模型在此数据集上的稳定性 回归树的评分rgr.score(Xtest) 默认返回的是 R 平方，其定义如下： \\begin{gathered} R^{2}=1-\\frac{u}{v} \\\\ u=\\sum_{i=1}^{N}\\left(f_{i}-y_{i}\\right)^{2} \\quad v=\\sum_{i=1}^{N}\\left(y_{i}-\\hat{y}\\right)^{2} \\end{gathered}其中 $f_i$ 为各样本模型预测值，$y_i$ 为样本真实值，$\\hat y$ 为样本真实值的均值，而习惯上我们通常采用均方误差 MSE 评估回归的结果 MSE=\\frac{1}{N}\\sum^N_{i=1}(f_i-y_i)^2可以指定 scoring=&quot;neg_mean_squared_error&quot; 以负均方误差作为评估指标 回归树原理回归数为在每个节点划分后的预测数值和节点内数据真实数值的总体偏差尽可能小，此偏差有几种计量选择 核心优化目标回归即是指连续值的预测计算，因此每个节点给出一个值，而节点内数据各自有真实值，要最小化真实值和节点预测值的偏差 “mse”：选取均方误差作为分支优化目标 “friedman_mse”：费尔德曼均方误差 “mae”：绝对平均误差 "},{"title":"字符串常用解法整理","date":"2022-02-22T03:00:49.000Z","url":"/2022/02/22/Alg-Tricks/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/","tags":[["面试","/tags/%E9%9D%A2%E8%AF%95/"],["算法","/tags/%E7%AE%97%E6%B3%95/"],["折磨","/tags/%E6%8A%98%E7%A3%A8/"]],"categories":[["Alg-Tricks","/categories/Alg-Tricks/"]],"content":"注：主要编题顺序及算法模板来自公众号「代码随想录」，强推！ 在 python 中字符串可以类似列表进行索引切片操作，且其添加也非常方便；在 Java 中操作字符串要注意使用 String 对象方法，如取索引用 .charAt(i)，构建需要拼接的字符串时也注意创建 StringBuffer 或 StringBuilder；在 C++ 中操作 string 对象可以用索引方法获取对应字符如 s[0]，用如 s.size() 返回大小 操作 创建： Java：传入 char[] 或 byte[] 创建，或者直接赋值静态对象； C++：一些构造方法创建定长或截取型字符串 string s1(n, &#39;.&#39;) 定长填充 string s2(&quot;12345&quot;, 1, 3) 定长截取，从 1 索引开始，长度取 3 取子串： Java：s.substring(begin, end) 返回索引从 begin 到 end - 1 处 C++：s.substr(begin, len) 返回索引从 begin 开始，长度为 len 的子串 插入： Java：原 String 不允许修改，使用 StringBuffer 或 StringBuilder 可以传入原串初始化，调用 insert(int offset, Object obj) 来插入 C++：s.insert(s.begin() + i + 1, &#39;.&#39;) 插入的字符新位置索引为 i + 1 题组 反转字符串：处理一个 char[] s，采用双指针前后靠拢交换即可 反转字符串Ⅱ：给定字符串 s 和整数 k ，每隔 2k 个字符对前 k 个字符反转，若剩余字符少于 k 个则全部反转 解法：按照题意模拟每 2k 个操作一次就即可 剑指Offer 05.替换空格：将字符串中所有空格替换成 ‘%20’ 解法注意点：先在原串上扩容，再双指针从后向前替换，避免每次需要移动前面的字符；新建一个字符串然后从前往后填充也可 翻转字符串里的单词：以空格为分割翻转单词（带符号一起）的顺序但保持单词本身，多个空格最后改为一个，并且不要首位空格 解法：推荐解法是先处理空格，再整体翻转全部字符串，再翻转各单词；此处的初等解法即额外空间从后往前填充单词 剑指Offer 58.左旋转字符串Ⅱ：把字符串左侧若干个字符移动到字符串右侧（若不做限制则没什么意义，故考虑原地算法） 解法：先整串翻转，再末 n 个和前 (l-n) 个子串翻转 实现 strStr() 函数，从串 1 （文本串）中找到 串2 （模式串）的索引位置，若无匹配则返回 -1 （标为简单，用逐字符匹配至少能做） 解法：典型找子串问题，有 KMP 算法，先遍历模式串构成其前缀表（下标包括 i 之前的子字符串中，有多大长度的相同前缀后缀） | 下标 | 0 | 1 | 2 | 3 | 4 | 5 || ——— | —— | —— | —— | —— | —— | —— || 模式串 | a | a | b | a | a | f || 前缀表 | 0 | 1 | 0 | 1 | 2 | 0 | 此时的匹配过程中，当文本串和模式串的某个字符不匹配时，不再将模式串上的指针回归到 0，例如当模式串的 j 索引处不匹配时，可以找前缀表的 j-1 索引处（也可以将前缀表向右平移一格形成 next 数组）对应的数值作为转向的索引。 算法过程表示为：先基于模式串求出前缀表或 next 数组，然后遍历文本串过程中借助其快速匹配 重复的子字符串：给定非空字符串，判断是否可以由其一个子串重复多次构成（仅含小写字母，长度不超过10000） 解法：同样可以考虑 KMP 算法过程，其求 next 数组过程中考虑了最长相同前后缀，可以证明若字符串符合题目要求，则其可用于重复生成的子串一定是这个最长相同前后缀，因此可以判断长度是否整除然后匹配 "},{"title":"Hadoop 架构简介","date":"2022-02-19T01:22:55.000Z","url":"/2022/02/19/Data/Hadoop-%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/","tags":[["Hadoop","/tags/Hadoop/"],["Intro","/tags/Intro/"]],"categories":[["Data","/categories/Data/"]],"content":"记录部分课程内容 简介Hadoop 具有： 高可靠性：Hadoop 底层维护多个数据副本，所以即使 Hadoop 某个计算元素或存储出现故障，也不会导致数据的丢失 高扩展性：啊哎集群间分配任务数据，可方便地扩展数以千计的节点 高效性：在 MapReduce 的思想下，Hadoop 是并行工作的，以加快任务处理速度 高容错性：能够自动将失败的任务重新分配 Hadoop 组成 HDFS 架构概述HDFS —— Hadoop Distrubuted File System，是一个分布式文件系统 NameNode ：储存文件的元数据，如文件名，目录结构，文件属性（生成时间、副本数、文件权限），以及每个文件的块列表和块所在的 DataNode 等 DataNode ：再本地文件系统存储文件块数据，以及快数据的校验和。 Secondary NameNode(2nn) ：每隔一段时间对 NameNode 元数据备份。 YARN 架构概述YARN —— Yet Another Resource Negotiator，另一种资源协调这，是 Hadoop 的资源管理器 Resource Manager（RM）：整个集群资源（内存、CPU 等）的管理者 Node Manager（NM）：单个节点服务器资源管理者 Application Master（AM）：单个任务运行的管理者 Container：容器，相当于一台独立的服务器，里面封装了任务运行所需要的资源，如内存、CPU、磁盘、网络等 MapReduce 架构概述将计算过程分为两个阶段：Map 和 Reduce Map 阶段并行处理输入数据 Reduce 阶段对 Map 结果进行汇总 工作流 客户端向 Hadoop 发起任务时，先传入 Yarn 中的 Resource Manager 管理资源向 Node Manager，进入其中的容器来开启 Map 任务和 Reduce 任务 完成任务后存储数据到 DataNode，并在 NameNode 上记录 "},{"title":"数据分析面经整理（业务题）","date":"2022-02-19T01:10:05.000Z","url":"/2022/02/19/Interview/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%EF%BC%88%E4%B8%9A%E5%8A%A1%E9%A2%98%EF%BC%89/","tags":[["interview","/tags/interview/"],["data analysing","/tags/data-analysing/"],["situated quest","/tags/situated-quest/"]],"categories":[["Interview","/categories/Interview/"]],"content":"本文尽量持续更新从公开交流网上浏览到的数据分析岗位面经业务类题，考核内容视岗位关联电商交易额或平台用户活跃度等 名词概念 DAU ：日活，具体如下 MAU ：Monthly Active User, 月活，具体为一个月内（统计周期）去重后的登录或使用某产品的用户数量 ROI ：投资回报率 GMV ：Gross Merchandise Volume 商品交易总额，一定时间段内交易总额 同比、环比：都是描述增长率，同比通常指一个月份对比去年同月份的增长，即非连续周期；环比通常指一个缘分对比相邻前一个月份的增长，即连续周期 简答题 DAU 下降了怎么检查原因 总体思路流程：检查数据准确性；多维度拆分数据；假设原因；确定原因。大体先确定哪一部分的用户减少占主要因素，再确定相应的原因 检查数据准确性：是否有硬件异常；系统统计是否出错；相关联的指标是否有异常 多维度拆分数据：通常分为 用户、渠道、产品 用户可见属性有：新/老用户（新用户引流、老用户留存）、用户渠道（app、小程序、客户端）、用户地区（国家、省份） 登录渠道属性：平台（ios/android、或是某类型手机设备有问题？）、入口（客户端、外链访问） 产品属性：新/旧版本（可能更新功能后变动不佳、或旧版本有遗留问题）、时间点上（是否符合往常的月度/年度周期、 计算影响系数：（维度今日量-维度昨日量）/（今日总量-昨日总量） —— 最好各个维度完全独立且构成全集，即完全分割用户群 建立假设后 外因包括：政策原因、竞品的运营活动、社会事件或评价 漏斗模型：略 哪些指标测度 app 的健康度（什么是健康度） 用户规模和质量：活跃用户指标（统计周期内使用人数）；新增用户指标（周期内首次启用）；用户构成指标（活跃用户中活跃程度分类统计，如连续活跃，回流用户等）；用户留存率指标（新增用户一段时间内仍使用）；每用户总活跃天数指标 参与度：启动次数；使用时长；访问页面数；使用间隔 渠道分析： 引入新功能后，如何评价该新功能的有效性 AB Test 核心内容 ：为同一目标（指标提升或功能上线）制定两个方案，在同一时间维度（同一日或同一周），分别让组成成分相同（相似）的用户群组随机使用一个方案，总结数据后根据显著性检验来进行评估，给出一个大致例子： 以提升转化率指标为例，假定 A 为原方案，B 为新方案，一组用户的转化人数可以看作以转化率为参数 p 的二项分布，从而转化人数的均值方差可以近似地认为是 \\mu = np, \\space \\sigma^2=np(1-p) 建立假设检验，通常选择不会轻易接受的假设作为备择假设，在这里即 B 方案转化率明显大于 A 方案，具体如下： H_0:p_b - p_a \\lessequal 0 \\\\ H_1:p_b - p_a > 0其中的转化率参数为对应方案下的样本参数，使用具体转化人数来估计 根据假设选择检验方法，通常的问题都是双样本的均值显著性检验，根据样本的方差是否已知（通过以往数据估计，可以认为已知）以及两组样本方差是否一致来确定检验方法，通常有 Z 检验（针对大样本）、T 检验（针对小样本）、卡方检验 显著性水平（第一类错误） α 描述在两方案无显著差异情况下拒绝原假设 H_0，即放过了不佳的新方案，通常要求不大于 5%；统计显著性即 1 - α 第二类错误概率 β 描述在 B 方案实际优于 A 方案时拒绝备择假设 H_1，即错杀了一个有提升的方案，通常要求不大于 20%；统计功效即 1 - β 两个值的选择反映了不轻易容许坏方案上线的想法 "},{"title":"数据分析面经整理（技术题）","date":"2022-02-19T01:07:14.000Z","url":"/2022/02/19/Interview/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%EF%BC%88%E6%8A%80%E6%9C%AF%E9%A2%98%EF%BC%89/","tags":[["interview","/tags/interview/"],["data analysing","/tags/data-analysing/"],["tech quest","/tags/tech-quest/"]],"categories":[["Interview","/categories/Interview/"]],"content":"本文尽量持续更新从公开交流网上浏览到的数据分析岗位面经技术类题，考核内容以 sql/hive 相关的查询语句为主 Sql 语法题包括一些例题和常用函数解析 使用中注意点Tips 聚合相关 聚合操作最好在最里层先完成 count() 中可以写成 count(distinct col) 来计数不同的个数 collect_list 、collect_set 也是一种聚合函数，可以将分组构成一个列表字段或者去重后（即集合）的列表字段 连接相关 对于如取最近日期作为当日、不同 id 计数类的操作，可以从原表获取后连接来实现单值字段 合并相关 对于将 in_time 和 out_time 时段视作活跃行为的查询，都可以对两者取出日期然后 union，这样同一天完成 in 和 out 的就归为一条活跃行为，而跨日的也可以当作两天 行列互换操作：pivot、unpivot 函数，需要修改数据库兼容级别至 90 pivot 将列值转为列名，用法如 tb_src pivot (aggfunc(value_column) for pivot_column in (&lt;column_list&gt;)) unpivot 将列名转为列值，用法如 tb_src unpivot (value_column for pivot_column in (&lt;column_list&gt;))| 姓名 | 课程 | 分数 ||—|—|—||张三|语文|74||张三|数学|83||张三|物理|93||李四|语文|74||李四|数学|84||李四|物理|94| 结果|姓名|语文|数学|物理||—|—|—|—||李四|74|84|94||张三|74|83|93| SQL 语句执行顺序：from -&gt; join -&gt; on -&gt; where -&gt; group by -&gt; agg -&gt; having -&gt; select -&gt; distinct -&gt; order by -&gt; limit ，其中从 group by 开始可以使用字段别名（如由聚合操作得到的） 例题 连接两个表后算 30 天内的新用户数量，30 天回购率，人均消费 计算每个用户首次购买的订单 给定用户表，求次日留存率 开播三分钟内无人进入的直播房间号 先 group by 后窗口函数聚合 常用函数case when 可以替换为 if(condition,true_val,false_val) 排序通常在查询语句中的 order by 指定一行以此增序排列，加上 DESC 改为降序；当排序字段相同时可能乱序 日期date(str) ：返回年-月-日格式日期datepart(form, col) ：将传入的日期列返回指定 form 值，例如 指定 weekday 返回 1-7 的周几含义，指定 m 返回月份datediff(date1,date2) ：返回 date1 - date2 得到的天数date_format(date,format) ：例如 ‘%Y-%m-%d %H:%i:%s’timestampdiff(unit,ts1,ts2) ：返回 ts2 - ts1 转为指定时间单位结果 窗口函数func() over(partition by … order by … range/rows between preceding and following) 注意点： rows 和 range 的区别： rows ：框架由开始行和结束行的位置来定义，偏移量是行号与当前行号的差异。比较常用 range ：框架由值范围内的行定义，偏移量是行值与当前行值的差异。不太常用 order by 的影响：无 order by 时窗口范围是整个分区；有 order by 时窗口范围从首行到当前行 和 group by 同时出现时会先 group by 再进行窗口函数的聚合 一般窗口中用 rows 时最好逆序取 following（因为 preceding 时容易发生前面为空而报错） 窗口序数 row_number() ：唯一序数 rank() ：相等值取考前并略过空 dense_rank() ：不略过空 percent_rank() ：百分位排序，(rank-1)/(total-1) cume_dist() ：累积分布序，row_number()/total 跳跃取值 lag(exp_col, offset, default) lead() first_value() last_value() Excel 函数 sumif(条件区域，条件，&lt;求和区域&gt;) sumifs(求和区域，条件区域，条件，…) Pandaspivot_table ：pd.pivot_table(dataframe,index=[cols],columns=[cols],values=[cols],aggfunc=[funcs])没用过，主要是转换多级索引然后进行一定的聚合 统计假设检验概念为主："},{"title":"Pandas Intro","date":"2022-01-20T05:56:10.000Z","url":"/2022/01/20/Data/Pandas-Intro/","tags":[["Pre-Process","/tags/Pre-Process/"],["数据分析","/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"],["Pandas","/tags/Pandas/"]],"categories":[["Data","/categories/Data/"]],"content":"虽然说是 intro ，但是准备把常用指令都存进来并且后续应该懒得补充深入的内容了 核心类Series创建 pd.Series(arr-like[, index=idx-arr]) ：传入一维数组类型对象，可以指定索引或者自行从 0-n pd.Series(dict-like) ：传入字典相当于索引加值一起，默认顺序和字典写入顺序一致，但可以创建时重新指定 index 方法 isnull() / notnull() 返回等长布尔型 Series，可用于布尔索引 属性 索引行为可以类比 ndarray，基本都有复现包括布尔索引、运算广播等 values ：以数组返回其值 index ：返回索引，是一个 pd 内建类例如 RangeIndex(start=0, stop=4, step=1) 对象和其索引都有一个 name 属性，如 se.name / se.index.name DataFrame创建 pd.DataFrame(data) ：传入等长 arr-like 做值的字典，会自动排索引且按照 key 升序排列 方法属性 类同 ndarray 可以取转置对象 T 简单介绍通常数据分析都谈到 numpy, pandas, matplotlib, 以及可能使用到的 seabon, sklearn；不过 pandas 基本集成了 numpy 的数值运算内容，超值 数据读取或创建pandas 可以读取的数据格式包括 execl, csv, table 等，读入后形成数据类型 DataFrame，常用读取函数为 read_csv 和 read_excel，传入参数主要为文件路径，类比 open() csv 是一种（通常）以英文半角逗号为列分割符，以换行符为行分隔符的纯文本数据格式 Series 可以当作从 DataFrame 中取出的一行或一列 DataFrame 的轴向 axis=0 表示各行，axis=1 表示各列（通常2维） 数据概览B 话不多说直接上代码 数据定位简单的索引操作： 获取 index：df.index 指定 index：df.index=[&quot;x&quot;,&quot;y&quot;] 重新设置 index：df.reindex(list(&quot;abcdef&quot;)) 指定某一列作为 index：df.set_index(col,drop=False) 返回 index 的唯一值：df.set_index(col+).index.unique() 直接进行切片（针对行）或字典（针对列）索引，此处的索引一次只能取行或列，可以链式操作 布尔索引上述方法可以传入一个布尔值 array-like 对象（如列表或 Series）来进行索引，例如： 对 Series 调用 .str 方法可以得到字符串类型的 Se，用于调用内置方法获取布尔类型的 Se 可以结合缺失值的判断 pd.isnull() 和 pd.notnull() 来进行处理 定位索引通常先行后列，可处理多级索引 另外常用 loc 和 iloc ，有些微的区别： loc : works on the labels in the index —— 按照标签取数据，对行可以切片或传入 int 列表，对列则要按照标签 iloc : works on the positions in the index (so it only takes integers)，即无论对行列都只接受整数位来索引 数据合并df1.join(df2) 默认把两个 df 按照行索引相同的值左右合并 t1.merge(t2,left_on=&quot;O&quot;,right_on=&quot;X&quot;,how=&quot;outer&quot;) 指定列将两个 df 按照命令形式合并，这个才类似 SQL 中的 join pd.concat(df1,df2,axis=0) 类似 union 按照列合并，需要相同列，改变 axis 参数改变合并方向 数据分组和聚合df.groupby(by=col+) 返回一个 GourpBy 对象，对此对象可以进行 for 循环遍历，每个元素是一个分组后的一个 tuple ，此 tuple 第一个值为分组的组标题，第二个值为一个子 DataFrame GroupBy 对象形如 gp[col+] 仍然返回一个 GroupBy 对象，表示分组后取某些列； 事实上可以和 DataFrame 一样取索引 有一些方法： gp.count() gp.max() 等聚合 滑动窗口 缺失值处理 删除缺失值所在行或列 dropna(axis=0,how=&#39;any&#39;,inplace=False) 填充数据 se.fillna(value=se.mean()) 统计方法不多bb直接上例子 补充数据类型pandas 在读入数据存储为 DataFrame 或 Series 时会将值转为相应的类型，如下有对应 pandas 内和 python 原生： object : string int : integer float : float datetime : time bool : boolean var.dtype 查看变量的 dtype 字符串 Series 方法其中模式指正则表达式 方法 说明 cat 实现元素级的字符串连接操作，可指定分隔符 contains 返回表示各字符串是否含有指定模式的布尔型数组 count 模式的出现次数 endwith、startwith 相当于对各个元素执行末、始位判断 findall 计算各字符串的模式列表 get 获取各元素的第一个字符 join 根据指定的分隔符将 Series 中各元素的字符串连接起来 len 长度 lower、upper 逐元素转换大小写 match 正则匹配，逐元素 re.match pad 在字符串的左或右或左右添加空格 center 相当于 pad(side=’both’) repeat 各元素重复 replace 各元素替换 slice 各元素截取子串 split 各元素指定分隔符拆分 strip、rstrip、lstrip 去除空白符 案例： 有形如 &quot;type1, type2, ...&quot; 形式字符串作为每个值的一列，统计其中每个 type 的出现个数 "},{"title":"Hive 常用函数","date":"2022-01-16T12:50:44.000Z","url":"/2022/01/16/Data/Hive-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/","tags":[["Hive/Spark","/tags/Hive-Spark/"],["Functions","/tags/Functions/"],["Short-cuts","/tags/Short-cuts/"]],"categories":[["Data","/categories/Data/"]],"content":"字符串函数instr(stringA, stringB) 返回从 1 开始找到的 stringB 的下标号，若未找到则返回 0 substr(string, start, length) 返回子串，结合上方函数可执行定向截取 注意如 “2314124001” 若需要截取 “\\“ 之前的则用 substr(s,1,instr(s,’_’)-1)，即 substr 函数会取到左右的闭区间 Json 解析get_json_object 函数用法如 get_json_object(json_format_str,&#39;$.key1.key2[n].key3&#39;) 得到指定层级下的值，对列表值可以用 [*] 表示列表内的所有元素而非单个元素 json_tuple 函数用法如 json_tuple(json_format_str,&#39;key1&#39;,&#39;key2&#39;) 得到一个该 json 字段指定的一级 key 构成的表，是一个 UDTF，因此要结合 Lateral View 函数，例如： Explode官方解释：explode() 函数接受一个 array 或 map 类型的数据作为输入，然后将 array 或 map 里面的元素按照每行的形式输出（可见能快速处理 json 格式的字段） get_json_object 函数中可以用 [*] 表示列表格式内所有元素而非单个元素，后面能继续跟上 ‘key’ 得到对应 ‘value’ 的列表，形成一个 json 格式的字符串 同时结合正则表达式去除两端的大中括号，使用 split 后套上 explode 完成分解 Explode 是一个 UDTF，即由单行字段得到一个数据表的函数，不能直接和其他字段一起使用，因此需要结合 Lateral View Lateral View用法如 LATERAL VIEW udtf(expression) tableAlias As columnAlias Lateral View Outer 可以像表连接一样取 outer join 窗口函数几个名儿，看到就会了，格式如 func(col_if_needs) over(partition by col1, col2, ... order by col3, ...) 排序函数 row_number() —— 行严格递增 rank() —— 相同值取最高名次且占位 dense_rank() —— 相同值取最高但不占位 ntile(n) —— 将 partition 后的数据平均分成 n 个组，返回组序号 偏移函数 first_value() 和 last_value() 传入字段名，会随着数据的读入动态变化 lead(col, n, inplc) 和 lag(col, n, inplc) 向下或向上 n 行取值，若为空可替换为 inplc （可不指定则为 null） 聚合函数 函数略，用法可结合 rows between n preceding and m following —— 默认情况下都是 unbounded ，会聚合 partition 的整组，可替换前后为 current row 分布函数 cume_dist() 累计分布函数，闭区间 percent_rank() (当前行 -1) / (总行数 - 1) "},{"title":"Brief Tips","date":"2022-01-16T12:42:34.000Z","url":"/2022/01/16/hello-hexo/","tags":[["tips","/tags/tips/"],["hexo","/tags/hexo/"],["smp-cmd","/tags/smp-cmd/"]],"categories":[["short-cuts","/categories/short-cuts/"]],"content":"作为一个不是很想搞懂的小白，仅在此纪录一些以后更新常用命令或修改： 命令克隆主题先找到对应主题的 git 仓库，在主目录下执行类似下方 现主题指导 Kratos-Rebirth文章编辑配置在文章顶部信息区（Front-Matter）编辑配置类似下方 文章概要可以由在需要分割的地方加入 &lt;!-- more --&gt; 来实现 自制主题方法 改/加配置参考博客 目录结构 附上官方配置详解 ejs 语法大致按照 html 标准编写，引入一些新的语法格式部分如下： 标签 含义 &lt;% 脚本标签，用于流程控制 &lt;%_ 删除前面的空格符 &lt;%= 输出数据到模板 &lt;%- 输出非转义数据到模板 &lt;%# 注释 &lt;%% 输出字符串『&lt;%』 &gt;% 脚本结束标签 -%&gt; 结束时，删除换行符 _%&gt; 结束时，删除空格符 &lt;%- include(“index.ejs”) %&gt; 引入其他模板 Quick StartCreate a new post新建一篇博文 More info: Writing Run server 本地启动服务，可在  内查看改动效果，每次布局改动需要重启服务 More info: Server Generate static files生成本地静态文件，在编辑完博文后需要 g More info: Generating Deploy to remote sites发布新生成的静态文件到链接的 github 或其他 More info: Deployment"},{"title":"瞎编一篇简历","date":"2021-12-26T02:46:21.000Z","url":"/2021/12/26/Interview/interview/","tags":[["Expression","/tags/Expression/"]],"categories":[["Interview","/categories/Interview/"]],"content":"记录一些听来的或经历的面试经验简历篇 教育经历：校招学生写在前，但尽量简短，每条包含阶段所处学校及专业，总体或专业 GPA 即可（如果不是很高可以不写） 荣誉奖项等：如竞赛可简单介绍内容，但最好总体控制在页面 1/5 ，若奖项较多则仅列出重要性较高的几个即可 实习或工作经历：所属公司和部门，其中的工作内容精炼描述 —— 先写主要负责或参与什么内容，然后几行内讲清楚主要用到的工具和方法 项目经历：包括实验室项目和公开竞赛，以及自己完成的应用项目，每一条注意摘要描述所用工具和实现的效果，并展示工作量 专业技能： 编程语言：按照运用熟练度从高到低，熟悉一部分，了解一部分等（别吹过头写掌握了，真的牛除外） 分工作专业领域：如大数据常用工具 Hadoop，Spark 等可单列；机器学习，深度学习主要类库可单列；协同工作流辅助工具等可单列 其他部分：简要补充如数学、英语水平，以及相关的 github 页面或长期的博客 以上内容如果进行详细介绍的部分要注意自主加粗来凸显重点，如在记录项目或实习时按照 STAR 法则描述 情景、任务、动作、结果 时，可以加粗动作和结果部分，篇幅允许可适当描述克服的难点 适度吹牛简历上适度吹牛，如项目经历等可以不用完全独立完成，自己参与了一个环节并且对全局有较高的熟悉即可；道听途说，甚至是找师兄师姐做过的项目也行，只要对流程把握清晰，能在主动介绍的时候表达流畅，甚至不一定会被问 专业技能如算法和 coding 能力必要练习，且如实描述，在面试中必定实打实地考核相关能力 —— 此处算法指编程问题高效或通用算法，如 动态规划，记忆回溯等直接考察项；如机器学习，深度学习等算法需要论文体现能力，故不吹太满时可以背八股应对 编写推荐使用 Latex 编写排版，若自己有熟悉的本地编辑器可以获取一个一般的模板稍微修改内容即可，或者访问 LaTeX Tamplets 选择一个模板直接在线改好后导出（网站可能连接不是很稳定，但会在线保存）"}]